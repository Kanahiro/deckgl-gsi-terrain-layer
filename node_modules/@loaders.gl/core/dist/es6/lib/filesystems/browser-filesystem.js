export default class BrowserFileSystem {
  constructor(files, options = {}) {
    this._fetch = options.fetch || fetch;
    this.files = {};

    for (let i = 0; i < files.length; ++i) {
      const file = files[i];
      this.files[file.name] = file;
    }

    this.fetch = this.fetch.bind(this);
  }

  async fetch(path, options = {}) {
    if (path.includes('://')) {
      const fallbackFetch = options.fetch || this._fetch;
      return fallbackFetch(path, options);
    }

    const file = this.files[path];

    if (file) {
      const response = new Response(this.files[path]);
      Object.defineProperty(response, 'url', {
        value: path
      });
      return response;
    }

    return new Response(path, {
      status: 400,
      statusText: 'NOT FOUND'
    });
  }

  async readdir() {
    const files = [];

    for (const path in this.files) {
      files.push(path);
    }

    return files;
  }

  async stat(path, options) {
    const file = this.files[path];

    if (!file) {
      throw new Error("No such file: ".concat(path));
    }

    return {
      size: file.size
    };
  }

  async unlink(pathname) {
    delete this.files[pathname];
  }

  async open(pathname) {
    return this.files[pathname];
  }

  async read(fd, {
    buffer = null,
    offset = 0,
    length = buffer.byteLength,
    position = null
  }) {
    const file = fd;
    const arrayBuffer = await readFileSlice(file, position, position + length);
    return arrayBuffer;
  }

  async close(fd) {}

}

async function readFileSlice(file, start, end) {
  const slice = file.slice(start, end);
  return await new Promise((resolve, reject) => {
    const fileReader = new FileReader();

    fileReader.onload = event => resolve(event.target && event.target.result);

    fileReader.onerror = error => reject(error);

    fileReader.readAsArrayBuffer(slice);
  });
}
//# sourceMappingURL=browser-filesystem.js.map