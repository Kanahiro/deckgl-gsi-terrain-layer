import { assert } from '@loaders.gl/loader-utils';
import { concatenateChunksAsync, makeTransformIterator } from '@loaders.gl/loader-utils';
import { isLoaderObject } from '../loader-utils/normalize-loader';
import { normalizeOptions } from '../loader-utils/option-utils';
import { getLoaderContext } from '../loader-utils/context-utils';
import { getAsyncIteratorFromData, getReadableStream } from '../loader-utils/get-data';
import { getResourceUrlAndType } from '../utils/resource-utils';
import { selectLoader } from './select-loader';
import { parse } from './parse';
export async function parseInBatches(data, loaders, options, context) {
  assert(!context || typeof context !== 'string', 'parseInBatches no longer accepts final url');

  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
    context = options;
    options = loaders;
    loaders = null;
  }

  data = await data;
  options = options || {};
  const {
    url
  } = getResourceUrlAndType(data);
  const loader = await selectLoader(data, loaders, options);

  if (!loader) {
    return null;
  }

  options = normalizeOptions(options, loader, loaders, url);
  context = getLoaderContext({
    url,
    parseInBatches,
    parse,
    loaders
  }, options, context);
  return await parseWithLoaderInBatches(loader, data, options, context);
}

async function parseWithLoaderInBatches(loader, data, options, context) {
  const outputIterator = await parseToOutputIterator(loader, data, options, context);

  if (!options.metadata) {
    return outputIterator;
  }

  const metadataBatch = {
    batchType: 'metadata',
    metadata: {
      _loader: loader,
      _context: context
    },
    data: [],
    bytesUsed: 0
  };

  async function* makeMetadataBatchIterator(iterator) {
    yield metadataBatch;
    yield* iterator;
  }

  return makeMetadataBatchIterator(outputIterator);
}

async function parseToOutputIterator(loader, data, options, context) {
  if (loader.parseInBatches) {
    const inputIterator = await getAsyncIteratorFromData(data);
    const iteratorChain = applyInputTransforms(inputIterator, options);
    return await loader.parseInBatches(iteratorChain, options, context, loader);
  }

  if (loader.parseStreamInBatches) {
    const stream = await getReadableStream(data);

    if (stream) {
      if (options.transforms) {
        console.warn('options.transforms not implemented for loaders that use `parseStreamInBatches`');
      }

      return loader.parseStreamInBatches(stream, options, context);
    }
  }

  async function* parseChunkInBatches() {
    const inputIterator = await getAsyncIteratorFromData(data);
    const arrayBuffer = await concatenateChunksAsync(inputIterator);
    yield loader.parse(arrayBuffer, options, context, loader);
  }

  return await parseChunkInBatches();
}

function applyInputTransforms(inputIterator, options) {
  let iteratorChain = inputIterator;

  for (const Transform of options.transforms || []) {
    iteratorChain = makeTransformIterator(iteratorChain, Transform, options);
  }

  return iteratorChain;
}
//# sourceMappingURL=parse-in-batches.js.map