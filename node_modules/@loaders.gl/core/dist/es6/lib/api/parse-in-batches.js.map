{"version":3,"sources":["../../../../src/lib/api/parse-in-batches.js"],"names":["assert","concatenateChunksAsync","makeTransformIterator","isLoaderObject","normalizeOptions","getLoaderContext","getAsyncIteratorFromData","getReadableStream","getResourceUrlAndType","selectLoader","parse","parseInBatches","data","loaders","options","context","Array","isArray","url","loader","parseWithLoaderInBatches","outputIterator","parseToOutputIterator","metadata","metadataBatch","batchType","_loader","_context","bytesUsed","makeMetadataBatchIterator","iterator","inputIterator","iteratorChain","applyInputTransforms","parseStreamInBatches","stream","transforms","console","warn","parseChunkInBatches","arrayBuffer","Transform"],"mappings":"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","sourcesContent":["import {assert} from '@loaders.gl/loader-utils';\nimport {concatenateChunksAsync, makeTransformIterator} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getLoaderContext} from '../loader-utils/context-utils';\nimport {getAsyncIteratorFromData, getReadableStream} from '../loader-utils/get-data';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport {parse} from './parse';\n\nexport async function parseInBatches(data, loaders, options, context) {\n  assert(!context || typeof context !== 'string', 'parseInBatches no longer accepts final url');\n\n  // Signature: parseInBatches(data, options, url) - Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const {url} = getResourceUrlAndType(data);\n\n  // Chooses a loader and normalizes it\n  // Note - only uses URL and contentType for streams and iterator inputs\n  const loader = await selectLoader(data, loaders, options);\n  // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, loaders, url);\n  context = getLoaderContext({url, parseInBatches, parse, loaders}, options, context);\n\n  return await parseWithLoaderInBatches(loader, data, options, context);\n}\n\n/**\n * Loader has beens selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n\n  // Generate metadata batch if requested\n  if (!options.metadata) {\n    return outputIterator;\n  }\n\n  const metadataBatch = {\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    // Populate with some default fields to avoid crashing\n    data: [],\n    bytesUsed: 0\n  };\n\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n\n  return makeMetadataBatchIterator(outputIterator);\n}\n\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parseStreamInBatches` (limited), `parse` (fallback)\n */\nasync function parseToOutputIterator(loader, data, options, context) {\n  if (loader.parseInBatches) {\n    const inputIterator = await getAsyncIteratorFromData(data);\n\n    const iteratorChain = applyInputTransforms(inputIterator, options);\n\n    return await loader.parseInBatches(iteratorChain, options, context, loader);\n  }\n\n  if (loader.parseStreamInBatches) {\n    const stream = await getReadableStream(data);\n    if (stream) {\n      if (options.transforms) {\n        // eslint-disable-next-line\n        console.warn(\n          'options.transforms not implemented for loaders that use `parseStreamInBatches`'\n        );\n      }\n      return loader.parseStreamInBatches(stream, options, context);\n    }\n  }\n\n  // Fallback: load atomically using `parse` concatenating input iterator into single chunk\n  async function* parseChunkInBatches() {\n    const inputIterator = await getAsyncIteratorFromData(data);\n    const arrayBuffer = await concatenateChunksAsync(inputIterator);\n    // yield a single batch, the output from loader.parse()\n    yield loader.parse(arrayBuffer, options, context, loader);\n  }\n\n  return await parseChunkInBatches();\n}\n\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nfunction applyInputTransforms(inputIterator, options) {\n  let iteratorChain = inputIterator;\n  for (const Transform of options.transforms || []) {\n    // @ts-ignore\n    iteratorChain = makeTransformIterator(iteratorChain, Transform, options);\n  }\n  return iteratorChain;\n}\n"],"file":"parse-in-batches.js"}