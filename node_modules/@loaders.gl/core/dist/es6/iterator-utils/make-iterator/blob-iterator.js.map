{"version":3,"sources":["../../../../src/iterator-utils/make-iterator/blob-iterator.js"],"names":["DEFAULT_CHUNK_SIZE","makeBlobIterator","file","options","chunkSize","offset","size","end","chunk","readFileSlice","Promise","resolve","reject","slice","fileReader","FileReader","onload","event","target","result","onerror","error","readAsArrayBuffer"],"mappings":"AAEA,MAAMA,kBAAkB,GAAG,OAAO,IAAlC;AAEA,OAAO,gBAAgBC,gBAAhB,CAAiCC,IAAjC,EAAuCC,OAAO,GAAG,EAAjD,EAAqD;AAC1D,QAAMC,SAAS,GAAGD,OAAO,CAACC,SAAR,IAAqBJ,kBAAvC;AAEA,MAAIK,MAAM,GAAG,CAAb;;AACA,SAAOA,MAAM,GAAGH,IAAI,CAACI,IAArB,EAA2B;AACzB,UAAMC,GAAG,GAAGF,MAAM,GAAGD,SAArB;AAEA,UAAMI,KAAK,GAAG,MAAMC,aAAa,CAACP,IAAD,EAAOG,MAAP,EAAeE,GAAf,CAAjC;AAEAF,IAAAA,MAAM,GAAGE,GAAT;AACA,UAAMC,KAAN;AACD;AACF;AAED,OAAO,eAAeC,aAAf,CAA6BP,IAA7B,EAAmCG,MAAnC,EAA2CE,GAA3C,EAAgD;AACrD,SAAO,MAAM,IAAIG,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAI5C,UAAMC,KAAK,GAAGX,IAAI,CAACW,KAAL,CAAWR,MAAX,EAAmBE,GAAnB,CAAd;AAEA,UAAMO,UAAU,GAAG,IAAIC,UAAJ,EAAnB;;AACAD,IAAAA,UAAU,CAACE,MAAX,GAAoBC,KAAK,IAAIN,OAAO,CAACM,KAAK,CAACC,MAAN,IAAgBD,KAAK,CAACC,MAAN,CAAaC,MAA9B,CAApC;;AACAL,IAAAA,UAAU,CAACM,OAAX,GAAqBC,KAAK,IAAIT,MAAM,CAACS,KAAD,CAApC;;AACAP,IAAAA,UAAU,CAACQ,iBAAX,CAA6BT,KAA7B;AACD,GAVY,CAAb;AAWD","sourcesContent":["/* global FileReader */\n\nconst DEFAULT_CHUNK_SIZE = 1024 * 1024; // 1MB â€” biggest value that keeps UI responsive\n\nexport async function* makeBlobIterator(file, options = {}) {\n  const chunkSize = options.chunkSize || DEFAULT_CHUNK_SIZE;\n\n  let offset = 0;\n  while (offset < file.size) {\n    const end = offset + chunkSize;\n\n    const chunk = await readFileSlice(file, offset, end);\n\n    offset = end;\n    yield chunk;\n  }\n}\n\nexport async function readFileSlice(file, offset, end) {\n  return await new Promise((resolve, reject) => {\n    // The trick when reading File objects is to read successive \"slices\" of the File\n    // Per spec https://w3c.github.io/FileAPI/, slicing a File should only update the start and end fields\n    // Actually reading from file should happen in `readAsArrayBuffer` (and as far we can tell it does)\n    const slice = file.slice(offset, end);\n\n    const fileReader = new FileReader();\n    fileReader.onload = event => resolve(event.target && event.target.result);\n    fileReader.onerror = error => reject(error);\n    fileReader.readAsArrayBuffer(slice);\n  });\n}\n"],"file":"blob-iterator.js"}