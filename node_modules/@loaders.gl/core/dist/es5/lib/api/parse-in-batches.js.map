{"version":3,"sources":["../../../../src/lib/api/parse-in-batches.js"],"names":["parseInBatches","data","loaders","options","context","Array","isArray","url","loader","parse","parseWithLoaderInBatches","makeMetadataBatchIterator","iterator","metadataBatch","parseToOutputIterator","outputIterator","metadata","batchType","_loader","_context","bytesUsed","parseChunkInBatches","inputIterator","arrayBuffer","iteratorChain","applyInputTransforms","parseStreamInBatches","stream","transforms","console","warn","Transform"],"mappings":"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","sourcesContent":["import {assert} from '@loaders.gl/loader-utils';\nimport {concatenateChunksAsync, makeTransformIterator} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getLoaderContext} from '../loader-utils/context-utils';\nimport {getAsyncIteratorFromData, getReadableStream} from '../loader-utils/get-data';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport {parse} from './parse';\n\nexport async function parseInBatches(data, loaders, options, context) {\n  assert(!context || typeof context !== 'string', 'parseInBatches no longer accepts final url');\n\n  // Signature: parseInBatches(data, options, url) - Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const {url} = getResourceUrlAndType(data);\n\n  // Chooses a loader and normalizes it\n  // Note - only uses URL and contentType for streams and iterator inputs\n  const loader = await selectLoader(data, loaders, options);\n  // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, loaders, url);\n  context = getLoaderContext({url, parseInBatches, parse, loaders}, options, context);\n\n  return await parseWithLoaderInBatches(loader, data, options, context);\n}\n\n/**\n * Loader has beens selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n\n  // Generate metadata batch if requested\n  if (!options.metadata) {\n    return outputIterator;\n  }\n\n  const metadataBatch = {\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    // Populate with some default fields to avoid crashing\n    data: [],\n    bytesUsed: 0\n  };\n\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n\n  return makeMetadataBatchIterator(outputIterator);\n}\n\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parseStreamInBatches` (limited), `parse` (fallback)\n */\nasync function parseToOutputIterator(loader, data, options, context) {\n  if (loader.parseInBatches) {\n    const inputIterator = await getAsyncIteratorFromData(data);\n\n    const iteratorChain = applyInputTransforms(inputIterator, options);\n\n    return await loader.parseInBatches(iteratorChain, options, context, loader);\n  }\n\n  if (loader.parseStreamInBatches) {\n    const stream = await getReadableStream(data);\n    if (stream) {\n      if (options.transforms) {\n        // eslint-disable-next-line\n        console.warn(\n          'options.transforms not implemented for loaders that use `parseStreamInBatches`'\n        );\n      }\n      return loader.parseStreamInBatches(stream, options, context);\n    }\n  }\n\n  // Fallback: load atomically using `parse` concatenating input iterator into single chunk\n  async function* parseChunkInBatches() {\n    const inputIterator = await getAsyncIteratorFromData(data);\n    const arrayBuffer = await concatenateChunksAsync(inputIterator);\n    // yield a single batch, the output from loader.parse()\n    yield loader.parse(arrayBuffer, options, context, loader);\n  }\n\n  return await parseChunkInBatches();\n}\n\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nfunction applyInputTransforms(inputIterator, options) {\n  let iteratorChain = inputIterator;\n  for (const Transform of options.transforms || []) {\n    // @ts-ignore\n    iteratorChain = makeTransformIterator(iteratorChain, Transform, options);\n  }\n  return iteratorChain;\n}\n"],"file":"parse-in-batches.js"}