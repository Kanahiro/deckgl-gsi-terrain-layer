{"version":3,"sources":["../../../../src/lib/api/encode.js"],"names":["concatenateArrayBuffers","resolvePath","isBrowser","writeFile","fetchFile","getTemporaryFilename","filename","encode","data","writer","options","url","encodeSync","encodeText","TextEncoder","encodeInBatches","batches","chunks","batch","push","encodeURLtoURL","tmpInputFilename","tmpOutputFilename","outputFilename","response","arrayBuffer","Error","text","TextDecoder","decode","dataIterator","getIterator","table","start","end","length","inputUrl","outputUrl"],"mappings":"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","sourcesContent":["/* global TextEncoder, TextDecoder */\n/** @typedef {import('./encode')} types */\nimport {concatenateArrayBuffers, resolvePath} from '@loaders.gl/loader-utils';\nimport {isBrowser} from '@loaders.gl/loader-utils';\nimport {writeFile} from '../fetch/write-file';\nimport {fetchFile} from '../fetch/fetch-file';\n\n/**\n * @param {string} filename\n * @returns {string}\n * @todo Move to utils\n */\nfunction getTemporaryFilename(filename) {\n  return `/tmp/${filename}`;\n}\n\nexport async function encode(data, writer, options, url) {\n  if (writer.encode) {\n    return await writer.encode(data, options);\n  }\n\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n\n  if (writer.encodeText) {\n    return new TextEncoder().encode(await writer.encodeText(data, options));\n  }\n\n  if (writer.encodeInBatches) {\n    // Create an iterator representing the data\n    // TODO - Assumes this is a table\n    const batches = encodeInBatches(data, writer, options);\n\n    // Concatenate the output\n    const chunks = [];\n    for await (const batch of batches) {\n      chunks.push(batch);\n    }\n    // @ts-ignore\n    return await concatenateArrayBuffers(...chunks);\n  }\n\n  if (!isBrowser && writer.encodeURLtoURL) {\n    // TODO - how to generate filenames with correct extensions?\n    const tmpInputFilename = getTemporaryFilename('input');\n    await writeFile(tmpInputFilename, data);\n\n    const tmpOutputFilename = getTemporaryFilename('output');\n\n    const outputFilename = await encodeURLtoURL(\n      tmpInputFilename,\n      tmpOutputFilename,\n      writer,\n      options\n    );\n\n    const response = await fetchFile(outputFilename);\n    return response.arrayBuffer();\n  }\n\n  throw new Error('Writer could not encode data');\n}\n\nexport function encodeSync(data, writer, options, url) {\n  if (writer.encodeSync) {\n    return writer.encodeSync(data, options);\n  }\n  throw new Error('Writer could not synchronously encode data');\n}\n\nexport async function encodeText(data, writer, options, url) {\n  if (writer.text && writer.encodeText) {\n    return await writer.encodeText(data, options);\n  }\n\n  if (writer.text && (writer.encode || writer.encodeInBatches)) {\n    const arrayBuffer = await encode(data, writer, options);\n    return new TextDecoder().decode(arrayBuffer);\n  }\n\n  throw new Error('Writer could not encode data as text');\n}\n\nexport function encodeInBatches(data, writer, options, url) {\n  if (writer.encodeInBatches) {\n    const dataIterator = getIterator(data);\n    return writer.encodeInBatches(dataIterator, options);\n  }\n  // TODO -fall back to atomic encode?\n  throw new Error('Writer could not encode data in batches');\n}\n\nfunction getIterator(data) {\n  // TODO - this is an unacceptable hack!!!\n  const dataIterator = [{table: data, start: 0, end: data.length}];\n  return dataIterator;\n}\n\nexport async function encodeURLtoURL(inputUrl, outputUrl, writer, options) {\n  inputUrl = resolvePath(inputUrl);\n  outputUrl = resolvePath(outputUrl);\n  if (isBrowser || !writer.encodeURLtoURL) {\n    throw new Error();\n  }\n  const outputFilename = await writer.encodeURLtoURL(inputUrl, outputUrl, options);\n  return outputFilename;\n}\n"],"file":"encode.js"}