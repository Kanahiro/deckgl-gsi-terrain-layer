{"version":3,"sources":["../../../../src/lib/api/parse-in-batches.js"],"names":["assert","concatenateChunksAsync","makeTransformIterator","isLoaderObject","normalizeOptions","getLoaderContext","getAsyncIteratorFromData","getReadableStream","getResourceUrlAndType","selectLoader","parse","parseInBatches","data","loaders","options","context","Array","isArray","url","loader","parseWithLoaderInBatches","makeMetadataBatchIterator","iterator","metadataBatch","parseToOutputIterator","outputIterator","metadata","batchType","_loader","_context","bytesUsed","parseChunkInBatches","inputIterator","arrayBuffer","iteratorChain","applyInputTransforms","parseStreamInBatches","stream","transforms","console","warn","Transform"],"mappings":"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","sourcesContent":["import {assert} from '@loaders.gl/loader-utils';\nimport {concatenateChunksAsync, makeTransformIterator} from '@loaders.gl/loader-utils';\nimport {isLoaderObject} from '../loader-utils/normalize-loader';\nimport {normalizeOptions} from '../loader-utils/option-utils';\nimport {getLoaderContext} from '../loader-utils/context-utils';\nimport {getAsyncIteratorFromData, getReadableStream} from '../loader-utils/get-data';\nimport {getResourceUrlAndType} from '../utils/resource-utils';\nimport {selectLoader} from './select-loader';\n\n// Ensure `parse` is available in context if loader falls back to `parse`\nimport {parse} from './parse';\n\nexport async function parseInBatches(data, loaders, options, context) {\n  assert(!context || typeof context !== 'string', 'parseInBatches no longer accepts final url');\n\n  // Signature: parseInBatches(data, options, url) - Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    context = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  data = await data; // Resolve any promise\n  options = options || {};\n\n  // Extract a url for auto detection\n  const {url} = getResourceUrlAndType(data);\n\n  // Chooses a loader and normalizes it\n  // Note - only uses URL and contentType for streams and iterator inputs\n  const loader = await selectLoader(data, loaders, options);\n  // Note: if options.nothrow was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = normalizeOptions(options, loader, loaders, url);\n  context = getLoaderContext({url, parseInBatches, parse, loaders}, options, context);\n\n  return await parseWithLoaderInBatches(loader, data, options, context);\n}\n\n/**\n * Loader has beens selected and context has been prepared, see if we need to emit a metadata batch\n */\nasync function parseWithLoaderInBatches(loader, data, options, context) {\n  const outputIterator = await parseToOutputIterator(loader, data, options, context);\n\n  // Generate metadata batch if requested\n  if (!options.metadata) {\n    return outputIterator;\n  }\n\n  const metadataBatch = {\n    batchType: 'metadata',\n    metadata: {\n      _loader: loader,\n      _context: context\n    },\n    // Populate with some default fields to avoid crashing\n    data: [],\n    bytesUsed: 0\n  };\n\n  async function* makeMetadataBatchIterator(iterator) {\n    yield metadataBatch;\n    yield* iterator;\n  }\n\n  return makeMetadataBatchIterator(outputIterator);\n}\n\n/**\n * Prep work is done, now it is time to start parsing into an output operator\n * The approach depends on which parse function the loader exposes\n * `parseInBatches` (preferred), `parseStreamInBatches` (limited), `parse` (fallback)\n */\nasync function parseToOutputIterator(loader, data, options, context) {\n  if (loader.parseInBatches) {\n    const inputIterator = await getAsyncIteratorFromData(data);\n\n    const iteratorChain = applyInputTransforms(inputIterator, options);\n\n    return await loader.parseInBatches(iteratorChain, options, context, loader);\n  }\n\n  if (loader.parseStreamInBatches) {\n    const stream = await getReadableStream(data);\n    if (stream) {\n      if (options.transforms) {\n        // eslint-disable-next-line\n        console.warn(\n          'options.transforms not implemented for loaders that use `parseStreamInBatches`'\n        );\n      }\n      return loader.parseStreamInBatches(stream, options, context);\n    }\n  }\n\n  // Fallback: load atomically using `parse` concatenating input iterator into single chunk\n  async function* parseChunkInBatches() {\n    const inputIterator = await getAsyncIteratorFromData(data);\n    const arrayBuffer = await concatenateChunksAsync(inputIterator);\n    // yield a single batch, the output from loader.parse()\n    yield loader.parse(arrayBuffer, options, context, loader);\n  }\n\n  return await parseChunkInBatches();\n}\n\n/**\n * Create an iterator chain with any transform iterators (crypto, decompression)\n * @param inputIterator\n * @param options\n */\nfunction applyInputTransforms(inputIterator, options) {\n  let iteratorChain = inputIterator;\n  for (const Transform of options.transforms || []) {\n    // @ts-ignore\n    iteratorChain = makeTransformIterator(iteratorChain, Transform, options);\n  }\n  return iteratorChain;\n}\n"],"file":"parse-in-batches.js"}