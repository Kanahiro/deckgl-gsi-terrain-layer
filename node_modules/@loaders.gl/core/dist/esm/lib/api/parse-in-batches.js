import _regeneratorRuntime from "@babel/runtime/regenerator";
import _asyncToGenerator from "@babel/runtime/helpers/esm/asyncToGenerator";
import _wrapAsyncGenerator from "@babel/runtime/helpers/esm/wrapAsyncGenerator";
import _awaitAsyncGenerator from "@babel/runtime/helpers/esm/awaitAsyncGenerator";
import _asyncIterator from "@babel/runtime/helpers/esm/asyncIterator";
import _asyncGeneratorDelegate from "@babel/runtime/helpers/esm/asyncGeneratorDelegate";

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

import { assert } from '@loaders.gl/loader-utils';
import { concatenateChunksAsync, makeTransformIterator } from '@loaders.gl/loader-utils';
import { isLoaderObject } from '../loader-utils/normalize-loader';
import { normalizeOptions } from '../loader-utils/option-utils';
import { getLoaderContext } from '../loader-utils/context-utils';
import { getAsyncIteratorFromData, getReadableStream } from '../loader-utils/get-data';
import { getResourceUrlAndType } from '../utils/resource-utils';
import { selectLoader } from './select-loader';
import { parse } from './parse';
export function parseInBatches(_x2, _x3, _x4, _x5) {
  return _parseInBatches.apply(this, arguments);
}

function _parseInBatches() {
  _parseInBatches = _asyncToGenerator(_regeneratorRuntime.mark(function _callee(data, loaders, options, context) {
    var _getResourceUrlAndTyp, url, loader;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assert(!context || typeof context !== 'string', 'parseInBatches no longer accepts final url');

            if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {
              context = options;
              options = loaders;
              loaders = null;
            }

            _context.next = 4;
            return data;

          case 4:
            data = _context.sent;
            options = options || {};
            _getResourceUrlAndTyp = getResourceUrlAndType(data), url = _getResourceUrlAndTyp.url;
            _context.next = 9;
            return selectLoader(data, loaders, options);

          case 9:
            loader = _context.sent;

            if (loader) {
              _context.next = 12;
              break;
            }

            return _context.abrupt("return", null);

          case 12:
            options = normalizeOptions(options, loader, loaders, url);
            context = getLoaderContext({
              url: url,
              parseInBatches: parseInBatches,
              parse: parse,
              loaders: loaders
            }, options, context);
            _context.next = 16;
            return parseWithLoaderInBatches(loader, data, options, context);

          case 16:
            return _context.abrupt("return", _context.sent);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseInBatches.apply(this, arguments);
}

function parseWithLoaderInBatches(_x6, _x7, _x8, _x9) {
  return _parseWithLoaderInBatches.apply(this, arguments);
}

function _parseWithLoaderInBatches() {
  _parseWithLoaderInBatches = _asyncToGenerator(_regeneratorRuntime.mark(function _callee3(loader, data, options, context) {
    var outputIterator, metadataBatch, makeMetadataBatchIterator, _makeMetadataBatchIterator;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _makeMetadataBatchIterator = function _makeMetadataBatchIte2() {
              _makeMetadataBatchIterator = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee2(iterator) {
                return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                  while (1) {
                    switch (_context2.prev = _context2.next) {
                      case 0:
                        _context2.next = 2;
                        return metadataBatch;

                      case 2:
                        return _context2.delegateYield(_asyncGeneratorDelegate(_asyncIterator(iterator), _awaitAsyncGenerator), "t0", 3);

                      case 3:
                      case "end":
                        return _context2.stop();
                    }
                  }
                }, _callee2);
              }));
              return _makeMetadataBatchIterator.apply(this, arguments);
            };

            makeMetadataBatchIterator = function _makeMetadataBatchIte(_x) {
              return _makeMetadataBatchIterator.apply(this, arguments);
            };

            _context3.next = 4;
            return parseToOutputIterator(loader, data, options, context);

          case 4:
            outputIterator = _context3.sent;

            if (options.metadata) {
              _context3.next = 7;
              break;
            }

            return _context3.abrupt("return", outputIterator);

          case 7:
            metadataBatch = {
              batchType: 'metadata',
              metadata: {
                _loader: loader,
                _context: context
              },
              data: [],
              bytesUsed: 0
            };
            return _context3.abrupt("return", makeMetadataBatchIterator(outputIterator));

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _parseWithLoaderInBatches.apply(this, arguments);
}

function parseToOutputIterator(_x10, _x11, _x12, _x13) {
  return _parseToOutputIterator.apply(this, arguments);
}

function _parseToOutputIterator() {
  _parseToOutputIterator = _asyncToGenerator(_regeneratorRuntime.mark(function _callee5(loader, data, options, context) {
    var inputIterator, iteratorChain, stream, parseChunkInBatches, _parseChunkInBatches;

    return _regeneratorRuntime.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            _parseChunkInBatches = function _parseChunkInBatches3() {
              _parseChunkInBatches = _wrapAsyncGenerator(_regeneratorRuntime.mark(function _callee4() {
                var inputIterator, arrayBuffer;
                return _regeneratorRuntime.wrap(function _callee4$(_context4) {
                  while (1) {
                    switch (_context4.prev = _context4.next) {
                      case 0:
                        _context4.next = 2;
                        return _awaitAsyncGenerator(getAsyncIteratorFromData(data));

                      case 2:
                        inputIterator = _context4.sent;
                        _context4.next = 5;
                        return _awaitAsyncGenerator(concatenateChunksAsync(inputIterator));

                      case 5:
                        arrayBuffer = _context4.sent;
                        _context4.next = 8;
                        return loader.parse(arrayBuffer, options, context, loader);

                      case 8:
                      case "end":
                        return _context4.stop();
                    }
                  }
                }, _callee4);
              }));
              return _parseChunkInBatches.apply(this, arguments);
            };

            parseChunkInBatches = function _parseChunkInBatches2() {
              return _parseChunkInBatches.apply(this, arguments);
            };

            if (!loader.parseInBatches) {
              _context5.next = 10;
              break;
            }

            _context5.next = 5;
            return getAsyncIteratorFromData(data);

          case 5:
            inputIterator = _context5.sent;
            iteratorChain = applyInputTransforms(inputIterator, options);
            _context5.next = 9;
            return loader.parseInBatches(iteratorChain, options, context, loader);

          case 9:
            return _context5.abrupt("return", _context5.sent);

          case 10:
            if (!loader.parseStreamInBatches) {
              _context5.next = 17;
              break;
            }

            _context5.next = 13;
            return getReadableStream(data);

          case 13:
            stream = _context5.sent;

            if (!stream) {
              _context5.next = 17;
              break;
            }

            if (options.transforms) {
              console.warn('options.transforms not implemented for loaders that use `parseStreamInBatches`');
            }

            return _context5.abrupt("return", loader.parseStreamInBatches(stream, options, context));

          case 17:
            _context5.next = 19;
            return parseChunkInBatches();

          case 19:
            return _context5.abrupt("return", _context5.sent);

          case 20:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _parseToOutputIterator.apply(this, arguments);
}

function applyInputTransforms(inputIterator, options) {
  var iteratorChain = inputIterator;

  var _iterator = _createForOfIteratorHelper(options.transforms || []),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var Transform = _step.value;
      iteratorChain = makeTransformIterator(iteratorChain, Transform, options);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return iteratorChain;
}
//# sourceMappingURL=parse-in-batches.js.map