{"version":3,"sources":["../../../../src/lib/parsers/parse-to-image.js"],"names":["getBlobOrSVGDataUrl","parseToImage","arrayBuffer","options","url","blobOrDataUrl","URL","self","webkitURL","objectUrl","createObjectURL","loadToImage","revokeObjectURL","image","Image","src","decode","Promise","resolve","reject","onload","onerror","err","Error","error"],"mappings":";;AACA,SAAQA,mBAAR,QAAkC,aAAlC;AAGA,wBAA8BC,YAA9B;AAAA;AAAA;;;6DAAe,iBAA4BC,WAA5B,EAAyCC,OAAzC,EAAkDC,GAAlD;AAAA;AAAA;AAAA;AAAA;AAAA;AAKPC,YAAAA,aALO,GAKSL,mBAAmB,CAACE,WAAD,EAAcE,GAAd,CAL5B;AAMPE,YAAAA,GANO,GAMDC,IAAI,CAACD,GAAL,IAAYC,IAAI,CAACC,SANhB;AAOPC,YAAAA,SAPO,GAOK,OAAOJ,aAAP,KAAyB,QAAzB,IAAqCC,GAAG,CAACI,eAAJ,CAAoBL,aAApB,CAP1C;AAAA;AAAA;AAAA,mBASEM,WAAW,CAACF,SAAS,IAAIJ,aAAd,EAA6BF,OAA7B,CATb;;AAAA;AAAA;;AAAA;AAAA;;AAWX,gBAAIM,SAAJ,EAAe;AACbH,cAAAA,GAAG,CAACM,eAAJ,CAAoBH,SAApB;AACD;;AAbU;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAiBf,gBAAsBE,WAAtB;AAAA;AAAA;;;4DAAO,kBAA2BP,GAA3B,EAAgCD,OAAhC;AAAA;AAAA;AAAA;AAAA;AAAA;AACCU,YAAAA,KADD,GACS,IAAIC,KAAJ,EADT;AAELD,YAAAA,KAAK,CAACE,GAAN,GAAYX,GAAZ;;AAFK,kBAWDD,OAAO,CAACU,KAAR,IAAiBV,OAAO,CAACU,KAAR,CAAcG,MAA/B,IAAyCH,KAAK,CAACG,MAX9C;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAYGH,KAAK,CAACG,MAAN,EAZH;;AAAA;AAAA,8CAaIH,KAbJ;;AAAA;AAAA;AAAA,mBAiBQ,IAAII,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC5C,kBAAI;AACFN,gBAAAA,KAAK,CAACO,MAAN,GAAe;AAAA,yBAAMF,OAAO,CAACL,KAAD,CAAb;AAAA,iBAAf;;AACAA,gBAAAA,KAAK,CAACQ,OAAN,GAAgB,UAAAC,GAAG;AAAA,yBAAIH,MAAM,CAAC,IAAII,KAAJ,gCAAkCnB,GAAlC,eAA0CkB,GAA1C,EAAD,CAAV;AAAA,iBAAnB;AACD,eAHD,CAGE,OAAOE,KAAP,EAAc;AACdL,gBAAAA,MAAM,CAACK,KAAD,CAAN;AACD;AACF,aAPY,CAjBR;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["/* global self, Image */\nimport {getBlobOrSVGDataUrl} from './svg-utils';\n\n// Parses html image from array buffer\nexport default async function parseToImage(arrayBuffer, options, url) {\n  // Note: image parsing requires conversion to Blob (for createObjectURL).\n  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...\n  // But presumably not worth adding 'blob' flag to loader objects?\n\n  const blobOrDataUrl = getBlobOrSVGDataUrl(arrayBuffer, url);\n  const URL = self.URL || self.webkitURL;\n  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);\n  try {\n    return await loadToImage(objectUrl || blobOrDataUrl, options);\n  } finally {\n    if (objectUrl) {\n      URL.revokeObjectURL(objectUrl);\n    }\n  }\n}\n\nexport async function loadToImage(url, options) {\n  const image = new Image();\n  image.src = url;\n\n  // The `image.onload()` callback does not guarantee that the image has been decoded\n  // so a main thread \"freeze\" can be incurred when using the image for the first time.\n  // `Image.decode()` returns a promise that completes when image is decoded.\n\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode\n  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`\n  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11\n  if (options.image && options.image.decode && image.decode) {\n    await image.decode();\n    return image;\n  }\n\n  // Create a promise that tracks onload/onerror callbacks\n  return await new Promise((resolve, reject) => {\n    try {\n      image.onload = () => resolve(image);\n      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"],"file":"parse-to-image.js"}