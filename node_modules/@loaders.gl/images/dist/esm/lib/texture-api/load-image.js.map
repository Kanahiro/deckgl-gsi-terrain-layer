{"version":3,"sources":["../../../../src/lib/texture-api/load-image.js"],"names":["assert","parseImage","getImageSize","generateUrl","deepLoad","shallowLoad","loadImage","getUrl","options","getImageUrls","imageUrls","urlOptions","mipLevels","image","getMipmappedImageUrls","urls","url","lod","width","height","getMipLevels","push","mipLevel","length","Math","floor","log2","max"],"mappings":"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","sourcesContent":["import assert from '../utils/assert';\nimport parseImage from '../parsers/parse-image';\nimport {getImageSize} from '../category-api/parsed-image-api';\nimport {generateUrl} from './generate-url';\nimport {deepLoad, shallowLoad} from './deep-load';\n\nexport async function loadImage(getUrl, options = {}) {\n  const imageUrls = await getImageUrls(getUrl, options);\n  return await deepLoad(imageUrls, parseImage, options);\n}\n\nexport async function getImageUrls(getUrl, options, urlOptions = {}) {\n  const mipLevels = (options && options.image && options.image.mipLevels) || 0;\n  return mipLevels !== 0\n    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)\n    : generateUrl(getUrl, options, urlOptions);\n}\n\nasync function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {\n  const urls = [];\n\n  // If no mip levels supplied, we need to load the level 0 image and calculate based on size\n  if (mipLevels === 'auto') {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: 0});\n    const image = await shallowLoad(url, parseImage, options);\n\n    const {width, height} = getImageSize(image);\n    mipLevels = getMipLevels({width, height});\n\n    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?\n    urls.push(url);\n  }\n\n  // We now know how many mipLevels we need, remaining image urls can now be constructed\n  assert(mipLevels > 0);\n\n  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {\n    const url = generateUrl(getUrl, options, {...urlOptions, lod: mipLevel});\n    urls.push(url);\n  }\n\n  return urls;\n}\n\n// Calculates number of mipmaps based on texture size (log2)\nexport function getMipLevels({width, height}) {\n  return 1 + Math.floor(Math.log2(Math.max(width, height)));\n}\n"],"file":"load-image.js"}