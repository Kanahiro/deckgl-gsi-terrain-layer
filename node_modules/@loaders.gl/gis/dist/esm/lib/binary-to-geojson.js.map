{"version":3,"sources":["../../../src/lib/binary-to-geojson.js"],"names":["binaryToGeoJson","data","type","format","parseGeometry","dataArray","normalizeInput","deduceReturnType","parseFeatureCollection","isHeterogeneousType","Boolean","points","lines","polygons","parseType","features","push","length","featureIds","globalFeatureIds","numericProps","properties","lastIndex","lastValue","value","i","currValue","parseFeature","startIndex","endIndex","geometry","parseProperties","Object","assign","key","pointToGeoJson","lineStringToGeoJson","polygonToGeoJson","Error","Infinity","positions","polygonIndices","filter","x","primitivePolygonIndices","multi","coordinates","startRingIndex","endRingIndex","ringCoordinates","ringToGeoJson","startPolygonIndex","endPolygonIndex","polygonCoordinates","pathIndices","size","j","Array","from","subarray"],"mappings":"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","sourcesContent":["export function binaryToGeoJson(data, type, format) {\n  if (format === 'geometry') {\n    return parseGeometry(data);\n  }\n\n  const dataArray = normalizeInput(data, type);\n\n  switch (deduceReturnType(dataArray)) {\n    case 'Geometry':\n      return parseGeometry(dataArray[0]);\n    case 'FeatureCollection':\n      return parseFeatureCollection(dataArray);\n    default:\n      break;\n  }\n\n  return null;\n}\n\n// Normalize features\n// Return an array of data objects, each of which have a type key\nfunction normalizeInput(data, type) {\n  const isHeterogeneousType = Boolean(data.points || data.lines || data.polygons);\n\n  if (!isHeterogeneousType) {\n    data.type = type || parseType(data);\n    return [data];\n  }\n\n  const features = [];\n  if (data.points) {\n    data.points.type = 'Point';\n    features.push(data.points);\n  }\n  if (data.lines) {\n    data.lines.type = 'LineString';\n    features.push(data.lines);\n  }\n  if (data.polygons) {\n    data.polygons.type = 'Polygon';\n    features.push(data.polygons);\n  }\n  return features;\n}\n\n// Determine whether a geometry or feature collection should be returned\n// If the input data doesn't have property identifiers, returns a single geometry\nfunction deduceReturnType(dataArray) {\n  // If more than one item in dataArray, multiple geometry types, must be a featurecollection\n  if (dataArray.length > 1) {\n    return 'FeatureCollection';\n  }\n\n  const data = dataArray[0];\n  if (!(data.featureIds || data.globalFeatureIds || data.numericProps || data.properties)) {\n    return 'Geometry';\n  }\n\n  return 'FeatureCollection';\n}\n\n/** Parse input binary data and return an array of GeoJSON Features */\nfunction parseFeatureCollection(dataArray) {\n  const features = [];\n  for (const data of dataArray) {\n    let lastIndex = 0;\n    let lastValue = data.featureIds.value[0];\n\n    // Need to deduce start, end indices of each feature\n    for (let i = 0; i < data.featureIds.value.length; i++) {\n      const currValue = data.featureIds.value[i];\n      if (currValue === lastValue) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      features.push(parseFeature(data, lastIndex, i));\n      lastIndex = i;\n      lastValue = currValue;\n    }\n\n    // Last feature\n    features.push(parseFeature(data, lastIndex, data.featureIds.value.length));\n  }\n  return features;\n}\n\n/** Parse input binary data and return a single GeoJSON Feature */\nfunction parseFeature(data, startIndex, endIndex) {\n  const geometry = parseGeometry(data, startIndex, endIndex);\n  const properties = parseProperties(data, startIndex, endIndex);\n  return {type: 'Feature', geometry, properties};\n}\n\n/** Parse input binary data and return an object of properties */\nfunction parseProperties(data, startIndex, endIndex) {\n  const properties = Object.assign(data.properties[data.featureIds.value[startIndex]]);\n  for (const key in data.numericProps) {\n    properties[key] = data.numericProps[key].value[startIndex];\n  }\n  return properties;\n}\n\n/** Parse input binary data and return a valid GeoJSON geometry object */\nfunction parseGeometry(data, startIndex, endIndex) {\n  switch (data.type) {\n    case 'Point':\n      return pointToGeoJson(data, startIndex, endIndex);\n    case 'LineString':\n      return lineStringToGeoJson(data, startIndex, endIndex);\n    case 'Polygon':\n      return polygonToGeoJson(data, startIndex, endIndex);\n    default:\n      throw new Error(`Unsupported geometry type: ${data.type}`);\n  }\n}\n\n/** Parse binary data of type Polygon */\nfunction polygonToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {positions} = data;\n  const polygonIndices = data.polygonIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const primitivePolygonIndices = data.primitivePolygonIndices.value.filter(\n    x => x >= startIndex && x <= endIndex\n  );\n  const multi = polygonIndices.length > 2;\n\n  const coordinates = [];\n  // Polygon\n  if (!multi) {\n    for (let i = 0; i < primitivePolygonIndices.length - 1; i++) {\n      const startRingIndex = primitivePolygonIndices[i];\n      const endRingIndex = primitivePolygonIndices[i + 1];\n      const ringCoordinates = ringToGeoJson(positions, startRingIndex, endRingIndex);\n      coordinates.push(ringCoordinates);\n    }\n\n    return {type: 'Polygon', coordinates};\n  }\n\n  // MultiPolygon\n  for (let i = 0; i < polygonIndices.length - 1; i++) {\n    const startPolygonIndex = polygonIndices[i];\n    const endPolygonIndex = polygonIndices[i + 1];\n    const polygonCoordinates = polygonToGeoJson(data, startPolygonIndex, endPolygonIndex)\n      .coordinates;\n    coordinates.push(polygonCoordinates);\n  }\n\n  return {type: 'MultiPolygon', coordinates};\n}\n\n/** Parse binary data of type LineString */\nfunction lineStringToGeoJson(data, startIndex = -Infinity, endIndex = Infinity) {\n  const {positions} = data;\n  const pathIndices = data.pathIndices.value.filter(x => x >= startIndex && x <= endIndex);\n  const multi = pathIndices.length > 2;\n\n  if (!multi) {\n    const coordinates = ringToGeoJson(positions, pathIndices[0], pathIndices[1]);\n    return {type: 'LineString', coordinates};\n  }\n\n  const coordinates = [];\n  for (let i = 0; i < pathIndices.length - 1; i++) {\n    const ringCoordinates = ringToGeoJson(positions, pathIndices[i], pathIndices[i + 1]);\n    coordinates.push(ringCoordinates);\n  }\n\n  return {type: 'MultiLineString', coordinates};\n}\n\n/** Parse binary data of type Point */\nfunction pointToGeoJson(data, startIndex, endIndex) {\n  const {positions} = data;\n  const coordinates = ringToGeoJson(positions, startIndex, endIndex);\n  const multi = coordinates.length > 1;\n\n  if (multi) {\n    return {type: 'MultiPoint', coordinates};\n  }\n\n  return {type: 'Point', coordinates: coordinates[0]};\n}\n\n/**\n * Parse a linear ring of positions to a GeoJSON linear ring\n *\n * @param positions Positions TypedArray\n * @param  {number?} startIndex Start index to include in ring\n * @param  {number?} endIndex End index to include in ring\n * @return {number[][]} GeoJSON ring\n */\nfunction ringToGeoJson(positions, startIndex, endIndex) {\n  startIndex = startIndex || 0;\n  endIndex = endIndex || positions.value.length / positions.size;\n\n  const ringCoordinates = [];\n  for (let j = startIndex; j < endIndex; j++) {\n    ringCoordinates.push(\n      Array.from(positions.value.subarray(j * positions.size, (j + 1) * positions.size))\n    );\n  }\n  return ringCoordinates;\n}\n\n// Deduce geometry type of data object\nfunction parseType(data) {\n  if (data.pathIndices) {\n    return 'LineString';\n  }\n\n  if (data.polygonIndices) {\n    return 'Polygon';\n  }\n\n  return 'Point';\n}\n"],"file":"binary-to-geojson.js"}