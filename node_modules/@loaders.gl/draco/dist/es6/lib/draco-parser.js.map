{"version":3,"sources":["../../../src/lib/draco-parser.js"],"names":["getMeshBoundingBox","GEOMETRY_TYPE","TRIANGULAR_MESH","POINT_CLOUD","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","DracoParser","constructor","draco","drawMode","metadataQuerier","destroy","destroyGeometry","dracoGeometry","parseSync","arrayBuffer","options","MetadataQuerier","buffer","DecoderBuffer","Init","byteLength","decoder","Decoder","data","dracoStatus","header","geometryType","GetEncodedGeometryType","Mesh","DecodeBufferToMesh","type","faceCount","num_faces","attributeCount","num_attributes","vertexCount","num_points","PointCloud","DecodeBufferToPointCloud","Error","ok","ptr","message","error_msg","loaderData","_extractDRACOGeometry","metadata","_getGeometryMetadata","boundingBox","attributes","geometry","_getAttributes","positionAttribute","indices","_getMeshStripIndices","_getMeshFaceIndices","mode","value","size","getPositionAttributeMetadata","posTransform","AttributeQuantizationTransform","InitFromAttribute","position","isQuantized","maxRange","range","numQuantizationBits","quantization_bits","minValues","i","min_value","numPoints","attributeId","dracoAttribute","GetAttribute","attributeMetadata","_getAttributeMetadata","attributeData","uniqueId","unique_id","attributeType","attribute_type","dataType","data_type","numComponents","num_components","byteOffset","byte_offset","byteStride","byte_stride","normalized","attributeName","_deduceAttributeName","typedArray","_getAttributeTypedArray","length","numFaces","numIndices","dracoArray","DracoInt32Array","GetFaceFromMesh","index","GetValue","GetTriangleStripsFromMesh","numValues","DracoFloat32Array","GetAttributeFloatForAllPoints","DracoInt8Array","GetAttributeInt8ForAllPoints","DracoInt16Array","GetAttributeInt16ForAllPoints","GetAttributeInt32ForAllPoints","DracoUInt8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","GetAttributeUInt16ForAllPoints","DracoUInt32Array","GetAttributeUInt32ForAllPoints","errorMsg","components","extraAttributes","attributeUniqueId","Object","entries","dracoAttributeConstant","entryName","attributeNameEntry","string","dracoMetadata","GetMetadata","_queryDracoMetadata","GetAttributeMetadata","result","numEntries","NumEntries","entryIndex","GetEntryName","int","GetIntEntry","GetStringEntry","double","GetDoubleEntry","intArray","GetIntEntryArray","decode"],"mappings":"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","sourcesContent":["// This code is inspired by example code in the DRACO repository\n/** @typedef {import('../types/draco-types')} Draco3D */\n/** @typedef {import('../types/draco-types').Decoder} Decoder */\nimport {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nexport default class DracoParser {\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco) {\n    /** @type {Draco3D} */\n    this.draco = draco;\n    this.drawMode = 'TRIANGLE';\n    this.metadataQuerier = {};\n  }\n\n  destroy() {}\n\n  destroyGeometry(dracoGeometry) {\n    if (dracoGeometry) {\n      this.draco.destroy(dracoGeometry.dracoGeometry);\n    }\n  }\n\n  // NOTE: caller must call `destroyGeometry` on the return value after using it\n  parseSync(arrayBuffer, options = {}) {\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    const decoder = new this.draco.Decoder();\n\n    const data = {};\n    let dracoStatus;\n    let dracoGeometry;\n    let header;\n\n    try {\n      const geometryType = decoder.GetEncodedGeometryType(buffer);\n      switch (geometryType) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoGeometry = new this.draco.Mesh();\n          dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.TRIANGULAR_MESH,\n            faceCount: dracoGeometry.num_faces(),\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoGeometry = new this.draco.PointCloud();\n          dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.POINT_CLOUD,\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        default:\n          throw new Error('Unknown DRACO geometry type.');\n      }\n\n      // @ts-ignore .ptr\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        if (dracoGeometry) {\n          this.draco.destroy(dracoGeometry);\n        }\n        throw new Error(message);\n      }\n\n      data.loaderData = {header};\n\n      this._extractDRACOGeometry(decoder, dracoGeometry, geometryType, data, options);\n      const metadata = this._getGeometryMetadata(decoder, dracoGeometry);\n\n      data.header = {\n        vertexCount: header.vertexCount,\n        boundingBox: getMeshBoundingBox(data.attributes),\n        metadata\n      };\n    } finally {\n      this.draco.destroy(decoder);\n      this.draco.destroy(buffer);\n      this.draco.destroy(dracoGeometry);\n      this.draco.destroy(this.metadataQuerier);\n    }\n\n    return data;\n  }\n\n  /**\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   * @param {*} geometryType\n   * @param {*} geometry\n   * @param {object} options\n   */\n  _extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry, options) {\n    const attributes = this._getAttributes(decoder, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO decompressor: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (geometryType === this.draco.TRIANGULAR_MESH) {\n      attributes.indices =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? /**\n             *\n             * @param {*} decoder\n             * @param {*} dracoGeometry\n             */\n            this._getMeshStripIndices(decoder, dracoGeometry)\n          : this._getMeshFaceIndices(decoder, dracoGeometry);\n      geometry.mode =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? 5 // GL.TRIANGLE_STRIP\n          : 4; // GL.TRIANGLES\n    } else {\n      geometry.mode = 0; // GL.POINTS\n    }\n\n    if (attributes.indices) {\n      geometry.indices = {value: attributes.indices, size: 1};\n      delete attributes.indices;\n    }\n    geometry.attributes = attributes;\n\n    return geometry;\n  }\n\n  getPositionAttributeMetadata(positionAttribute) {\n    this.metadata = this.metadata || {};\n    this.metadata.attributes = this.metadata.attributes || {};\n\n    const posTransform = new this.draco.AttributeQuantizationTransform();\n    if (posTransform.InitFromAttribute(positionAttribute)) {\n      // Quantized attribute. Store the quantization parameters into the attribute\n      this.metadata.attributes.position.isQuantized = true;\n      this.metadata.attributes.position.maxRange = posTransform.range();\n      this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();\n      this.metadata.attributes.position.minValues = new Float32Array(3);\n      for (let i = 0; i < 3; ++i) {\n        this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);\n      }\n    }\n    this.draco.destroy(posTransform);\n  }\n\n  _getAttributes(decoder, dracoGeometry, options) {\n    const attributes = {};\n    const numPoints = dracoGeometry.num_points();\n    // const attributeUniqueIdMap = {};\n\n    // Note: Draco docs do not seem clear on `GetAttribute` accepting a zero-based index,\n    // but it seems to work this way\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeMetadata = this._getAttributeMetadata(decoder, dracoGeometry, attributeId);\n      const attributeData = {\n        uniqueId: dracoAttribute.unique_id(),\n        attributeType: dracoAttribute.attribute_type(),\n        dataType: DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()],\n        size: dracoAttribute.size(),\n        numComponents: dracoAttribute.num_components(),\n        byteOffset: dracoAttribute.byte_offset(),\n        byteStride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        metadata: attributeMetadata\n      };\n\n      // DRACO does not store attribute names - We need to deduce an attribute name\n      const attributeName = this._deduceAttributeName(attributeData, options);\n\n      const {typedArray} = this._getAttributeTypedArray(\n        decoder,\n        dracoGeometry,\n        dracoAttribute,\n        attributeName\n      );\n      attributes[attributeName] = {\n        value: typedArray,\n        size: typedArray.length / numPoints,\n        metadata: attributeMetadata\n      };\n    }\n\n    return attributes;\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   */\n  _getMeshFaceIndices(decoder, dracoGeometry) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n\n    const numIndices = numFaces * 3;\n    const indices = new Uint32Array(numIndices);\n    const dracoArray = new this.draco.DracoInt32Array();\n    for (let i = 0; i < numFaces; ++i) {\n      decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);\n      const index = i * 3;\n      indices[index] = dracoArray.GetValue(0);\n      indices[index + 1] = dracoArray.GetValue(1);\n      indices[index + 2] = dracoArray.GetValue(2);\n    }\n\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   */\n  _getMeshStripIndices(decoder, dracoGeometry) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    /* const numStrips = */ decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n    const indices = new Uint32Array(dracoArray.size());\n    for (let i = 0; i < dracoArray.size(); ++i) {\n      indices[i] = dracoArray.GetValue(i);\n    }\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  /**\n   *\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   * @param {*} dracoAttribute\n   * @param {*} attributeName\n   */\n  _getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {\n    if (dracoAttribute.ptr === 0) {\n      const message = `DRACO decode bad attribute ${attributeName}`;\n      // console.error(message);\n      throw new Error(message);\n    }\n\n    const attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];\n    const numComponents = dracoAttribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    let dracoArray;\n    let typedArray;\n\n    switch (attributeType) {\n      case Float32Array:\n        dracoArray = new this.draco.DracoFloat32Array();\n        decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Float32Array(numValues);\n        break;\n\n      case Int8Array:\n        dracoArray = new this.draco.DracoInt8Array();\n        decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int8Array(numValues);\n        break;\n\n      case Int16Array:\n        dracoArray = new this.draco.DracoInt16Array();\n        decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int16Array(numValues);\n        break;\n\n      case Int32Array:\n        dracoArray = new this.draco.DracoInt32Array();\n        decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int32Array(numValues);\n        break;\n\n      case Uint8Array:\n        dracoArray = new this.draco.DracoUInt8Array();\n        decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint8Array(numValues);\n        break;\n\n      case Uint16Array:\n        dracoArray = new this.draco.DracoUInt16Array();\n        decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint16Array(numValues);\n        break;\n\n      case Uint32Array:\n        dracoArray = new this.draco.DracoUInt32Array();\n        decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint32Array(numValues);\n        break;\n\n      default:\n        const errorMsg = 'DRACO decoder: unexpected attribute type.';\n        // console.error(errorMsg);\n        throw new Error(errorMsg);\n    }\n\n    // Copy data from decoder.\n    for (let i = 0; i < numValues; i++) {\n      typedArray[i] = dracoArray.GetValue(i);\n    }\n\n    this.draco.destroy(dracoArray);\n\n    return {typedArray, components: numComponents};\n  }\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param {object} attributeData\n   */\n  _deduceAttributeName(attributeData, options) {\n    const {extraAttributes = {}} = options;\n    if (extraAttributes && typeof extraAttributes === 'object') {\n      for (const [attributeName, attributeUniqueId] of Object.entries(extraAttributes)) {\n        if (attributeUniqueId === attributeData.uniqueId) {\n          return attributeName;\n        }\n      }\n    }\n\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeData.attributeType === attributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    if (attributeData.metadata) {\n      const entryName = options.attributeNameEntry || 'name';\n      if (attributeData.metadata[entryName]) {\n        return attributeData.metadata[entryName].string;\n      }\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${attributeData.uniqueId}`;\n  }\n\n  _getGeometryMetadata(decoder, dracoGeometry) {\n    const dracoMetadata = decoder.GetMetadata(dracoGeometry);\n    return this._queryDracoMetadata(dracoMetadata);\n  }\n\n  _getAttributeMetadata(decoder, dracoGeometry, attributeId) {\n    const dracoMetadata = decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._queryDracoMetadata(dracoMetadata);\n  }\n\n  // The not so wonderful world of undocumented Draco APIs :(\n  _queryDracoMetadata(dracoMetadata) {\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray: this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName)\n      };\n    }\n    return result;\n  }\n\n  // DEPRECATED\n\n  decode(arrayBuffer, options) {\n    return this.parseSync(arrayBuffer, options);\n  }\n}\n"],"file":"draco-parser.js"}