{"version":3,"sources":["../../../src/lib/draco-parser.js"],"names":["getMeshBoundingBox","GEOMETRY_TYPE","TRIANGULAR_MESH","POINT_CLOUD","DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP","POSITION","NORMAL","COLOR","TEX_COORD","DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP","Int8Array","Uint8Array","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","DracoParser","draco","drawMode","metadataQuerier","dracoGeometry","destroy","arrayBuffer","options","MetadataQuerier","buffer","DecoderBuffer","Init","byteLength","decoder","Decoder","data","dracoStatus","header","geometryType","GetEncodedGeometryType","Mesh","DecodeBufferToMesh","type","faceCount","num_faces","attributeCount","num_attributes","vertexCount","num_points","PointCloud","DecodeBufferToPointCloud","Error","ok","ptr","message","error_msg","loaderData","_extractDRACOGeometry","metadata","_getGeometryMetadata","boundingBox","attributes","geometry","_getAttributes","positionAttribute","indices","_getMeshStripIndices","_getMeshFaceIndices","mode","value","size","posTransform","AttributeQuantizationTransform","InitFromAttribute","position","isQuantized","maxRange","range","numQuantizationBits","quantization_bits","minValues","i","min_value","numPoints","attributeId","dracoAttribute","GetAttribute","attributeMetadata","_getAttributeMetadata","attributeData","uniqueId","unique_id","attributeType","attribute_type","dataType","data_type","numComponents","num_components","byteOffset","byte_offset","byteStride","byte_stride","normalized","attributeName","_deduceAttributeName","_getAttributeTypedArray","typedArray","length","numFaces","numIndices","dracoArray","DracoInt32Array","GetFaceFromMesh","index","GetValue","GetTriangleStripsFromMesh","numValues","DracoFloat32Array","GetAttributeFloatForAllPoints","DracoInt8Array","GetAttributeInt8ForAllPoints","DracoInt16Array","GetAttributeInt16ForAllPoints","GetAttributeInt32ForAllPoints","DracoUInt8Array","GetAttributeUInt8ForAllPoints","DracoUInt16Array","GetAttributeUInt16ForAllPoints","DracoUInt32Array","GetAttributeUInt32ForAllPoints","errorMsg","components","extraAttributes","Object","entries","attributeUniqueId","dracoAttributeConstant","entryName","attributeNameEntry","string","dracoMetadata","GetMetadata","_queryDracoMetadata","GetAttributeMetadata","result","numEntries","NumEntries","entryIndex","GetEntryName","GetIntEntry","GetStringEntry","GetDoubleEntry","intArray","GetIntEntryArray","parseSync"],"mappings":"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","sourcesContent":["// This code is inspired by example code in the DRACO repository\n/** @typedef {import('../types/draco-types')} Draco3D */\n/** @typedef {import('../types/draco-types').Decoder} Decoder */\nimport {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n\nconst GEOMETRY_TYPE = {\n  TRIANGULAR_MESH: 0,\n  POINT_CLOUD: 1\n};\n\n// Native Draco attribute names to GLTF attribute names.\nconst DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {\n  POSITION: 'POSITION',\n  NORMAL: 'NORMAL',\n  COLOR: 'COLOR_0',\n  TEX_COORD: 'TEXCOORD_0'\n};\n\nconst DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {\n  1: Int8Array,\n  2: Uint8Array,\n  3: Int16Array,\n  4: Uint16Array,\n  5: Int32Array,\n  6: Uint32Array,\n  9: Float32Array\n};\n\nexport default class DracoParser {\n  // draco - the draco decoder, either import `draco3d` or load dynamically\n  constructor(draco) {\n    /** @type {Draco3D} */\n    this.draco = draco;\n    this.drawMode = 'TRIANGLE';\n    this.metadataQuerier = {};\n  }\n\n  destroy() {}\n\n  destroyGeometry(dracoGeometry) {\n    if (dracoGeometry) {\n      this.draco.destroy(dracoGeometry.dracoGeometry);\n    }\n  }\n\n  // NOTE: caller must call `destroyGeometry` on the return value after using it\n  parseSync(arrayBuffer, options = {}) {\n    this.metadataQuerier = new this.draco.MetadataQuerier();\n    const buffer = new this.draco.DecoderBuffer();\n    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);\n\n    const decoder = new this.draco.Decoder();\n\n    const data = {};\n    let dracoStatus;\n    let dracoGeometry;\n    let header;\n\n    try {\n      const geometryType = decoder.GetEncodedGeometryType(buffer);\n      switch (geometryType) {\n        case this.draco.TRIANGULAR_MESH:\n          dracoGeometry = new this.draco.Mesh();\n          dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.TRIANGULAR_MESH,\n            faceCount: dracoGeometry.num_faces(),\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        case this.draco.POINT_CLOUD:\n          dracoGeometry = new this.draco.PointCloud();\n          dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);\n          header = {\n            type: GEOMETRY_TYPE.POINT_CLOUD,\n            attributeCount: dracoGeometry.num_attributes(),\n            vertexCount: dracoGeometry.num_points()\n          };\n          break;\n\n        default:\n          throw new Error('Unknown DRACO geometry type.');\n      }\n\n      // @ts-ignore .ptr\n      if (!dracoStatus.ok() || !dracoGeometry.ptr) {\n        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;\n        // console.error(message);\n        if (dracoGeometry) {\n          this.draco.destroy(dracoGeometry);\n        }\n        throw new Error(message);\n      }\n\n      data.loaderData = {header};\n\n      this._extractDRACOGeometry(decoder, dracoGeometry, geometryType, data, options);\n      const metadata = this._getGeometryMetadata(decoder, dracoGeometry);\n\n      data.header = {\n        vertexCount: header.vertexCount,\n        boundingBox: getMeshBoundingBox(data.attributes),\n        metadata\n      };\n    } finally {\n      this.draco.destroy(decoder);\n      this.draco.destroy(buffer);\n      this.draco.destroy(dracoGeometry);\n      this.draco.destroy(this.metadataQuerier);\n    }\n\n    return data;\n  }\n\n  /**\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   * @param {*} geometryType\n   * @param {*} geometry\n   * @param {object} options\n   */\n  _extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry, options) {\n    const attributes = this._getAttributes(decoder, dracoGeometry, options);\n\n    const positionAttribute = attributes.POSITION;\n    if (!positionAttribute) {\n      throw new Error('DRACO decompressor: No position attribute found.');\n    }\n\n    // For meshes, we need indices to define the faces.\n    if (geometryType === this.draco.TRIANGULAR_MESH) {\n      attributes.indices =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? /**\n             *\n             * @param {*} decoder\n             * @param {*} dracoGeometry\n             */\n            this._getMeshStripIndices(decoder, dracoGeometry)\n          : this._getMeshFaceIndices(decoder, dracoGeometry);\n      geometry.mode =\n        this.drawMode === 'TRIANGLE_STRIP'\n          ? 5 // GL.TRIANGLE_STRIP\n          : 4; // GL.TRIANGLES\n    } else {\n      geometry.mode = 0; // GL.POINTS\n    }\n\n    if (attributes.indices) {\n      geometry.indices = {value: attributes.indices, size: 1};\n      delete attributes.indices;\n    }\n    geometry.attributes = attributes;\n\n    return geometry;\n  }\n\n  getPositionAttributeMetadata(positionAttribute) {\n    this.metadata = this.metadata || {};\n    this.metadata.attributes = this.metadata.attributes || {};\n\n    const posTransform = new this.draco.AttributeQuantizationTransform();\n    if (posTransform.InitFromAttribute(positionAttribute)) {\n      // Quantized attribute. Store the quantization parameters into the attribute\n      this.metadata.attributes.position.isQuantized = true;\n      this.metadata.attributes.position.maxRange = posTransform.range();\n      this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();\n      this.metadata.attributes.position.minValues = new Float32Array(3);\n      for (let i = 0; i < 3; ++i) {\n        this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);\n      }\n    }\n    this.draco.destroy(posTransform);\n  }\n\n  _getAttributes(decoder, dracoGeometry, options) {\n    const attributes = {};\n    const numPoints = dracoGeometry.num_points();\n    // const attributeUniqueIdMap = {};\n\n    // Note: Draco docs do not seem clear on `GetAttribute` accepting a zero-based index,\n    // but it seems to work this way\n    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {\n      const dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);\n      const attributeMetadata = this._getAttributeMetadata(decoder, dracoGeometry, attributeId);\n      const attributeData = {\n        uniqueId: dracoAttribute.unique_id(),\n        attributeType: dracoAttribute.attribute_type(),\n        dataType: DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()],\n        size: dracoAttribute.size(),\n        numComponents: dracoAttribute.num_components(),\n        byteOffset: dracoAttribute.byte_offset(),\n        byteStride: dracoAttribute.byte_stride(),\n        normalized: dracoAttribute.normalized(),\n        metadata: attributeMetadata\n      };\n\n      // DRACO does not store attribute names - We need to deduce an attribute name\n      const attributeName = this._deduceAttributeName(attributeData, options);\n\n      const {typedArray} = this._getAttributeTypedArray(\n        decoder,\n        dracoGeometry,\n        dracoAttribute,\n        attributeName\n      );\n      attributes[attributeName] = {\n        value: typedArray,\n        size: typedArray.length / numPoints,\n        metadata: attributeMetadata\n      };\n    }\n\n    return attributes;\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   */\n  _getMeshFaceIndices(decoder, dracoGeometry) {\n    // Example on how to retrieve mesh and attributes.\n    const numFaces = dracoGeometry.num_faces();\n\n    const numIndices = numFaces * 3;\n    const indices = new Uint32Array(numIndices);\n    const dracoArray = new this.draco.DracoInt32Array();\n    for (let i = 0; i < numFaces; ++i) {\n      decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);\n      const index = i * 3;\n      indices[index] = dracoArray.GetValue(0);\n      indices[index + 1] = dracoArray.GetValue(1);\n      indices[index + 2] = dracoArray.GetValue(2);\n    }\n\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  /**\n   * For meshes, we need indices to define the faces.\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   */\n  _getMeshStripIndices(decoder, dracoGeometry) {\n    const dracoArray = new this.draco.DracoInt32Array();\n    /* const numStrips = */ decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);\n    const indices = new Uint32Array(dracoArray.size());\n    for (let i = 0; i < dracoArray.size(); ++i) {\n      indices[i] = dracoArray.GetValue(i);\n    }\n    this.draco.destroy(dracoArray);\n    return indices;\n  }\n\n  /**\n   *\n   * @param {Decoder} decoder\n   * @param {*} dracoGeometry\n   * @param {*} dracoAttribute\n   * @param {*} attributeName\n   */\n  _getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {\n    if (dracoAttribute.ptr === 0) {\n      const message = `DRACO decode bad attribute ${attributeName}`;\n      // console.error(message);\n      throw new Error(message);\n    }\n\n    const attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];\n    const numComponents = dracoAttribute.num_components();\n    const numPoints = dracoGeometry.num_points();\n    const numValues = numPoints * numComponents;\n\n    let dracoArray;\n    let typedArray;\n\n    switch (attributeType) {\n      case Float32Array:\n        dracoArray = new this.draco.DracoFloat32Array();\n        decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Float32Array(numValues);\n        break;\n\n      case Int8Array:\n        dracoArray = new this.draco.DracoInt8Array();\n        decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int8Array(numValues);\n        break;\n\n      case Int16Array:\n        dracoArray = new this.draco.DracoInt16Array();\n        decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int16Array(numValues);\n        break;\n\n      case Int32Array:\n        dracoArray = new this.draco.DracoInt32Array();\n        decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Int32Array(numValues);\n        break;\n\n      case Uint8Array:\n        dracoArray = new this.draco.DracoUInt8Array();\n        decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint8Array(numValues);\n        break;\n\n      case Uint16Array:\n        dracoArray = new this.draco.DracoUInt16Array();\n        decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint16Array(numValues);\n        break;\n\n      case Uint32Array:\n        dracoArray = new this.draco.DracoUInt32Array();\n        decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);\n        typedArray = new Uint32Array(numValues);\n        break;\n\n      default:\n        const errorMsg = 'DRACO decoder: unexpected attribute type.';\n        // console.error(errorMsg);\n        throw new Error(errorMsg);\n    }\n\n    // Copy data from decoder.\n    for (let i = 0; i < numValues; i++) {\n      typedArray[i] = dracoArray.GetValue(i);\n    }\n\n    this.draco.destroy(dracoArray);\n\n    return {typedArray, components: numComponents};\n  }\n\n  /**\n   * Deduce an attribute name.\n   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)\n   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized\n   * types\n   * @param {object} attributeData\n   */\n  _deduceAttributeName(attributeData, options) {\n    const {extraAttributes = {}} = options;\n    if (extraAttributes && typeof extraAttributes === 'object') {\n      for (const [attributeName, attributeUniqueId] of Object.entries(extraAttributes)) {\n        if (attributeUniqueId === attributeData.uniqueId) {\n          return attributeName;\n        }\n      }\n    }\n\n    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {\n      const attributeType = this.draco[dracoAttributeConstant];\n      if (attributeData.attributeType === attributeType) {\n        // TODO - Return unique names if there multiple attributes per type\n        // (e.g. multiple TEX_COORDS or COLORS)\n        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];\n      }\n    }\n\n    if (attributeData.metadata) {\n      const entryName = options.attributeNameEntry || 'name';\n      if (attributeData.metadata[entryName]) {\n        return attributeData.metadata[entryName].string;\n      }\n    }\n\n    // Attribute of \"GENERIC\" type, we need to assign some name\n    return `CUSTOM_ATTRIBUTE_${attributeData.uniqueId}`;\n  }\n\n  _getGeometryMetadata(decoder, dracoGeometry) {\n    const dracoMetadata = decoder.GetMetadata(dracoGeometry);\n    return this._queryDracoMetadata(dracoMetadata);\n  }\n\n  _getAttributeMetadata(decoder, dracoGeometry, attributeId) {\n    const dracoMetadata = decoder.GetAttributeMetadata(dracoGeometry, attributeId);\n    return this._queryDracoMetadata(dracoMetadata);\n  }\n\n  // The not so wonderful world of undocumented Draco APIs :(\n  _queryDracoMetadata(dracoMetadata) {\n    if (!dracoMetadata || !dracoMetadata.ptr) {\n      return {};\n    }\n    const result = {};\n    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);\n    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {\n      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);\n      result[entryName] = {\n        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),\n        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),\n        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),\n        intArray: this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName)\n      };\n    }\n    return result;\n  }\n\n  // DEPRECATED\n\n  decode(arrayBuffer, options) {\n    return this.parseSync(arrayBuffer, options);\n  }\n}\n"],"file":"draco-parser.js"}