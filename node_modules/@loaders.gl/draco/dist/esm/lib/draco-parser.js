import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _typeof from "@babel/runtime/helpers/esm/typeof";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { getMeshBoundingBox } from '@loaders.gl/loader-utils';
var GEOMETRY_TYPE = {
  TRIANGULAR_MESH: 0,
  POINT_CLOUD: 1
};
var DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
  POSITION: 'POSITION',
  NORMAL: 'NORMAL',
  COLOR: 'COLOR_0',
  TEX_COORD: 'TEXCOORD_0'
};
var DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  9: Float32Array
};

var DracoParser = function () {
  function DracoParser(draco) {
    _classCallCheck(this, DracoParser);

    this.draco = draco;
    this.drawMode = 'TRIANGLE';
    this.metadataQuerier = {};
  }

  _createClass(DracoParser, [{
    key: "destroy",
    value: function destroy() {}
  }, {
    key: "destroyGeometry",
    value: function destroyGeometry(dracoGeometry) {
      if (dracoGeometry) {
        this.draco.destroy(dracoGeometry.dracoGeometry);
      }
    }
  }, {
    key: "parseSync",
    value: function parseSync(arrayBuffer) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.metadataQuerier = new this.draco.MetadataQuerier();
      var buffer = new this.draco.DecoderBuffer();
      buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);
      var decoder = new this.draco.Decoder();
      var data = {};
      var dracoStatus;
      var dracoGeometry;
      var header;

      try {
        var geometryType = decoder.GetEncodedGeometryType(buffer);

        switch (geometryType) {
          case this.draco.TRIANGULAR_MESH:
            dracoGeometry = new this.draco.Mesh();
            dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
            header = {
              type: GEOMETRY_TYPE.TRIANGULAR_MESH,
              faceCount: dracoGeometry.num_faces(),
              attributeCount: dracoGeometry.num_attributes(),
              vertexCount: dracoGeometry.num_points()
            };
            break;

          case this.draco.POINT_CLOUD:
            dracoGeometry = new this.draco.PointCloud();
            dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
            header = {
              type: GEOMETRY_TYPE.POINT_CLOUD,
              attributeCount: dracoGeometry.num_attributes(),
              vertexCount: dracoGeometry.num_points()
            };
            break;

          default:
            throw new Error('Unknown DRACO geometry type.');
        }

        if (!dracoStatus.ok() || !dracoGeometry.ptr) {
          var message = "DRACO decompression failed: ".concat(dracoStatus.error_msg());

          if (dracoGeometry) {
            this.draco.destroy(dracoGeometry);
          }

          throw new Error(message);
        }

        data.loaderData = {
          header: header
        };

        this._extractDRACOGeometry(decoder, dracoGeometry, geometryType, data, options);

        var metadata = this._getGeometryMetadata(decoder, dracoGeometry);

        data.header = {
          vertexCount: header.vertexCount,
          boundingBox: getMeshBoundingBox(data.attributes),
          metadata: metadata
        };
      } finally {
        this.draco.destroy(decoder);
        this.draco.destroy(buffer);
        this.draco.destroy(dracoGeometry);
        this.draco.destroy(this.metadataQuerier);
      }

      return data;
    }
  }, {
    key: "_extractDRACOGeometry",
    value: function _extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry, options) {
      var attributes = this._getAttributes(decoder, dracoGeometry, options);

      var positionAttribute = attributes.POSITION;

      if (!positionAttribute) {
        throw new Error('DRACO decompressor: No position attribute found.');
      }

      if (geometryType === this.draco.TRIANGULAR_MESH) {
        attributes.indices = this.drawMode === 'TRIANGLE_STRIP' ? this._getMeshStripIndices(decoder, dracoGeometry) : this._getMeshFaceIndices(decoder, dracoGeometry);
        geometry.mode = this.drawMode === 'TRIANGLE_STRIP' ? 5 : 4;
      } else {
        geometry.mode = 0;
      }

      if (attributes.indices) {
        geometry.indices = {
          value: attributes.indices,
          size: 1
        };
        delete attributes.indices;
      }

      geometry.attributes = attributes;
      return geometry;
    }
  }, {
    key: "getPositionAttributeMetadata",
    value: function getPositionAttributeMetadata(positionAttribute) {
      this.metadata = this.metadata || {};
      this.metadata.attributes = this.metadata.attributes || {};
      var posTransform = new this.draco.AttributeQuantizationTransform();

      if (posTransform.InitFromAttribute(positionAttribute)) {
        this.metadata.attributes.position.isQuantized = true;
        this.metadata.attributes.position.maxRange = posTransform.range();
        this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();
        this.metadata.attributes.position.minValues = new Float32Array(3);

        for (var i = 0; i < 3; ++i) {
          this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);
        }
      }

      this.draco.destroy(posTransform);
    }
  }, {
    key: "_getAttributes",
    value: function _getAttributes(decoder, dracoGeometry, options) {
      var attributes = {};
      var numPoints = dracoGeometry.num_points();

      for (var attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
        var dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);

        var attributeMetadata = this._getAttributeMetadata(decoder, dracoGeometry, attributeId);

        var attributeData = {
          uniqueId: dracoAttribute.unique_id(),
          attributeType: dracoAttribute.attribute_type(),
          dataType: DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()],
          size: dracoAttribute.size(),
          numComponents: dracoAttribute.num_components(),
          byteOffset: dracoAttribute.byte_offset(),
          byteStride: dracoAttribute.byte_stride(),
          normalized: dracoAttribute.normalized(),
          metadata: attributeMetadata
        };

        var attributeName = this._deduceAttributeName(attributeData, options);

        var _this$_getAttributeTy = this._getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName),
            typedArray = _this$_getAttributeTy.typedArray;

        attributes[attributeName] = {
          value: typedArray,
          size: typedArray.length / numPoints,
          metadata: attributeMetadata
        };
      }

      return attributes;
    }
  }, {
    key: "_getMeshFaceIndices",
    value: function _getMeshFaceIndices(decoder, dracoGeometry) {
      var numFaces = dracoGeometry.num_faces();
      var numIndices = numFaces * 3;
      var indices = new Uint32Array(numIndices);
      var dracoArray = new this.draco.DracoInt32Array();

      for (var i = 0; i < numFaces; ++i) {
        decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);
        var index = i * 3;
        indices[index] = dracoArray.GetValue(0);
        indices[index + 1] = dracoArray.GetValue(1);
        indices[index + 2] = dracoArray.GetValue(2);
      }

      this.draco.destroy(dracoArray);
      return indices;
    }
  }, {
    key: "_getMeshStripIndices",
    value: function _getMeshStripIndices(decoder, dracoGeometry) {
      var dracoArray = new this.draco.DracoInt32Array();
      decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
      var indices = new Uint32Array(dracoArray.size());

      for (var i = 0; i < dracoArray.size(); ++i) {
        indices[i] = dracoArray.GetValue(i);
      }

      this.draco.destroy(dracoArray);
      return indices;
    }
  }, {
    key: "_getAttributeTypedArray",
    value: function _getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {
      if (dracoAttribute.ptr === 0) {
        var message = "DRACO decode bad attribute ".concat(attributeName);
        throw new Error(message);
      }

      var attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];
      var numComponents = dracoAttribute.num_components();
      var numPoints = dracoGeometry.num_points();
      var numValues = numPoints * numComponents;
      var dracoArray;
      var typedArray;

      switch (attributeType) {
        case Float32Array:
          dracoArray = new this.draco.DracoFloat32Array();
          decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
          typedArray = new Float32Array(numValues);
          break;

        case Int8Array:
          dracoArray = new this.draco.DracoInt8Array();
          decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
          typedArray = new Int8Array(numValues);
          break;

        case Int16Array:
          dracoArray = new this.draco.DracoInt16Array();
          decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
          typedArray = new Int16Array(numValues);
          break;

        case Int32Array:
          dracoArray = new this.draco.DracoInt32Array();
          decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
          typedArray = new Int32Array(numValues);
          break;

        case Uint8Array:
          dracoArray = new this.draco.DracoUInt8Array();
          decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
          typedArray = new Uint8Array(numValues);
          break;

        case Uint16Array:
          dracoArray = new this.draco.DracoUInt16Array();
          decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
          typedArray = new Uint16Array(numValues);
          break;

        case Uint32Array:
          dracoArray = new this.draco.DracoUInt32Array();
          decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
          typedArray = new Uint32Array(numValues);
          break;

        default:
          var errorMsg = 'DRACO decoder: unexpected attribute type.';
          throw new Error(errorMsg);
      }

      for (var i = 0; i < numValues; i++) {
        typedArray[i] = dracoArray.GetValue(i);
      }

      this.draco.destroy(dracoArray);
      return {
        typedArray: typedArray,
        components: numComponents
      };
    }
  }, {
    key: "_deduceAttributeName",
    value: function _deduceAttributeName(attributeData, options) {
      var _options$extraAttribu = options.extraAttributes,
          extraAttributes = _options$extraAttribu === void 0 ? {} : _options$extraAttribu;

      if (extraAttributes && _typeof(extraAttributes) === 'object') {
        for (var _i = 0, _Object$entries = Object.entries(extraAttributes); _i < _Object$entries.length; _i++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
              attributeName = _Object$entries$_i[0],
              attributeUniqueId = _Object$entries$_i[1];

          if (attributeUniqueId === attributeData.uniqueId) {
            return attributeName;
          }
        }
      }

      for (var dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
        var attributeType = this.draco[dracoAttributeConstant];

        if (attributeData.attributeType === attributeType) {
          return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
        }
      }

      if (attributeData.metadata) {
        var entryName = options.attributeNameEntry || 'name';

        if (attributeData.metadata[entryName]) {
          return attributeData.metadata[entryName].string;
        }
      }

      return "CUSTOM_ATTRIBUTE_".concat(attributeData.uniqueId);
    }
  }, {
    key: "_getGeometryMetadata",
    value: function _getGeometryMetadata(decoder, dracoGeometry) {
      var dracoMetadata = decoder.GetMetadata(dracoGeometry);
      return this._queryDracoMetadata(dracoMetadata);
    }
  }, {
    key: "_getAttributeMetadata",
    value: function _getAttributeMetadata(decoder, dracoGeometry, attributeId) {
      var dracoMetadata = decoder.GetAttributeMetadata(dracoGeometry, attributeId);
      return this._queryDracoMetadata(dracoMetadata);
    }
  }, {
    key: "_queryDracoMetadata",
    value: function _queryDracoMetadata(dracoMetadata) {
      if (!dracoMetadata || !dracoMetadata.ptr) {
        return {};
      }

      var result = {};
      var numEntries = this.metadataQuerier.NumEntries(dracoMetadata);

      for (var entryIndex = 0; entryIndex < numEntries; entryIndex++) {
        var entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
        result[entryName] = {
          "int": this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
          string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
          "double": this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
          intArray: this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName)
        };
      }

      return result;
    }
  }, {
    key: "decode",
    value: function decode(arrayBuffer, options) {
      return this.parseSync(arrayBuffer, options);
    }
  }]);

  return DracoParser;
}();

export { DracoParser as default };
//# sourceMappingURL=draco-parser.js.map