{"version":3,"sources":["../../../../src/tileset/helpers/i3s-lod.js"],"names":["WGS84_RADIUS_X","qualityFactor","Math","PI","lodJudge","tile","frameState","viewport","metersPerPixel","mbsLat","header","mbs","mbsLon","mbsZ","mbsR","height","width","latitude","longitude","viewportCenter","mbsCenter","mbsLatProjected","mbsLonProjected","diagonalInMeters","sqrt","distanceInMeters","getDistanceFromLatLon","visibleHeight","visibleWidth","lodMetricValue","screenSize","getI3ScreenSize","children","projectVertexToSphere","x","y","z","azim","incl","radius","radCosInc","cos","sin","observerLon","observerLat","observerZ","centerLon","centerLat","centerZ","projectedCenter","projectedObserver","dx","dy","dz","cameraPositionCartographic","unprojectPosition","cameraPosition","dSquared","mbsRNormalized","d","fltMax","screenSizeFactor","calculateScreenSizeFactor","scale","pixelProjectionMatrix","tanOfHalfVFAngle","tan","atan","screenCircleFactor"],"mappings":"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","sourcesContent":["import {toRadians} from '@math.gl/core';\n\nconst WGS84_RADIUS_X = 6378137.0;\n// use this to bias the lod switching  (1+ results in increasing the LOD quality)\nconst qualityFactor = Math.PI / 2; // empirical derived bias factor\n/* eslint-disable max-statements */\nexport function lodJudge(tile, frameState) {\n  const viewport = frameState.viewport;\n  const metersPerPixel = viewport.metersPerPixel;\n\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const {height, width, latitude, longitude} = viewport;\n\n  const viewportCenter = [longitude, latitude];\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const mbsLatProjected = [longitude, mbsLat];\n  const mbsLonProjected = [mbsLon, latitude];\n\n  const diagonalInMeters = Math.sqrt(height * height + width * width) * metersPerPixel[0];\n  const distanceInMeters = getDistanceFromLatLon(viewportCenter, mbsCenter);\n\n  const visibleHeight = height * 0.5 + mbsR / WGS84_RADIUS_X;\n  const visibleWidth = width * 0.5 + mbsR / WGS84_RADIUS_X;\n\n  if (distanceInMeters > diagonalInMeters + mbsR / WGS84_RADIUS_X) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLatProjected) > visibleHeight) {\n    return 'OUT';\n  }\n  if (getDistanceFromLatLon(viewportCenter, mbsLonProjected) > visibleWidth) {\n    return 'OUT';\n  }\n\n  if (tile.lodMetricValue === 0) {\n    return 'DIG';\n  }\n\n  // For the maxScreenThreshold error metric, maxError means that you should replace the node with it's children\n  // as soon as the nodes bounding sphere has a screen radius larger than maxError pixels.\n  // In this sense a value of 0 means you should always load it's children,\n  // or if it's a leaf node, you should always display it.\n  let screenSize = getI3ScreenSize(tile, frameState); // in pixels\n  screenSize *= qualityFactor;\n  if (screenSize < 0.5) {\n    return 'OUT';\n  }\n  // Hack: 1000 is a Magic number to get the correct LoD\n  if (!tile.header.children || screenSize <= tile.lodMetricValue) {\n    return 'DRAW';\n  } else if (tile.header.children) {\n    return 'DIG';\n  }\n  return 'OUT';\n}\n\n/* eslint-enable max-statements */\n\nfunction projectVertexToSphere([x, y, z]) {\n  const azim = toRadians(x);\n  const incl = toRadians(y);\n  const radius = 1.0 + z / WGS84_RADIUS_X;\n  const radCosInc = radius * Math.cos(incl);\n  x = radCosInc * Math.cos(azim);\n  y = radCosInc * Math.sin(azim);\n  z = radius * Math.sin(incl);\n  return [x, y, z];\n}\n\nfunction getDistanceFromLatLon(\n  [observerLon, observerLat, observerZ = 0.0],\n  [centerLon, centerLat, centerZ = 0.0]\n) {\n  const projectedCenter = projectVertexToSphere([centerLon, centerLat, centerZ]);\n  const projectedObserver = projectVertexToSphere([observerLon, observerLat, observerZ]);\n  const dx = projectedObserver[0] - projectedCenter[0];\n  const dy = projectedObserver[1] - projectedCenter[1];\n  const dz = projectedObserver[2] - projectedCenter[2];\n  return dx * dx + dy * dy + dz * dz;\n}\n\nexport function getI3ScreenSize(tile, frameState) {\n  const viewport = frameState.viewport;\n  // https://stackoverflow.com/questions/21648630/radius-of-projected-sphere-in-screen-space\n  const mbsLat = tile.header.mbs[1];\n  const mbsLon = tile.header.mbs[0];\n  const mbsZ = tile.header.mbs[2];\n  const mbsR = tile.header.mbs[3];\n\n  const mbsCenter = [mbsLon, mbsLat, mbsZ];\n  const cameraPositionCartographic = viewport.unprojectPosition(viewport.cameraPosition);\n  const dSquared = getDistanceFromLatLon(cameraPositionCartographic, mbsCenter);\n  const mbsRNormalized = mbsR / WGS84_RADIUS_X;\n  const d = dSquared - mbsRNormalized * mbsRNormalized;\n  const fltMax = 3.4028235e38; // convert from 0x7f7fffff which is the maximum\n  if (d <= 0.0) {\n    return 0.5 * fltMax;\n  }\n  let screenSizeFactor = calculateScreenSizeFactor(tile, frameState);\n  // viewport changed in deck.gl v8.0\n  screenSizeFactor *= mbsRNormalized / Math.sqrt(d) / viewport.scale;\n  return screenSizeFactor;\n}\n\nfunction calculateScreenSizeFactor(tile, frameState) {\n  const {width, height, pixelProjectionMatrix} = frameState.viewport;\n  const tanOfHalfVFAngle = Math.tan(\n    Math.atan(\n      Math.sqrt(\n        1.0 / (pixelProjectionMatrix[0] * pixelProjectionMatrix[0]) +\n          1.0 / (pixelProjectionMatrix[5] * pixelProjectionMatrix[5])\n      )\n    )\n  );\n\n  const screenCircleFactor = Math.sqrt(height * height + width * width) / tanOfHalfVFAngle;\n\n  return screenCircleFactor;\n}\n"],"file":"i3s-lod.js"}