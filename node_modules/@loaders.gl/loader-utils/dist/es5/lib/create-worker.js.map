{"version":3,"sources":["../../../src/lib/create-worker.js"],"names":["createWorker","loader","self","requestId","parse","arraybuffer","options","url","Promise","resolve","reject","id","onMessage","data","type","removeEventListener","result","message","addEventListener","postMessage","onmessage","evt","isKnownMessage","name","source","split","byteOffset","byteLength","parseData","context","transferList","parseSync","parser","parseTextSync","textDecoder","TextDecoder","decode","Error","modules","worker","startsWith"],"mappings":";;;;;;;;;;;;;;;AAGA;;AACA;;;;;;AAEe,SAASA,YAAT,CAAsBC,MAAtB,EAA8B;AAE3C,MAAI,OAAOC,IAAP,KAAgB,WAApB,EAAiC;AAC/B;AACD;;AAED,MAAIC,SAAS,GAAG,CAAhB;;AACA,MAAMC,KAAK,GAAG,SAARA,KAAQ,CAACC,WAAD;AAAA,QAAcC,OAAd,uEAAwB,EAAxB;AAAA,QAA4BC,GAA5B;AAAA,WACZ,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC/B,UAAMC,EAAE,GAAGR,SAAS,EAApB;;AAEA,UAAMS,SAAS,GAAG,SAAZA,SAAY,OAAY;AAAA,YAAVC,IAAU,QAAVA,IAAU;;AAC5B,YAAI,CAACA,IAAD,IAASA,IAAI,CAACF,EAAL,KAAYA,EAAzB,EAA6B;AAE3B;AACD;;AACD,gBAAQE,IAAI,CAACC,IAAb;AACE,eAAK,YAAL;AACEZ,YAAAA,IAAI,CAACa,mBAAL,CAAyB,SAAzB,EAAoCH,SAApC;AACAH,YAAAA,OAAO,CAACI,IAAI,CAACG,MAAN,CAAP;AACA;;AAEF,eAAK,aAAL;AACEd,YAAAA,IAAI,CAACa,mBAAL,CAAyB,SAAzB,EAAoCH,SAApC;AACAF,YAAAA,MAAM,CAACG,IAAI,CAACI,OAAN,CAAN;AACA;;AAEF;AAXF;AAcD,OAnBD;;AAoBAf,MAAAA,IAAI,CAACgB,gBAAL,CAAsB,SAAtB,EAAiCN,SAAjC;AAGAV,MAAAA,IAAI,CAACiB,WAAL,CAAiB;AAACL,QAAAA,IAAI,EAAE,OAAP;AAAgBH,QAAAA,EAAE,EAAFA,EAAhB;AAAoBN,QAAAA,WAAW,EAAXA,WAApB;AAAiCC,QAAAA,OAAO,EAAPA,OAAjC;AAA0CC,QAAAA,GAAG,EAAHA;AAA1C,OAAjB,EAAiE,CAACF,WAAD,CAAjE;AACD,KA3BD,CADY;AAAA,GAAd;;AA8BAH,EAAAA,IAAI,CAACkB,SAAL;AAAA,gFAAiB,iBAAMC,GAAN;AAAA;;AAAA;AAAA;AAAA;AAAA;AACRR,cAAAA,IADQ,GACAQ,GADA,CACRR,IADQ;AAAA;;AAAA,kBAIRS,cAAc,CAACT,IAAD,EAAOZ,MAAM,CAACsB,IAAd,CAJN;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAQb,gEAAsBtB,MAAtB,EAA8BY,IAAI,CAACW,MAAL,CAAYC,KAAZ,CAAkB,GAAlB,EAAuB,CAAvB,CAA9B;AAEOpB,cAAAA,WAVM,GAUuDQ,IAVvD,CAUNR,WAVM,qBAUuDQ,IAVvD,CAUOa,UAVP,EAUOA,UAVP,iCAUoB,CAVpB,wCAUuDb,IAVvD,CAUuBc,UAVvB,EAUuBA,UAVvB,iCAUoC,CAVpC,qCAUuDd,IAVvD,CAUuCP,OAVvC,EAUuCA,OAVvC,8BAUiD,EAVjD;AAAA;AAAA,qBAYQsB,SAAS,CAAC;AAC7B3B,gBAAAA,MAAM,EAANA,MAD6B;AAE7BI,gBAAAA,WAAW,EAAXA,WAF6B;AAG7BqB,gBAAAA,UAAU,EAAVA,UAH6B;AAI7BC,gBAAAA,UAAU,EAAVA,UAJ6B;AAK7BrB,gBAAAA,OAAO,EAAPA,OAL6B;AAM7BuB,gBAAAA,OAAO,EAAE;AAACzB,kBAAAA,KAAK,EAALA;AAAD;AANoB,eAAD,CAZjB;;AAAA;AAYPY,cAAAA,MAZO;AAoBPc,cAAAA,YApBO,GAoBQ,sCAAgBd,MAAhB,CApBR;AAsBbd,cAAAA,IAAI,CAACiB,WAAL,CAAiB;AAACL,gBAAAA,IAAI,EAAE,MAAP;AAAeE,gBAAAA,MAAM,EAANA;AAAf,eAAjB,EAAyCc,YAAzC;AAtBa;AAAA;;AAAA;AAAA;AAAA;AAyBb5B,cAAAA,IAAI,CAACiB,WAAL,CAAiB;AAACL,gBAAAA,IAAI,EAAE,OAAP;AAAgBG,gBAAAA,OAAO,EAAE,YAAMA;AAA/B,eAAjB;;AAzBa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAjB;;AAAA;AAAA;AAAA;AAAA;AA4BD;;SAMcW,S;;;;;+EAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAA0B3B,YAAAA,MAA1B,SAA0BA,MAA1B,EAAkCI,WAAlC,SAAkCA,WAAlC,EAA+CqB,UAA/C,SAA+CA,UAA/C,EAA2DC,UAA3D,SAA2DA,UAA3D,EAAuErB,OAAvE,SAAuEA,OAAvE,EAAgFuB,OAAhF,SAAgFA,OAAhF;;AAAA,kBAGM5B,MAAM,CAAC8B,SAAP,IAAoB9B,MAAM,CAACG,KAHjC;AAAA;AAAA;AAAA;;AAIIS,YAAAA,IAAI,GAAGR,WAAP;AACA2B,YAAAA,MAAM,GAAG/B,MAAM,CAAC8B,SAAP,IAAoB9B,MAAM,CAACG,KAApC;AALJ;AAAA;;AAAA;AAAA,iBAMaH,MAAM,CAACgC,aANpB;AAAA;AAAA;AAAA;;AAOUC,YAAAA,WAPV,GAOwB,IAAIC,WAAJ,EAPxB;AAQItB,YAAAA,IAAI,GAAGqB,WAAW,CAACE,MAAZ,CAAmB/B,WAAnB,CAAP;AACA2B,YAAAA,MAAM,GAAG/B,MAAM,CAACgC,aAAhB;AATJ;AAAA;;AAAA;AAAA,kBAWU,IAAII,KAAJ,oCAAsCpC,MAAM,CAACsB,IAA7C,aAXV;;AAAA;AAeEjB,YAAAA,OAAO,mCACFA,OADE;AAELgC,cAAAA,OAAO,EAAGrC,MAAM,IAAIA,MAAM,CAACK,OAAjB,IAA4BL,MAAM,CAACK,OAAP,CAAegC,OAA5C,IAAwD,EAF5D;AAGLC,cAAAA,MAAM,EAAE;AAHH,cAAP;AAfF;AAAA,mBAqBeP,MAAM,CAACnB,IAAD,oBAAWP,OAAX,GAAqBuB,OAArB,EAA8B5B,MAA9B,CArBrB;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAyBA,SAASqB,cAAT,CAAwBT,IAAxB,EAA8BU,IAA9B,EAAoC;AAClC,SAAOV,IAAI,IAAIA,IAAI,CAACC,IAAL,KAAc,OAAtB,IAAiCD,IAAI,CAACW,MAAtC,IAAgDX,IAAI,CAACW,MAAL,CAAYgB,UAAZ,CAAuB,YAAvB,CAAvD;AACD","sourcesContent":["/* eslint-disable no-restricted-globals */\n/* global TextDecoder, self */\n\nimport {getTransferList} from './worker-utils/get-transfer-list';\nimport {validateLoaderVersion} from './validate-loader-version';\n\nexport default function createWorker(loader) {\n  // TODO - explain when this happens? Just a sanity check? Throw an error or log a warning?\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  let requestId = 0;\n  const parse = (arraybuffer, options = {}, url) =>\n    new Promise((resolve, reject) => {\n      const id = requestId++;\n\n      const onMessage = ({data}) => {\n        if (!data || data.id !== id) {\n          // not ours\n          return;\n        }\n        switch (data.type) {\n          case 'parse-done':\n            self.removeEventListener('message', onMessage);\n            resolve(data.result);\n            break;\n\n          case 'parse-error':\n            self.removeEventListener('message', onMessage);\n            reject(data.message);\n            break;\n\n          default:\n          // ignore\n        }\n      };\n      self.addEventListener('message', onMessage);\n      // Ask the main thread to decode data\n      // @ts-ignore self is WorkerGlobalScope\n      self.postMessage({type: 'parse', id, arraybuffer, options, url}, [arraybuffer]);\n    });\n\n  self.onmessage = async evt => {\n    const {data} = evt;\n\n    try {\n      if (!isKnownMessage(data, loader.name)) {\n        return;\n      }\n\n      validateLoaderVersion(loader, data.source.split('@')[1]);\n\n      const {arraybuffer, byteOffset = 0, byteLength = 0, options = {}} = data;\n\n      const result = await parseData({\n        loader,\n        arraybuffer,\n        byteOffset,\n        byteLength,\n        options,\n        context: {parse}\n      });\n      const transferList = getTransferList(result);\n      // @ts-ignore self is WorkerGlobalScope\n      self.postMessage({type: 'done', result}, transferList);\n    } catch (error) {\n      // @ts-ignore self is WorkerGlobalScope\n      self.postMessage({type: 'error', message: error.message});\n    }\n  };\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arraybuffer, byteOffset, byteLength, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arraybuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arraybuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(data, name) {\n  return data && data.type === 'parse' && data.source && data.source.startsWith('loaders.gl');\n}\n\n/*\nfunction checkMessage(evt, name) {\n  switch (evt.data && evt.data.source) {\n    // Ignore known noise event from react-dev-tools bridge, webpack build progress etc...\n    case 'react-devtools-bridge':\n    case 'react-devtools-content-script':\n    case 'react-devtools-detector':\n      return false;\n    default:\n      // fall through\n  }\n\n  switch (evt.data && evt.data.type) {\n    case 'webpackProgress':\n    case 'webpackOk':\n      return false;\n    default:\n      // Enable to debug messages\n      // const message = `${name.toLowerCase()}-worker: ignoring unknown message`;\n      // console.log(message, evt.data, evt); // eslint-disable-line\n      return false;\n  }\n}\n*/\n"],"file":"create-worker.js"}