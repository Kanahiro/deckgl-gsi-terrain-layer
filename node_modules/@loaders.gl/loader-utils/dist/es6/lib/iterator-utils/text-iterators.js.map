{"version":3,"sources":["../../../../src/lib/iterator-utils/text-iterators.js"],"names":["makeTextDecoderIterator","arrayBufferIterator","options","textDecoder","TextDecoder","arrayBuffer","decode","stream","makeTextEncoderIterator","textIterator","textEncoder","TextEncoder","text","encode","makeLineIterator","previous","textChunk","eolIndex","indexOf","line","slice","length","makeNumberedLineIterator","lineIterator","counter"],"mappings":"AAKA,OAAO,gBAAgBA,uBAAhB,CAAwCC,mBAAxC,EAA6DC,OAA7D,EAAsE;AAC3E,QAAMC,WAAW,GAAG,IAAIC,WAAJ,CAAgBF,OAAhB,CAApB;;AACA,aAAW,MAAMG,WAAjB,IAAgCJ,mBAAhC,EAAqD;AACnD,UAAM,OAAOI,WAAP,KAAuB,QAAvB,GACFA,WADE,GAEFF,WAAW,CAACG,MAAZ,CAAmBD,WAAnB,EAAgC;AAACE,MAAAA,MAAM,EAAE;AAAT,KAAhC,CAFJ;AAGD;AACF;AAOD,OAAO,gBAAgBC,uBAAhB,CAAwCC,YAAxC,EAAsDP,OAAtD,EAA+D;AACpE,QAAMQ,WAAW,GAAG,IAAIC,WAAJ,EAApB;;AACA,aAAW,MAAMC,IAAjB,IAAyBH,YAAzB,EAAuC;AACrC,UAAM,OAAOG,IAAP,KAAgB,QAAhB,GAA2BF,WAAW,CAACG,MAAZ,CAAmBD,IAAnB,CAA3B,GAAsDA,IAA5D;AACD;AACF;AAQD,OAAO,gBAAgBE,gBAAhB,CAAiCL,YAAjC,EAA+C;AACpD,MAAIM,QAAQ,GAAG,EAAf;;AACA,aAAW,MAAMC,SAAjB,IAA8BP,YAA9B,EAA4C;AAC1CM,IAAAA,QAAQ,IAAIC,SAAZ;AACA,QAAIC,QAAJ;;AACA,WAAO,CAACA,QAAQ,GAAGF,QAAQ,CAACG,OAAT,CAAiB,IAAjB,CAAZ,KAAuC,CAA9C,EAAiD;AAE/C,YAAMC,IAAI,GAAGJ,QAAQ,CAACK,KAAT,CAAe,CAAf,EAAkBH,QAAQ,GAAG,CAA7B,CAAb;AACAF,MAAAA,QAAQ,GAAGA,QAAQ,CAACK,KAAT,CAAeH,QAAQ,GAAG,CAA1B,CAAX;AACA,YAAME,IAAN;AACD;AACF;;AAED,MAAIJ,QAAQ,CAACM,MAAT,GAAkB,CAAtB,EAAyB;AACvB,UAAMN,QAAN;AACD;AACF;AAQD,OAAO,gBAAgBO,wBAAhB,CAAyCC,YAAzC,EAAuD;AAC5D,MAAIC,OAAO,GAAG,CAAd;;AACA,aAAW,MAAML,IAAjB,IAAyBI,YAAzB,EAAuC;AACrC,UAAM;AAACC,MAAAA,OAAD;AAAUL,MAAAA;AAAV,KAAN;AACAK,IAAAA,OAAO;AACR;AACF","sourcesContent":["// TextDecoder iterators\n// TextDecoder will keep any partial undecoded bytes between calls to `decode`\n\n/* global TextDecoder, TextEncoder */\n\nexport async function* makeTextDecoderIterator(arrayBufferIterator, options) {\n  const textDecoder = new TextDecoder(options);\n  for await (const arrayBuffer of arrayBufferIterator) {\n    yield typeof arrayBuffer === 'string'\n      ? arrayBuffer\n      : textDecoder.decode(arrayBuffer, {stream: true});\n  }\n}\n\n// TextEncoder iterator\n// TODO - this is not useful unless min chunk size is given\n// TextEncoder will keep any partial undecoded bytes between calls to `encode`\n// If iterator does not yield strings, assume arrayBuffer and return unencoded\n\nexport async function* makeTextEncoderIterator(textIterator, options) {\n  const textEncoder = new TextEncoder();\n  for await (const text of textIterator) {\n    yield typeof text === 'string' ? textEncoder.encode(text) : text;\n  }\n}\n\n/**\n * @param textIterator async iterable yielding strings\n * @returns an async iterable over lines\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\n\nexport async function* makeLineIterator(textIterator) {\n  let previous = '';\n  for await (const textChunk of textIterator) {\n    previous += textChunk;\n    let eolIndex;\n    while ((eolIndex = previous.indexOf('\\n')) >= 0) {\n      // line includes the EOL\n      const line = previous.slice(0, eolIndex + 1);\n      previous = previous.slice(eolIndex + 1);\n      yield line;\n    }\n  }\n\n  if (previous.length > 0) {\n    yield previous;\n  }\n}\n\n/**\n * @param lineIterator async iterable yielding lines\n * @returns async iterable yielding numbered lines\n *\n * See http://2ality.com/2018/04/async-iter-nodejs.html\n */\nexport async function* makeNumberedLineIterator(lineIterator) {\n  let counter = 1;\n  for await (const line of lineIterator) {\n    yield {counter, line};\n    counter++;\n  }\n}\n"],"file":"text-iterators.js"}