{"version":3,"sources":["../../../../src/lib/worker-loader-utils/create-worker.js"],"names":["getTransferList","validateLoaderVersion","createWorker","loader","self","requestId","parse","arraybuffer","options","url","Promise","resolve","reject","id","onMessage","data","type","removeEventListener","result","message","addEventListener","postMessage","onmessage","evt","isKnownMessage","name","source","split","byteOffset","byteLength","parseData","context","transferList","error","parser","parseSync","parseTextSync","textDecoder","TextDecoder","decode","Error","modules","worker","startsWith"],"mappings":"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","sourcesContent":["/* eslint-disable no-restricted-globals */\n/* global TextDecoder, self */\n\nimport {getTransferList} from '../worker-utils/get-transfer-list';\nimport {validateLoaderVersion} from './validate-loader-version';\n\nexport default function createWorker(loader) {\n  // TODO - explain when this happens? Just a sanity check? Throw an error or log a warning?\n  if (typeof self === 'undefined') {\n    return;\n  }\n\n  let requestId = 0;\n  const parse = (arraybuffer, options = {}, url) =>\n    new Promise((resolve, reject) => {\n      const id = requestId++;\n\n      const onMessage = ({data}) => {\n        if (!data || data.id !== id) {\n          // not ours\n          return;\n        }\n        switch (data.type) {\n          case 'parse-done':\n            self.removeEventListener('message', onMessage);\n            resolve(data.result);\n            break;\n\n          case 'parse-error':\n            self.removeEventListener('message', onMessage);\n            reject(data.message);\n            break;\n\n          default:\n          // ignore\n        }\n      };\n      self.addEventListener('message', onMessage);\n      // Ask the main thread to decode data\n      // @ts-ignore self is WorkerGlobalScope\n      self.postMessage({type: 'parse', id, arraybuffer, options, url}, [arraybuffer]);\n    });\n\n  self.onmessage = async evt => {\n    const {data} = evt;\n\n    try {\n      if (!isKnownMessage(data, loader.name)) {\n        return;\n      }\n\n      validateLoaderVersion(loader, data.source.split('@')[1]);\n\n      const {arraybuffer, byteOffset = 0, byteLength = 0, options = {}} = data;\n\n      const result = await parseData({\n        loader,\n        arraybuffer,\n        byteOffset,\n        byteLength,\n        options,\n        context: {parse}\n      });\n      const transferList = getTransferList(result);\n      // @ts-ignore self is WorkerGlobalScope\n      self.postMessage({type: 'done', result}, transferList);\n    } catch (error) {\n      // @ts-ignore self is WorkerGlobalScope\n      self.postMessage({type: 'error', message: error.message});\n    }\n  };\n}\n\n// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)\n// TODO - Why not support async loader.parse* funcs here?\n// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?\n// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse\nasync function parseData({loader, arraybuffer, byteOffset, byteLength, options, context}) {\n  let data;\n  let parser;\n  if (loader.parseSync || loader.parse) {\n    data = arraybuffer;\n    parser = loader.parseSync || loader.parse;\n  } else if (loader.parseTextSync) {\n    const textDecoder = new TextDecoder();\n    data = textDecoder.decode(arraybuffer);\n    parser = loader.parseTextSync;\n  } else {\n    throw new Error(`Could not load data with ${loader.name} loader`);\n  }\n\n  // TODO - proper merge in of loader options...\n  options = {\n    ...options,\n    modules: (loader && loader.options && loader.options.modules) || {},\n    worker: false\n  };\n\n  return await parser(data, {...options}, context, loader);\n}\n\n// Filter out noise messages sent to workers\nfunction isKnownMessage(data, name) {\n  return data && data.type === 'parse' && data.source && data.source.startsWith('loaders.gl');\n}\n\n/*\nfunction checkMessage(evt, name) {\n  switch (evt.data && evt.data.source) {\n    // Ignore known noise event from react-dev-tools bridge, webpack build progress etc...\n    case 'react-devtools-bridge':\n    case 'react-devtools-content-script':\n    case 'react-devtools-detector':\n      return false;\n    default:\n      // fall through\n  }\n\n  switch (evt.data && evt.data.type) {\n    case 'webpackProgress':\n    case 'webpackOk':\n      return false;\n    default:\n      // Enable to debug messages\n      // const message = `${name.toLowerCase()}-worker: ignoring unknown message`;\n      // console.log(message, evt.data, evt); // eslint-disable-line\n      return false;\n  }\n}\n*/\n"],"file":"create-worker.js"}