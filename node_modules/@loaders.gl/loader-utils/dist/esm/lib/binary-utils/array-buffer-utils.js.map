{"version":3,"sources":["../../../../src/lib/binary-utils/array-buffer-utils.js"],"names":["assert","node","toArrayBuffer","data","ArrayBuffer","isView","buffer","text","uint8Array","TextEncoder","encode","_toArrayBuffer","compareArrayBuffers","arrayBuffer1","arrayBuffer2","byteLength","array1","Uint8Array","array2","i","length","concatenateArrayBuffers","sources","sourceArrays","map","source2","reduce","typedArray","result","offset","sourceArray","set","sliceArrayBuffer","arrayBuffer","byteOffset","subArray","undefined","subarray","arrayCopy"],"mappings":"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","sourcesContent":["/** @typedef {import('./array-buffer-utils')} types */\n/* global TextEncoder */\nimport assert from '../env-utils/assert';\nimport * as node from '../node/buffer-utils.node';\n\n/** @type {types['toArrayBuffer']} */\nexport function toArrayBuffer(data) {\n  // Note: Should be called first, Buffers can trigger other detections below\n  if (node.toArrayBuffer) {\n    // TODO - per docs we should just be able to call buffer.buffer, but there are issues\n    data = node.toArrayBuffer(data);\n  }\n\n  if (data instanceof ArrayBuffer) {\n    return data;\n  }\n\n  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)\n  if (ArrayBuffer.isView(data)) {\n    return data.buffer;\n  }\n\n  if (typeof data === 'string') {\n    const text = data;\n    const uint8Array = new TextEncoder().encode(text);\n    return uint8Array.buffer;\n  }\n\n  // HACK to support Blob polyfill\n  if (data && typeof data === 'object' && data._toArrayBuffer) {\n    return data._toArrayBuffer();\n  }\n\n  return assert(false);\n}\n\n/** @type {types['compareArrayBuffers']} */\nexport function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {\n  byteLength = byteLength || arrayBuffer1.byteLength;\n  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {\n    return false;\n  }\n  const array1 = new Uint8Array(arrayBuffer1);\n  const array2 = new Uint8Array(arrayBuffer2);\n  for (let i = 0; i < array1.length; ++i) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// Concatenate ArrayBuffers\n/** @type {types['concatenateArrayBuffers']} */\nexport function concatenateArrayBuffers(...sources) {\n  // Make sure all inputs are wrapped in typed arrays\n  const sourceArrays = sources.map(\n    source2 => (source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2)\n  );\n\n  // Get length of all inputs\n  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);\n\n  // Allocate array with space for all inputs\n  const result = new Uint8Array(byteLength);\n\n  // Copy the subarrays\n  let offset = 0;\n  for (const sourceArray of sourceArrays) {\n    result.set(sourceArray, offset);\n    offset += sourceArray.byteLength;\n  }\n\n  // We work with ArrayBuffers, discard the typed array wrapper\n  return result.buffer;\n}\n\n// Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0\nexport function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {\n  const subArray =\n    byteLength !== undefined\n      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)\n      : new Uint8Array(arrayBuffer).subarray(byteOffset);\n  const arrayCopy = new Uint8Array(subArray);\n  return arrayCopy.buffer;\n}\n"],"file":"array-buffer-utils.js"}