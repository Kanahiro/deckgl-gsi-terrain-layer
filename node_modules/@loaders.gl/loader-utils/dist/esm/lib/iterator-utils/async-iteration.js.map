{"version":3,"sources":["../../../../src/lib/iterator-utils/async-iteration.js"],"names":["concatenateArrayBuffers","assert","forEach","iterator","visitor","next","done","value","cancel","concatenateChunksAsync","asyncIterator","arrayBuffers","strings","chunk","push","length","join"],"mappings":";;;AAAA,SAAQA,uBAAR,QAAsC,oCAAtC;AACA,OAAOC,MAAP,MAAmB,qBAAnB;AAgBA,gBAAsBC,OAAtB;AAAA;AAAA;;;wDAAO,iBAAuBC,QAAvB,EAAiCC,OAAjC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,iBAEE,IAFF;AAAA;AAAA;AAAA;;AAAA;AAAA,mBAGyBD,QAAQ,CAACE,IAAT,EAHzB;;AAAA;AAAA;AAGIC,YAAAA,IAHJ,wBAGIA,IAHJ;AAGUC,YAAAA,KAHV,wBAGUA,KAHV;;AAAA,iBAICD,IAJD;AAAA;AAAA;AAAA;;AAKDH,YAAAA,QAAQ,UAAR;AALC;;AAAA;AAQGK,YAAAA,MARH,GAQYJ,OAAO,CAACG,KAAD,CARnB;;AAAA,iBASCC,MATD;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AAuBP,gBAAsBC,sBAAtB;AAAA;AAAA;;;uEAAO,kBAAsCC,aAAtC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAECC,YAAAA,YAFD,GAEgB,EAFhB;AAICC,YAAAA,OAJD,GAIW,EAJX;AAAA;AAAA;AAAA;AAAA,uCAKqBF,aALrB;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAKYG,YAAAA,KALZ;;AAMH,gBAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7BD,cAAAA,OAAO,CAACE,IAAR,CAAaD,KAAb;AACD,aAFD,MAEO;AACLF,cAAAA,YAAY,CAACG,IAAb,CAAkBD,KAAlB;AACD;;AAVE;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA,kBAaDD,OAAO,CAACG,MAAR,GAAiB,CAbhB;AAAA;AAAA;AAAA;;AAcHd,YAAAA,MAAM,CAACU,YAAY,CAACI,MAAb,KAAwB,CAAzB,CAAN;AAdG,8CAeIH,OAAO,CAACI,IAAR,CAAa,EAAb,CAfJ;;AAAA;AAAA,8CAkBEhB,uBAAuB,MAAvB,SAA2BW,YAA3B,CAlBF;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","sourcesContent":["import {concatenateArrayBuffers} from '../binary-utils/array-buffer-utils';\nimport assert from '../env-utils/assert';\n\n// GENERAL UTILITIES\n\n/**\n * Iterate over async iterator, without resetting iterator if end is not reached\n * - forEach intentionally does not reset iterator if exiting loop prematurely\n *   so that iteration can continue in a second loop\n * - It is recommended to use a standard for-await as last loop to ensure\n *   iterator gets properly reset\n *\n * TODO - optimize using sync iteration if argument is an Iterable?\n *\n * @param iterator\n * @param visitor\n */\nexport async function forEach(iterator, visitor) {\n  // eslint-disable-next-line\n  while (true) {\n    const {done, value} = await iterator.next();\n    if (done) {\n      iterator.return();\n      return;\n    }\n    const cancel = visitor(value);\n    if (cancel) {\n      return;\n    }\n  }\n}\n\n// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects\n\n/**\n * Concatenates all data chunks yielded by an (async) iterator\n * Supports strings and ArrayBuffers\n *\n * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs\n */\nexport async function concatenateChunksAsync(asyncIterator) {\n  /** @type {ArrayBuffer[]} */\n  const arrayBuffers = [];\n  /** @type {string[]} */\n  const strings = [];\n  for await (const chunk of asyncIterator) {\n    if (typeof chunk === 'string') {\n      strings.push(chunk);\n    } else {\n      arrayBuffers.push(chunk);\n    }\n  }\n\n  if (strings.length > 0) {\n    assert(arrayBuffers.length === 0);\n    return strings.join('');\n  }\n\n  return concatenateArrayBuffers(...arrayBuffers);\n}\n"],"file":"async-iteration.js"}