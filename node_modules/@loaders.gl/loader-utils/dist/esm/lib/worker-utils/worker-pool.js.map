{"version":3,"sources":["../../../../src/lib/worker-utils/worker-pool.js"],"names":["WorkerThread","WorkerPool","source","name","maxConcurrency","onMessage","onDebug","jobQueue","idleQueue","count","isDestroyed","forEach","worker","destroy","data","jobName","Promise","resolve","reject","push","_startQueuedJob","length","_getAvailableWorker","job","shift","message","backlog","process","_onWorkerDone","toLowerCase"],"mappings":"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","sourcesContent":["import WorkerThread from './worker-thread';\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  constructor({source, name = 'unnamed', maxConcurrency = 1, onMessage, onDebug = () => {}}) {\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n  }\n\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  /**\n   * Process binary data in a worker\n   */\n  process(data, jobName) {\n    return new Promise((resolve, reject) => {\n      this.jobQueue.push({data, jobName, resolve, reject});\n      this._startQueuedJob();\n    });\n  }\n\n  // PRIVATE\n\n  async _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const worker = this._getAvailableWorker();\n    if (!worker) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const job = this.jobQueue.shift();\n\n    // @ts-ignore\n    this.onDebug({\n      message: 'processing',\n      worker: worker.name,\n      job: job.jobName,\n      backlog: this.jobQueue.length\n    });\n\n    try {\n      job.resolve(await worker.process(job.data));\n    } catch (error) {\n      job.reject(error);\n    } finally {\n      this._onWorkerDone(worker);\n    }\n  }\n\n  _onWorkerDone(worker) {\n    if (this.isDestroyed) {\n      worker.destroy();\n    } else {\n      this.idleQueue.push(worker);\n      this._startQueuedJob();\n    }\n  }\n\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift();\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this.maxConcurrency) {\n      this.count++;\n      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;\n      return new WorkerThread({source: this.source, onMessage: this.onMessage, name});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n}\n"],"file":"worker-pool.js"}