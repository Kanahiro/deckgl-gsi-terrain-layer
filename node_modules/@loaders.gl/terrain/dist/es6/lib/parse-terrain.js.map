{"version":3,"sources":["../../../src/lib/parse-terrain.js"],"names":["Martini","getMeshBoundingBox","getTerrain","imageData","tileSize","elevationDecoder","rScaler","bScaler","gScaler","offset","gridSize","terrain","Float32Array","i","y","x","k","r","g","b","getMeshAttributes","vertices","bounds","numOfVerticies","length","positions","texCoords","minX","minY","maxX","maxY","xScale","yScale","pixelIdx","POSITION","value","size","TEXCOORD_0","getMartiniTileMesh","terrainImage","terrainOptions","meshMaxError","data","width","martini","tile","createTile","triangles","getMesh","attributes","loaderData","header","vertexCount","boundingBox","mode","indices","loadTerrain","arrayBuffer","options","context","image","type","parse","baseUri"],"mappings":"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","sourcesContent":["import Martini from '@mapbox/martini';\nimport {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n\nfunction getTerrain(imageData, tileSize, elevationDecoder) {\n  const {rScaler, bScaler, gScaler, offset} = elevationDecoder;\n\n  const gridSize = tileSize + 1;\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array(gridSize * gridSize);\n  // decode terrain values\n  for (let i = 0, y = 0; y < tileSize; y++) {\n    for (let x = 0; x < tileSize; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n  // backfill bottom border\n  for (let i = gridSize * (gridSize - 1), x = 0; x < gridSize - 1; x++, i++) {\n    terrain[i] = terrain[i - gridSize];\n  }\n  // backfill right border\n  for (let i = gridSize - 1, y = 0; y < gridSize; y++, i += gridSize) {\n    terrain[i] = terrain[i - 1];\n  }\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, tileSize, bounds) {\n  const gridSize = tileSize + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, tileSize, tileSize];\n  const xScale = (maxX - minX) / tileSize;\n  const yScale = (maxY - minY) / tileSize;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n\n    texCoords[2 * i + 0] = x / tileSize;\n    texCoords[2 * i + 1] = y / tileSize;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\nfunction getMartiniTileMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  const {meshMaxError, bounds, elevationDecoder} = terrainOptions;\n\n  const data = terrainImage.data;\n  const tileSize = terrainImage.width;\n  const gridSize = tileSize + 1;\n\n  const terrain = getTerrain(data, tileSize, elevationDecoder);\n\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {vertices, triangles} = tile.getMesh(meshMaxError);\n\n  const attributes = getMeshAttributes(vertices, terrain, tileSize, bounds);\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox: getMeshBoundingBox(attributes)\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: triangles, size: 1},\n    attributes\n  };\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  options.image = options.image || {};\n  options.image.type = 'data';\n  const image = await context.parse(arrayBuffer, options, options.baseUri);\n  // Extend function to support additional mesh generation options (square grid or delatin)\n  return getMartiniTileMesh(image, options.terrain);\n}\n"],"file":"parse-terrain.js"}