{"version":3,"sources":["../../../src/lib/parse-terrain.js"],"names":["getTerrain","imageData","tileSize","elevationDecoder","rScaler","bScaler","gScaler","offset","gridSize","terrain","Float32Array","i","y","x","k","r","g","b","getMeshAttributes","vertices","bounds","numOfVerticies","length","positions","texCoords","minX","minY","maxX","maxY","xScale","yScale","pixelIdx","POSITION","value","size","TEXCOORD_0","getMartiniTileMesh","terrainImage","terrainOptions","meshMaxError","data","width","martini","Martini","tile","createTile","getMesh","triangles","attributes","loaderData","header","vertexCount","boundingBox","mode","indices","loadTerrain","arrayBuffer","options","context","image","type","parse","baseUri"],"mappings":"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","sourcesContent":["import Martini from '@mapbox/martini';\nimport {getMeshBoundingBox} from '@loaders.gl/loader-utils';\n\nfunction getTerrain(imageData, tileSize, elevationDecoder) {\n  const {rScaler, bScaler, gScaler, offset} = elevationDecoder;\n\n  const gridSize = tileSize + 1;\n  // From Martini demo\n  // https://observablehq.com/@mourner/martin-real-time-rtin-terrain-mesh\n  const terrain = new Float32Array(gridSize * gridSize);\n  // decode terrain values\n  for (let i = 0, y = 0; y < tileSize; y++) {\n    for (let x = 0; x < tileSize; x++, i++) {\n      const k = i * 4;\n      const r = imageData[k + 0];\n      const g = imageData[k + 1];\n      const b = imageData[k + 2];\n      terrain[i + y] = r * rScaler + g * gScaler + b * bScaler + offset;\n    }\n  }\n  // backfill bottom border\n  for (let i = gridSize * (gridSize - 1), x = 0; x < gridSize - 1; x++, i++) {\n    terrain[i] = terrain[i - gridSize];\n  }\n  // backfill right border\n  for (let i = gridSize - 1, y = 0; y < gridSize; y++, i += gridSize) {\n    terrain[i] = terrain[i - 1];\n  }\n  return terrain;\n}\n\nfunction getMeshAttributes(vertices, terrain, tileSize, bounds) {\n  const gridSize = tileSize + 1;\n  const numOfVerticies = vertices.length / 2;\n  // vec3. x, y in pixels, z in meters\n  const positions = new Float32Array(numOfVerticies * 3);\n  // vec2. 1 to 1 relationship with position. represents the uv on the texture image. 0,0 to 1,1.\n  const texCoords = new Float32Array(numOfVerticies * 2);\n\n  const [minX, minY, maxX, maxY] = bounds || [0, 0, tileSize, tileSize];\n  const xScale = (maxX - minX) / tileSize;\n  const yScale = (maxY - minY) / tileSize;\n\n  for (let i = 0; i < numOfVerticies; i++) {\n    const x = vertices[i * 2];\n    const y = vertices[i * 2 + 1];\n    const pixelIdx = y * gridSize + x;\n\n    positions[3 * i + 0] = x * xScale + minX;\n    positions[3 * i + 1] = -y * yScale + maxY;\n    positions[3 * i + 2] = terrain[pixelIdx];\n\n    texCoords[2 * i + 0] = x / tileSize;\n    texCoords[2 * i + 1] = y / tileSize;\n  }\n\n  return {\n    POSITION: {value: positions, size: 3},\n    TEXCOORD_0: {value: texCoords, size: 2}\n    // NORMAL: {}, - optional, but creates the high poly look with lighting\n  };\n}\n\nfunction getMartiniTileMesh(terrainImage, terrainOptions) {\n  if (terrainImage === null) {\n    return null;\n  }\n  const {meshMaxError, bounds, elevationDecoder} = terrainOptions;\n\n  const data = terrainImage.data;\n  const tileSize = terrainImage.width;\n  const gridSize = tileSize + 1;\n\n  const terrain = getTerrain(data, tileSize, elevationDecoder);\n\n  const martini = new Martini(gridSize);\n  const tile = martini.createTile(terrain);\n  const {vertices, triangles} = tile.getMesh(meshMaxError);\n\n  const attributes = getMeshAttributes(vertices, terrain, tileSize, bounds);\n\n  return {\n    // Data return by this loader implementation\n    loaderData: {\n      header: {}\n    },\n    header: {\n      vertexCount: triangles.length,\n      boundingBox: getMeshBoundingBox(attributes)\n    },\n    mode: 4, // TRIANGLES\n    indices: {value: triangles, size: 1},\n    attributes\n  };\n}\n\nexport default async function loadTerrain(arrayBuffer, options, context) {\n  options.image = options.image || {};\n  options.image.type = 'data';\n  const image = await context.parse(arrayBuffer, options, options.baseUri);\n  // Extend function to support additional mesh generation options (square grid or delatin)\n  return getMartiniTileMesh(image, options.terrain);\n}\n"],"file":"parse-terrain.js"}