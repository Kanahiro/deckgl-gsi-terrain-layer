{"version":3,"sources":["../../../../src/lib/extensions/KHR_draco_mesh_compression.js"],"names":["DracoLoader","getZeroOffsetArrayBuffer","GLTFScenegraph","KHR_DRACO_MESH_COMPRESSION","getGLTFAccessors","getGLTFAccessor","decode","gltfData","options","context","gltf","decompressMeshes","scenegraph","promises","primitive","makeMeshPrimitiveIterator","getObjectExtension","push","decompressPrimitive","Promise","all","removeExtension","encode","mesh","json","meshes","compressMesh","addRequiredExtension","compressedPrimitive","buffer","getTypedArrayForBufferView","bufferView","bufferCopy","byteOffset","parse","decodedData","attributes","indices","checkPrimitive","mode","DracoWriter","Error","compressedData","encodeSync","parseSync","fauxAccessors","_addFauxAttributes","bufferViewIndex","addBufferView","glTFMesh","primitives","extensions","Object","keys","length"],"mappings":"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","sourcesContent":["// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\n\n/* eslint-disable camelcase */\n\nimport {DracoLoader} from '@loaders.gl/draco';\nimport {getZeroOffsetArrayBuffer} from '@loaders.gl/loader-utils';\nimport GLTFScenegraph from '../gltf-scenegraph';\nimport {KHR_DRACO_MESH_COMPRESSION} from '../gltf-constants';\nimport {getGLTFAccessors, getGLTFAccessor} from '../gltf-utils/gltf-attribute-utils';\n\n// Note: We have a \"soft dependency\" on Draco to avoid bundling it when not needed\nexport async function decode(gltfData, options, context) {\n  if (!options.gltf.decompressMeshes) {\n    return;\n  }\n\n  const scenegraph = new GLTFScenegraph(gltfData);\n  const promises = [];\n  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {\n    if (scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION)) {\n      promises.push(decompressPrimitive(primitive, scenegraph, options, context));\n    }\n  }\n\n  // Decompress meshes in parallel\n  await Promise.all(promises);\n\n  // We have now decompressed all primitives, so remove the top-level extensions\n  scenegraph.removeExtension(KHR_DRACO_MESH_COMPRESSION);\n}\n\nexport function encode(gltfData, options = {}) {\n  const scenegraph = new GLTFScenegraph(gltfData);\n\n  for (const mesh of scenegraph.json.meshes || []) {\n    // eslint-disable-next-line camelcase\n    compressMesh(mesh, options);\n    // NOTE: Only add the extension if something was actually compressed\n    scenegraph.addRequiredExtension(KHR_DRACO_MESH_COMPRESSION);\n  }\n}\n\n// DECODE\n\n// Unpacks one mesh primitive and removes the extension from the primitive\n// DracoDecoder needs to be imported and registered by app\n// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete\n\n// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec\n\nasync function decompressPrimitive(primitive, scenegraph, options, context) {\n  const compressedPrimitive = scenegraph.getObjectExtension(primitive, KHR_DRACO_MESH_COMPRESSION);\n\n  const buffer = scenegraph.getTypedArrayForBufferView(compressedPrimitive.bufferView);\n  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer\n  // TODO - remove when `parse` is fixed to handle `byteOffset`s\n  const bufferCopy = getZeroOffsetArrayBuffer(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);\n\n  // this will generate an exception if DracoLoader is not installed\n  const {parse} = context;\n  const decodedData = await parse(bufferCopy, DracoLoader, options, context);\n\n  primitive.attributes = getGLTFAccessors(decodedData.attributes);\n  if (decodedData.indices) {\n    primitive.indices = getGLTFAccessor(decodedData.indices);\n  }\n\n  // Extension has been processed, delete it\n  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];\n\n  checkPrimitive(primitive);\n}\n\n// ENCODE\n\n// eslint-disable-next-line max-len\n// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported\nfunction compressMesh(attributes, indices, mode = 4, options, context) {\n  if (!options.DracoWriter || !options.DracoLoader) {\n    throw new Error('DracoWriter/DracoLoader not available');\n  }\n\n  // TODO - use DracoWriter using encode w/ registered DracoWriter...\n  const compressedData = options.DracoWriter.encodeSync({attributes});\n\n  // Draco compression may change the order and number of vertices in a mesh.\n  // To satisfy the requirement that accessors properties be correct for both\n  // compressed and uncompressed data, generators should create uncompressed\n  // attributes and indices using data that has been decompressed from the Draco buffer,\n  // rather than the original source data.\n  const {parseSync} = context;\n  const decodedData = parseSync({attributes});\n  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);\n\n  const bufferViewIndex = options.addBufferView(compressedData);\n\n  const glTFMesh = {\n    primitives: [\n      {\n        attributes: fauxAccessors, // TODO - verify with spec\n        mode, // GL.POINTS\n        extensions: {\n          [KHR_DRACO_MESH_COMPRESSION]: {\n            bufferView: bufferViewIndex,\n            attributes: fauxAccessors // TODO - verify with spec\n          }\n        }\n      }\n    ]\n  };\n\n  return glTFMesh;\n}\n\n// UTILS\n\nfunction checkPrimitive(primitive) {\n  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {\n    throw new Error('Empty glTF primitive detected: Draco decompression failure?');\n  }\n}\n\nfunction* makeMeshPrimitiveIterator(scenegraph) {\n  for (const mesh of scenegraph.json.meshes || []) {\n    for (const primitive of mesh.primitives) {\n      yield primitive;\n    }\n  }\n}\n"],"file":"KHR_draco_mesh_compression.js"}