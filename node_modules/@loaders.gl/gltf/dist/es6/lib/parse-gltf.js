import { ImageLoader } from '@loaders.gl/images';
import { parseJSON, getZeroOffsetArrayBuffer } from '@loaders.gl/loader-utils';
import assert from './utils/assert';
import { resolveUrl } from './gltf-utils/resolve-url';
import { getTypedArrayForBufferView } from './gltf-utils/get-typed-array';
import { decodeExtensions } from './extensions/gltf-extensions';
import parseGLBSync, { isGLB } from './parse-glb';
import normalizeGLTFV1 from './normalize-gltf-v1';
import postProcessGLTF from './post-process-gltf';
export function isGLTF(arrayBuffer, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const byteOffset = 0;
  return isGLB(dataView, byteOffset);
}
export async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);
  normalizeGLTFV1(gltf, {
    normalize: options.gltf.normalize
  });
  const promises = [];

  if (options.gltf.loadImages) {
    const promise = loadImages(gltf, options, context);
    promises.push(promise);
  }

  if (options.gltf.loadBuffers) {
    await loadBuffers(gltf, options, context);
  }

  const promise = decodeExtensions(gltf, options, context);
  promises.push(promise);
  await Promise.all(promises);
  return options.gltf.postProcess ? postProcessGLTF(gltf, options) : gltf;
}

function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  if (options.uri) {
    gltf.baseUri = options.uri;
  }

  if (data instanceof ArrayBuffer && !isGLB(data, byteOffset, options)) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }

  if (typeof data === 'string') {
    gltf.json = parseJSON(data);
  } else if (data instanceof ArrayBuffer) {
    const glb = {};
    byteOffset = parseGLBSync(glb, data, byteOffset, options);
    assert(glb.type === 'glTF', "Invalid GLB magic string ".concat(glb.type));
    gltf._glb = glb;
    gltf.json = glb.json;
  } else {
    assert(false, "GLTF: must be ArrayBuffer or string");
  }

  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill(null);

  if (gltf._glb && gltf._glb.header.hasBinChunk) {
    const {
      binChunks
    } = gltf._glb;
    gltf.buffers[0] = {
      arrayBuffer: binChunks[0].arrayBuffer,
      byteOffset: binChunks[0].byteOffset,
      byteLength: binChunks[0].byteLength
    };
  }

  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}

async function loadBuffers(gltf, options, context) {
  for (let i = 0; i < gltf.json.buffers.length; ++i) {
    const buffer = gltf.json.buffers[i];

    if (buffer.uri) {
      const {
        fetch
      } = context;
      assert(fetch);
      const uri = resolveUrl(buffer.uri, options);
      const response = await fetch(uri);
      const arrayBuffer = await response.arrayBuffer();
      gltf.buffers[i] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };
      delete buffer.uri;
    }
  }
}

async function loadImages(gltf, options, context) {
  const images = gltf.json.images || [];
  const promises = [];

  for (let i = 0; i < images.length; ++i) {
    promises.push(loadImage(gltf, images[i], i, options, context));
  }

  return await Promise.all(promises);
}

async function loadImage(gltf, image, i, options, context) {
  const {
    fetch,
    parse
  } = context;
  let arrayBuffer;

  if (image.uri) {
    const uri = resolveUrl(image.uri, options);
    const response = await fetch(uri);
    arrayBuffer = await response.arrayBuffer();
  }

  if (Number.isFinite(image.bufferView)) {
    const array = getTypedArrayForBufferView(gltf.json, gltf.buffers, image.bufferView);
    arrayBuffer = getZeroOffsetArrayBuffer(array.buffer, array.byteOffset, array.byteLength);
  }

  assert(arrayBuffer, 'glTF image has no data');
  const parsedImage = await parse(arrayBuffer, ImageLoader, {}, context);
  gltf.images[i] = parsedImage;
}
//# sourceMappingURL=parse-gltf.js.map