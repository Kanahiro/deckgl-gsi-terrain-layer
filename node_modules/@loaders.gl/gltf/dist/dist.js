(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!************************************************************************************************************!*\
  !*** /home/vasia/Sites/actionengine/loaders_dev/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!*********************************************************************************************************!*\
  !*** /home/vasia/Sites/actionengine/loaders_dev/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \*********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/index.js":
/*!*************************************************************************************************!*\
  !*** /home/vasia/Sites/actionengine/loaders_dev/node_modules/@probe.gl/stats/dist/esm/index.js ***!
  \*************************************************************************************************/
/*! exports provided: Stats, Stat, _getHiResTimestamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_stats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stats */ "../../node_modules/@probe.gl/stats/dist/esm/lib/stats.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stats", function() { return _lib_stats__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_stat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/stat */ "../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stat", function() { return _lib_stat__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/hi-res-timestamp */ "../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getHiResTimestamp", function() { return _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"]; });




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js":
/*!****************************************************************************************************!*\
  !*** /home/vasia/Sites/actionengine/loaders_dev/node_modules/@probe.gl/stats/dist/esm/lib/stat.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stat; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/hi-res-timestamp */ "../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js");




var Stat = function () {
  function Stat(name, type) {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Stat);

    this.name = name;
    this.type = type;
    this.sampleSize = 1;
    this.reset();
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Stat, [{
    key: "setSampleSize",
    value: function setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
  }, {
    key: "incrementCount",
    value: function incrementCount() {
      this.addCount(1);
      return this;
    }
  }, {
    key: "decrementCount",
    value: function decrementCount() {
      this.subtractCount(1);
      return this;
    }
  }, {
    key: "addCount",
    value: function addCount(value) {
      this._count += value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "subtractCount",
    value: function subtractCount(value) {
      this._count -= value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "addTime",
    value: function addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "timeStart",
    value: function timeStart() {
      this._startTime = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"])();
      this._timerPending = true;
      return this;
    }
  }, {
    key: "timeEnd",
    value: function timeEnd() {
      if (!this._timerPending) {
        return this;
      }

      this.addTime(Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"])() - this._startTime);
      this._timerPending = false;

      this._checkSampling();

      return this;
    }
  }, {
    key: "getSampleAverageCount",
    value: function getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
  }, {
    key: "getSampleAverageTime",
    value: function getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
  }, {
    key: "getSampleHz",
    value: function getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
  }, {
    key: "getAverageCount",
    value: function getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
  }, {
    key: "getAverageTime",
    value: function getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
  }, {
    key: "getHz",
    value: function getHz() {
      return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
  }, {
    key: "_checkSampling",
    value: function _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  }]);

  return Stat;
}();


//# sourceMappingURL=stat.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/lib/stats.js":
/*!*****************************************************************************************************!*\
  !*** /home/vasia/Sites/actionengine/loaders_dev/node_modules/@probe.gl/stats/dist/esm/lib/stats.js ***!
  \*****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stats; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _stat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat */ "../../node_modules/@probe.gl/stats/dist/esm/lib/stat.js");




var Stats = function () {
  function Stats(_ref) {
    var id = _ref.id,
        stats = _ref.stats;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Stats);

    this.id = id;
    this.stats = {};

    this._initializeStats(stats);

    Object.seal(this);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Stats, [{
    key: "get",
    value: function get(name) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
      return this._getOrCreate({
        name: name,
        type: type
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var key in this.stats) {
        this.stats[key].reset();
      }

      return this;
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      for (var key in this.stats) {
        fn(this.stats[key]);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      var table = {};
      this.forEach(function (stat) {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
  }, {
    key: "_initializeStats",
    value: function _initializeStats() {
      var _this = this;

      var stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      stats.forEach(function (stat) {
        return _this._getOrCreate(stat);
      });
    }
  }, {
    key: "_getOrCreate",
    value: function _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }

      var name = stat.name,
          type = stat.type;

      if (!this.stats[name]) {
        if (stat instanceof _stat__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          this.stats[name] = stat;
        } else {
          this.stats[name] = new _stat__WEBPACK_IMPORTED_MODULE_2__["default"](name, type);
        }
      }

      return this.stats[name];
    }
  }, {
    key: "size",
    get: function get() {
      return Object.keys(this.stats).length;
    }
  }]);

  return Stats;
}();


//# sourceMappingURL=stats.js.map

/***/ }),

/***/ "../../node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js":
/*!******************************************************************************************************************!*\
  !*** /home/vasia/Sites/actionengine/loaders_dev/node_modules/@probe.gl/stats/dist/esm/utils/hi-res-timestamp.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getHiResTimestamp; });
function getHiResTimestamp() {
  var timestamp;

  if (typeof window !== 'undefined' && window.performance) {
    timestamp = window.performance.now();
  } else if (typeof process !== 'undefined' && process.hrtime) {
    var timeParts = process.hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
//# sourceMappingURL=hi-res-timestamp.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!**********************************************************************************!*\
  !*** /home/vasia/Sites/actionengine/loaders_dev/node_modules/process/browser.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../draco/src/draco-loader.js":
/*!************************************!*\
  !*** ../draco/src/draco-loader.js ***!
  \************************************/
/*! exports provided: DracoWorkerLoader, DracoLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DracoWorkerLoader", function() { return DracoWorkerLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DracoLoader", function() { return DracoLoader; });
/* harmony import */ var _lib_draco_module_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/draco-module-loader */ "../draco/src/lib/draco-module-loader.js");
/* harmony import */ var _lib_draco_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/draco-parser */ "../draco/src/lib/draco-parser.js");
/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */
/** @typedef {import('@loaders.gl/loader-utils').WorkerLoaderObject} WorkerLoaderObject */



// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.1" : undefined;

/** @type {WorkerLoaderObject} */
const DracoWorkerLoader = {
  id: 'draco',
  name: 'Draco',
  version: VERSION,
  extensions: ['drc'],
  mimeTypes: ['application/octet-stream'],
  binary: true,
  tests: ['DRACO'],
  options: {
    draco: {
      decoderType: typeof WebAssembly === 'object' ? 'wasm' : 'js', // 'js' for IE11
      libraryPath: `libs/`,
      workerUrl: `https://unpkg.com/@loaders.gl/draco@${VERSION}/dist/draco-loader.worker.js`,
      localWorkerUrl: `modules/draco/dist/draco-loader.worker.dev.js`,
      extraAttributes: {}
    }
  }
};

/** @type {LoaderObject} */
const DracoLoader = {
  ...DracoWorkerLoader,
  parse
};

async function parse(arrayBuffer, options, context, loader) {
  const {draco} = await Object(_lib_draco_module_loader__WEBPACK_IMPORTED_MODULE_0__["loadDracoDecoderModule"])(options);
  const dracoParser = new _lib_draco_parser__WEBPACK_IMPORTED_MODULE_1__["default"](draco);
  try {
    // TODO passing in options causes CI failures...
    // @ts-ignore
    return dracoParser.parseSync(arrayBuffer, {
      extraAttributes: (options.draco && options.draco.extraAttributes) || null,
      ...(options.parseOptions || {})
    });
  } finally {
    dracoParser.destroy();
  }
}


/***/ }),

/***/ "../draco/src/draco-writer.js":
/*!************************************!*\
  !*** ../draco/src/draco-writer.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_draco_module_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/draco-module-loader */ "../draco/src/lib/draco-module-loader.js");
/* harmony import */ var _lib_draco_builder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/draco-builder */ "../draco/src/lib/draco-builder.js");



/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'DRACO',
  extensions: ['drc'],
  encode,
  options: {
    draco: {
      pointcloud: false // Set to true if pointcloud (mode: 0, no indices)
      // Draco Compression Parameters
      // method: 'MESH_EDGEBREAKER_ENCODING',
      // speed: [5, 5],
      // quantization: {
      //   POSITION: 10
      // }
    }
  }
});

async function encode(data, options) {
  // DEPRECATED - remove support for options
  const dracoOptions = (options && options.draco) || options || {};

  // Dynamically load draco
  const {draco} = await Object(_lib_draco_module_loader__WEBPACK_IMPORTED_MODULE_0__["loadDracoEncoderModule"])(options || {});
  const dracoBuilder = new _lib_draco_builder__WEBPACK_IMPORTED_MODULE_1__["default"](draco);

  try {
    return dracoBuilder.encodeSync(data, dracoOptions);
  } finally {
    dracoBuilder.destroy();
  }
}


/***/ }),

/***/ "../draco/src/index.js":
/*!*****************************!*\
  !*** ../draco/src/index.js ***!
  \*****************************/
/*! exports provided: DracoLoader, DracoWorkerLoader, DracoWriter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _draco_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./draco-loader */ "../draco/src/draco-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DracoLoader", function() { return _draco_loader__WEBPACK_IMPORTED_MODULE_0__["DracoLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DracoWorkerLoader", function() { return _draco_loader__WEBPACK_IMPORTED_MODULE_0__["DracoWorkerLoader"]; });

/* harmony import */ var _draco_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./draco-writer */ "../draco/src/draco-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DracoWriter", function() { return _draco_writer__WEBPACK_IMPORTED_MODULE_1__["default"]; });





/***/ }),

/***/ "../draco/src/lib/draco-builder.js":
/*!*****************************************!*\
  !*** ../draco/src/lib/draco-builder.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DracoBuilder; });
// This code is inspired by example code in the DRACO repository
/** @typedef {import('../types/draco-types')} Draco3D */
/** @typedef {import('../types/draco-types').TypedArray} TypedArray */
/** @typedef {import('../types/draco-types').DracoInt8Array} DracoInt8Array */
/** @typedef {import('../types/draco-types').Encoder} Encoder */
/** @typedef {import('../types/draco-types').Mesh} Mesh */
/** @typedef {import('../types/draco-types').PointCloud} PointCloud */
/** @typedef {import('../types/draco-types').Metadata} Metadata */
/** @typedef {import('../types/draco-types').PointCloudBuilder} PointCloudBuilder */
/** @typedef {import('../types/draco-types').MetadataBuilder} MetadataBuilder */

// Native Draco attribute names to GLTF attribute names.
const GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP = {
  POSITION: 'POSITION',
  NORMAL: 'NORMAL',
  COLOR_0: 'COLOR',
  TEXCOORD_0: 'TEX_COORD'
};

function noop() {}

class DracoBuilder {
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(draco, options = {}) {
    /** @type {Draco3D} */
    this.draco = draco;
    this.dracoEncoder = new this.draco.Encoder();
    this.dracoMeshBuilder = new this.draco.MeshBuilder();
    this.dracoMetadataBuilder = new this.draco.MetadataBuilder();
    this.log = options.log || noop;
  }

  destroy() {
    this.destroyEncodedObject(this.dracoMeshBuilder);
    this.destroyEncodedObject(this.dracoEncoder);
    this.destroyEncodedObject(this.dracoMetadataBuilder);
    // @ts-ignore
    this.dracoMeshBuilder = null;
    // @ts-ignore
    this.dracoEncoder = null;
    // @ts-ignore
    this.draco = null;
  }

  // TBD - when does this need to be called?
  destroyEncodedObject(object) {
    if (object) {
      this.draco.destroy(object);
    }
  }

  // Encode mesh=({})
  encodeSync(mesh, options = {}) {
    this._setOptions(options);

    return options.pointcloud
      ? this._encodePointCloud(mesh, options)
      : this._encodeMesh(mesh, options);
  }

  // PRIVATE

  _getAttributesFromMesh(mesh) {
    // TODO - Change the encodePointCloud interface instead?
    const attributes = {...mesh, ...mesh.attributes};
    // Fold indices into the attributes
    if (mesh.indices) {
      attributes.indices = mesh.indices;
    }
    return attributes;
  }

  _encodePointCloud(pointcloud, options) {
    const dracoPointCloud = new this.draco.PointCloud();

    if (options.metadata) {
      this._addGeometryMetadata(dracoPointCloud, options.metadata);
    }

    const attributes = this._getAttributesFromMesh(pointcloud);

    // Build a `DracoPointCloud` from the input data
    this._createDracoPointCloud(dracoPointCloud, attributes, options);

    const dracoData = new this.draco.DracoInt8Array();

    try {
      const encodedLen = this.dracoEncoder.EncodePointCloudToDracoBuffer(
        dracoPointCloud,
        false,
        dracoData
      );

      if (!(encodedLen > 0)) {
        throw new Error('Draco encoding failed.');
      }

      this.log(`DRACO encoded ${dracoPointCloud.num_points()} points
        with ${dracoPointCloud.num_attributes()} attributes into ${encodedLen} bytes`);

      return dracoInt8ArrayToArrayBuffer(dracoData);
    } finally {
      this.destroyEncodedObject(dracoData);
      this.destroyEncodedObject(dracoPointCloud);
    }
  }

  _encodeMesh(mesh, options) {
    const dracoMesh = new this.draco.Mesh();

    if (options.metadata) {
      this._addGeometryMetadata(dracoMesh, options.metadata);
    }

    const attributes = this._getAttributesFromMesh(mesh);

    // Build a `DracoMesh` from the input data
    this._createDracoMesh(dracoMesh, attributes, options);

    const dracoData = new this.draco.DracoInt8Array();

    try {
      const encodedLen = this.dracoEncoder.EncodeMeshToDracoBuffer(dracoMesh, dracoData);
      if (encodedLen <= 0) {
        throw new Error('Draco encoding failed.');
      }

      this.log(`DRACO encoded ${dracoMesh.num_points()} points
        with ${dracoMesh.num_attributes()} attributes into ${encodedLen} bytes`);

      return dracoInt8ArrayToArrayBuffer(dracoData);
    } finally {
      this.destroyEncodedObject(dracoData);
      this.destroyEncodedObject(dracoMesh);
    }
  }

  /**
   * Set encoding options.
   * @param {{speed?: any; method?: any; quantization?: any;}} options
   */
  _setOptions(options) {
    if ('speed' in options) {
      // @ts-ignore
      this.dracoEncoder.SetSpeedOptions(...options.speed);
    }
    if ('method' in options) {
      const dracoMethod = this.draco[options.method];
      // assert(dracoMethod)
      this.dracoEncoder.SetEncodingMethod(dracoMethod);
    }
    if ('quantization' in options) {
      for (const attribute in options.quantization) {
        const bits = options.quantization[attribute];
        const dracoPosition = this.draco[attribute];
        this.dracoEncoder.SetAttributeQuantization(dracoPosition, bits);
      }
    }
  }

  /**
   * @param {Mesh} dracoMesh
   * @param {object} attributes
   * @returns {Mesh}
   */
  _createDracoMesh(dracoMesh, attributes, options) {
    const optionalMetadata = options.attributesMetadata || {};

    try {
      const positions = this._getPositionAttribute(attributes);
      if (!positions) {
        throw new Error('positions');
      }
      const vertexCount = positions.length / 3;

      for (let attributeName in attributes) {
        const attribute = attributes[attributeName];
        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;
        const uniqueId = this._addAttributeToMesh(dracoMesh, attributeName, attribute, vertexCount);

        if (uniqueId !== -1) {
          this._addAttributeMetadata(dracoMesh, uniqueId, {
            name: attributeName,
            ...(optionalMetadata[attributeName] || {})
          });
        }
      }
    } catch (error) {
      this.destroyEncodedObject(dracoMesh);
      throw error;
    }

    return dracoMesh;
  }

  /**
   * @param {PointCloud} dracoPointCloud
   * @param {object} attributes
   * @returns {PointCloud}
   */
  _createDracoPointCloud(dracoPointCloud, attributes, options) {
    const optionalMetadata = options.attributesMetadata || {};

    try {
      const positions = this._getPositionAttribute(attributes);
      if (!positions) {
        throw new Error('positions');
      }
      const vertexCount = positions.length / 3;

      for (let attributeName in attributes) {
        const attribute = attributes[attributeName];
        attributeName = GLTF_TO_DRACO_ATTRIBUTE_NAME_MAP[attributeName] || attributeName;
        const uniqueId = this._addAttributeToMesh(
          dracoPointCloud,
          attributeName,
          attribute,
          vertexCount
        );
        if (uniqueId !== -1) {
          this._addAttributeMetadata(dracoPointCloud, uniqueId, {
            name: attributeName,
            ...(optionalMetadata[attributeName] || {})
          });
        }
      }
    } catch (error) {
      this.destroyEncodedObject(dracoPointCloud);
      throw error;
    }

    return dracoPointCloud;
  }

  /**
   * @param {PointCloud} mesh
   * @param {string} attributeName
   * @param {TypedArray} attribute
   * @param {number} vertexCount
   */
  _addAttributeToMesh(mesh, attributeName, attribute, vertexCount) {
    if (!ArrayBuffer.isView(attribute)) {
      return -1;
    }

    const type = this._getDracoAttributeType(attributeName);
    // @ts-ignore TODO/fix types
    const size = attribute.length / vertexCount;

    if (type === 'indices') {
      // @ts-ignore TODO/fix types
      const numFaces = attribute.length / 3;
      this.log(`Adding attribute ${attributeName}, size ${numFaces}`);

      // @ts-ignore assumes mesh is a Mesh, not a point cloud
      this.dracoMeshBuilder.AddFacesToMesh(mesh, numFaces, attribute);
      return -1;
    }

    this.log(`Adding attribute ${attributeName}, size ${size}`);

    const builder = this.dracoMeshBuilder;
    const {buffer} = attribute;

    switch (attribute.constructor) {
      case Int8Array:
        return builder.AddInt8Attribute(mesh, type, vertexCount, size, new Int8Array(buffer));

      case Int16Array:
        return builder.AddInt16Attribute(mesh, type, vertexCount, size, new Int16Array(buffer));

      case Int32Array:
        return builder.AddInt32Attribute(mesh, type, vertexCount, size, new Int32Array(buffer));
      case Uint8Array:
      case Uint8ClampedArray:
        return builder.AddUInt8Attribute(mesh, type, vertexCount, size, new Uint8Array(buffer));

      case Uint16Array:
        return builder.AddUInt16Attribute(mesh, type, vertexCount, size, new Uint16Array(buffer));

      case Uint32Array:
        return builder.AddUInt32Attribute(mesh, type, vertexCount, size, new Uint32Array(buffer));

      case Float32Array:
      default:
        return builder.AddFloatAttribute(mesh, type, vertexCount, size, new Float32Array(buffer));
    }
  }

  /**
   * DRACO can compress attributes of know type better
   * TODO - expose an attribute type map?
   * @param {*} attributeName
   */
  _getDracoAttributeType(attributeName) {
    switch (attributeName.toLowerCase()) {
      case 'indices':
        return 'indices';
      case 'position':
      case 'positions':
      case 'vertices':
        return this.draco.POSITION;
      case 'normal':
      case 'normals':
        return this.draco.NORMAL;
      case 'color':
      case 'colors':
        return this.draco.COLOR;
      case 'texCoord':
      case 'texCoords':
        return this.draco.TEX_COORD;
      default:
        return this.draco.GENERIC;
    }
  }

  _getPositionAttribute(attributes) {
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const dracoType = this._getDracoAttributeType(attributeName);
      if (dracoType === this.draco.POSITION) {
        return attribute;
      }
    }
    return null;
  }

  /**
   * Add metadata for the geometry.
   * @param {PointCloud} dracoGeometry - WASM Draco Object
   * @param {Map<string, string>|{[key: string]: string}} metadata
   */
  _addGeometryMetadata(dracoGeometry, metadata) {
    const dracoMetadata = new this.draco.Metadata();
    this._populateDracoMetadata(dracoMetadata, metadata);
    this.dracoMeshBuilder.AddMetadata(dracoGeometry, dracoMetadata);
  }

  /**
   * Add metadata for an attribute to geometry.
   * @param {PointCloud} dracoGeometry - WASM Draco Object
   * @param {number} uniqueAttributeId
   * @param {Map<string, string>|{[key: string]: string}} metadata
   */
  _addAttributeMetadata(dracoGeometry, uniqueAttributeId, metadata) {
    // Note: Draco JS IDL doesn't seem to expose draco.AttributeMetadata, however it seems to
    // create such objects automatically from draco.Metadata object.
    const dracoAttributeMetadata = new this.draco.Metadata();
    this._populateDracoMetadata(dracoAttributeMetadata, metadata);
    // Draco3d doc note: Directly add attribute metadata to geometry.
    // You can do this without explicitly adding |GeometryMetadata| to mesh.
    this.dracoMeshBuilder.SetMetadataForAttribute(
      dracoGeometry,
      uniqueAttributeId,
      dracoAttributeMetadata
    );
  }

  /**
   * Add contents of object or map to a WASM Draco Metadata Object
   * @param {Metadata} dracoMetadata - WASM Draco Object
   * @param {Map<string, string>|{[key: string]: string}} metadata
   */
  _populateDracoMetadata(dracoMetadata, metadata) {
    for (const [key, value] of getEntries(metadata)) {
      switch (typeof value) {
        case 'number':
          if (Math.trunc(value) === value) {
            this.dracoMetadataBuilder.AddIntEntry(dracoMetadata, key, value);
          } else {
            this.dracoMetadataBuilder.AddDoubleEntry(dracoMetadata, key, value);
          }
          break;
        case 'string':
        default:
          this.dracoMetadataBuilder.AddStringEntry(dracoMetadata, key, value);
      }
    }
  }
}

// HELPER FUNCTIONS

/**
 * Copy encoded data to buffer
 * @param {DracoInt8Array} dracoData
 */
function dracoInt8ArrayToArrayBuffer(dracoData) {
  const byteLength = dracoData.size();
  const outputBuffer = new ArrayBuffer(byteLength);
  const outputData = new Int8Array(outputBuffer);
  for (let i = 0; i < byteLength; ++i) {
    outputData[i] = dracoData.GetValue(i);
  }
  return outputBuffer;
}

/** Enable iteration over either an object or a map */
function getEntries(container) {
  const hasEntriesFunc = container.entries && !container.hasOwnProperty('entries');
  return hasEntriesFunc ? container.entries() : Object.entries(container);
}


/***/ }),

/***/ "../draco/src/lib/draco-module-loader.js":
/*!***********************************************!*\
  !*** ../draco/src/lib/draco-module-loader.js ***!
  \***********************************************/
/*! exports provided: loadDracoDecoderModule, loadDracoEncoderModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadDracoDecoderModule", function() { return loadDracoDecoderModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadDracoEncoderModule", function() { return loadDracoEncoderModule; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
// Dynamic DRACO module loading inspired by THREE.DRACOLoader
// https://github.com/mrdoob/three.js/blob/398c4f39ebdb8b23eefd4a7a5ec49ec0c96c7462/examples/jsm/loaders/DRACOLoader.js
// by Don McCurdy / https://www.donmccurdy.com / MIT license



let loadDecoderPromise;
let loadEncoderPromise;

async function loadDracoDecoderModule(options) {
  const modules = options.modules || {};

  // Check if a bundled draco3d library has been supplied by application
  if (modules.draco3d) {
    loadDecoderPromise =
      loadDecoderPromise ||
      new Promise(resolve => {
        const draco = modules.draco3d.createDecoderModule({
          onModuleLoaded() {
            resolve({draco});
          }
        });
      });
  } else {
    // If not, dynamically load the WASM script from our CDN
    loadDecoderPromise = loadDecoderPromise || loadDracoDecoder(options);
  }
  return await loadDecoderPromise;
}

async function loadDracoEncoderModule(options) {
  const modules = options.modules || {};

  // Check if a bundled draco3d library has been supplied by application
  if (modules.draco3d) {
    loadEncoderPromise =
      loadEncoderPromise ||
      new Promise(resolve => {
        const draco = modules.draco3d.createEncoderModule({
          onModuleLoaded() {
            resolve({draco});
          }
        });
      });
  } else {
    // If not, dynamically load the WASM script from our CDN
    loadEncoderPromise = loadEncoderPromise || loadDracoEncoder(options);
  }
  return await loadEncoderPromise;
}

// DRACO DECODER LOADING

async function loadDracoDecoder(options) {
  let DracoDecoderModule;
  let wasmBinary;
  switch (options.draco && options.draco.decoderType) {
    case 'js':
      DracoDecoderModule = await Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["loadLibrary"])('draco_decoder.js', 'draco', options);
      break;

    case 'wasm':
    default:
      [DracoDecoderModule, wasmBinary] = await Promise.all([
        await Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["loadLibrary"])('draco_wasm_wrapper.js', 'draco', options),
        await Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["loadLibrary"])('draco_decoder.wasm', 'draco', options)
      ]);
  }
  // Depends on how import happened...
  // @ts-ignore
  DracoDecoderModule = DracoDecoderModule || _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["global"].DracoDecoderModule;
  return await initializeDracoDecoder(DracoDecoderModule, wasmBinary);
}

function initializeDracoDecoder(DracoDecoderModule, wasmBinary) {
  const options = {};
  if (wasmBinary) {
    options.wasmBinary = wasmBinary;
  }

  return new Promise(resolve => {
    DracoDecoderModule({
      ...options,
      onModuleLoaded: draco => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}

// ENCODER

async function loadDracoEncoder(options) {
  let DracoEncoderModule = await Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["loadLibrary"])('draco_encoder.js', 'draco', options);
  // @ts-ignore
  DracoEncoderModule = DracoEncoderModule || _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["global"].DracoEncoderModule;

  return new Promise(resolve => {
    DracoEncoderModule({
      onModuleLoaded: draco => resolve({draco}) // Module is Promise-like. Wrap in object to avoid loop.
    });
  });
}


/***/ }),

/***/ "../draco/src/lib/draco-parser.js":
/*!****************************************!*\
  !*** ../draco/src/lib/draco-parser.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DracoParser; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
// This code is inspired by example code in the DRACO repository
/** @typedef {import('../types/draco-types')} Draco3D */
/** @typedef {import('../types/draco-types').Decoder} Decoder */


const GEOMETRY_TYPE = {
  TRIANGULAR_MESH: 0,
  POINT_CLOUD: 1
};

// Native Draco attribute names to GLTF attribute names.
const DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP = {
  POSITION: 'POSITION',
  NORMAL: 'NORMAL',
  COLOR: 'COLOR_0',
  TEX_COORD: 'TEXCOORD_0'
};

const DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP = {
  1: Int8Array,
  2: Uint8Array,
  3: Int16Array,
  4: Uint16Array,
  5: Int32Array,
  6: Uint32Array,
  9: Float32Array
};

class DracoParser {
  // draco - the draco decoder, either import `draco3d` or load dynamically
  constructor(draco) {
    /** @type {Draco3D} */
    this.draco = draco;
    this.drawMode = 'TRIANGLE';
    this.metadataQuerier = {};
  }

  destroy() {}

  destroyGeometry(dracoGeometry) {
    if (dracoGeometry) {
      this.draco.destroy(dracoGeometry.dracoGeometry);
    }
  }

  // NOTE: caller must call `destroyGeometry` on the return value after using it
  parseSync(arrayBuffer, options = {}) {
    this.metadataQuerier = new this.draco.MetadataQuerier();
    const buffer = new this.draco.DecoderBuffer();
    buffer.Init(new Int8Array(arrayBuffer), arrayBuffer.byteLength);

    const decoder = new this.draco.Decoder();

    const data = {};
    let dracoStatus;
    let dracoGeometry;
    let header;

    try {
      const geometryType = decoder.GetEncodedGeometryType(buffer);
      switch (geometryType) {
        case this.draco.TRIANGULAR_MESH:
          dracoGeometry = new this.draco.Mesh();
          dracoStatus = decoder.DecodeBufferToMesh(buffer, dracoGeometry);
          header = {
            type: GEOMETRY_TYPE.TRIANGULAR_MESH,
            faceCount: dracoGeometry.num_faces(),
            attributeCount: dracoGeometry.num_attributes(),
            vertexCount: dracoGeometry.num_points()
          };
          break;

        case this.draco.POINT_CLOUD:
          dracoGeometry = new this.draco.PointCloud();
          dracoStatus = decoder.DecodeBufferToPointCloud(buffer, dracoGeometry);
          header = {
            type: GEOMETRY_TYPE.POINT_CLOUD,
            attributeCount: dracoGeometry.num_attributes(),
            vertexCount: dracoGeometry.num_points()
          };
          break;

        default:
          throw new Error('Unknown DRACO geometry type.');
      }

      // @ts-ignore .ptr
      if (!dracoStatus.ok() || !dracoGeometry.ptr) {
        const message = `DRACO decompression failed: ${dracoStatus.error_msg()}`;
        // console.error(message);
        if (dracoGeometry) {
          this.draco.destroy(dracoGeometry);
        }
        throw new Error(message);
      }

      data.loaderData = {header};

      this._extractDRACOGeometry(decoder, dracoGeometry, geometryType, data, options);
      const metadata = this._getGeometryMetadata(decoder, dracoGeometry);

      data.header = {
        vertexCount: header.vertexCount,
        boundingBox: Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["getMeshBoundingBox"])(data.attributes),
        metadata
      };
    } finally {
      this.draco.destroy(decoder);
      this.draco.destroy(buffer);
      this.draco.destroy(dracoGeometry);
      this.draco.destroy(this.metadataQuerier);
    }

    return data;
  }

  /**
   * @param {Decoder} decoder
   * @param {*} dracoGeometry
   * @param {*} geometryType
   * @param {*} geometry
   * @param {object} options
   */
  _extractDRACOGeometry(decoder, dracoGeometry, geometryType, geometry, options) {
    const attributes = this._getAttributes(decoder, dracoGeometry, options);

    const positionAttribute = attributes.POSITION;
    if (!positionAttribute) {
      throw new Error('DRACO decompressor: No position attribute found.');
    }

    // For meshes, we need indices to define the faces.
    if (geometryType === this.draco.TRIANGULAR_MESH) {
      attributes.indices =
        this.drawMode === 'TRIANGLE_STRIP'
          ? /**
             *
             * @param {*} decoder
             * @param {*} dracoGeometry
             */
            this._getMeshStripIndices(decoder, dracoGeometry)
          : this._getMeshFaceIndices(decoder, dracoGeometry);
      geometry.mode =
        this.drawMode === 'TRIANGLE_STRIP'
          ? 5 // GL.TRIANGLE_STRIP
          : 4; // GL.TRIANGLES
    } else {
      geometry.mode = 0; // GL.POINTS
    }

    if (attributes.indices) {
      geometry.indices = {value: attributes.indices, size: 1};
      delete attributes.indices;
    }
    geometry.attributes = attributes;

    return geometry;
  }

  getPositionAttributeMetadata(positionAttribute) {
    this.metadata = this.metadata || {};
    this.metadata.attributes = this.metadata.attributes || {};

    const posTransform = new this.draco.AttributeQuantizationTransform();
    if (posTransform.InitFromAttribute(positionAttribute)) {
      // Quantized attribute. Store the quantization parameters into the attribute
      this.metadata.attributes.position.isQuantized = true;
      this.metadata.attributes.position.maxRange = posTransform.range();
      this.metadata.attributes.position.numQuantizationBits = posTransform.quantization_bits();
      this.metadata.attributes.position.minValues = new Float32Array(3);
      for (let i = 0; i < 3; ++i) {
        this.metadata.attributes.position.minValues[i] = posTransform.min_value(i);
      }
    }
    this.draco.destroy(posTransform);
  }

  _getAttributes(decoder, dracoGeometry, options) {
    const attributes = {};
    const numPoints = dracoGeometry.num_points();
    // const attributeUniqueIdMap = {};

    // Note: Draco docs do not seem clear on `GetAttribute` accepting a zero-based index,
    // but it seems to work this way
    for (let attributeId = 0; attributeId < dracoGeometry.num_attributes(); attributeId++) {
      const dracoAttribute = decoder.GetAttribute(dracoGeometry, attributeId);
      const attributeMetadata = this._getAttributeMetadata(decoder, dracoGeometry, attributeId);
      const attributeData = {
        uniqueId: dracoAttribute.unique_id(),
        attributeType: dracoAttribute.attribute_type(),
        dataType: DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()],
        size: dracoAttribute.size(),
        numComponents: dracoAttribute.num_components(),
        byteOffset: dracoAttribute.byte_offset(),
        byteStride: dracoAttribute.byte_stride(),
        normalized: dracoAttribute.normalized(),
        metadata: attributeMetadata
      };

      // DRACO does not store attribute names - We need to deduce an attribute name
      const attributeName = this._deduceAttributeName(attributeData, options);

      const {typedArray} = this._getAttributeTypedArray(
        decoder,
        dracoGeometry,
        dracoAttribute,
        attributeName
      );
      attributes[attributeName] = {
        value: typedArray,
        size: typedArray.length / numPoints,
        metadata: attributeMetadata
      };
    }

    return attributes;
  }

  /**
   * For meshes, we need indices to define the faces.
   * @param {Decoder} decoder
   * @param {*} dracoGeometry
   */
  _getMeshFaceIndices(decoder, dracoGeometry) {
    // Example on how to retrieve mesh and attributes.
    const numFaces = dracoGeometry.num_faces();

    const numIndices = numFaces * 3;
    const indices = new Uint32Array(numIndices);
    const dracoArray = new this.draco.DracoInt32Array();
    for (let i = 0; i < numFaces; ++i) {
      decoder.GetFaceFromMesh(dracoGeometry, i, dracoArray);
      const index = i * 3;
      indices[index] = dracoArray.GetValue(0);
      indices[index + 1] = dracoArray.GetValue(1);
      indices[index + 2] = dracoArray.GetValue(2);
    }

    this.draco.destroy(dracoArray);
    return indices;
  }

  /**
   * For meshes, we need indices to define the faces.
   * @param {Decoder} decoder
   * @param {*} dracoGeometry
   */
  _getMeshStripIndices(decoder, dracoGeometry) {
    const dracoArray = new this.draco.DracoInt32Array();
    /* const numStrips = */ decoder.GetTriangleStripsFromMesh(dracoGeometry, dracoArray);
    const indices = new Uint32Array(dracoArray.size());
    for (let i = 0; i < dracoArray.size(); ++i) {
      indices[i] = dracoArray.GetValue(i);
    }
    this.draco.destroy(dracoArray);
    return indices;
  }

  /**
   *
   * @param {Decoder} decoder
   * @param {*} dracoGeometry
   * @param {*} dracoAttribute
   * @param {*} attributeName
   */
  _getAttributeTypedArray(decoder, dracoGeometry, dracoAttribute, attributeName) {
    if (dracoAttribute.ptr === 0) {
      const message = `DRACO decode bad attribute ${attributeName}`;
      // console.error(message);
      throw new Error(message);
    }

    const attributeType = DRACO_DATA_TYPE_TO_TYPED_ARRAY_MAP[dracoAttribute.data_type()];
    const numComponents = dracoAttribute.num_components();
    const numPoints = dracoGeometry.num_points();
    const numValues = numPoints * numComponents;

    let dracoArray;
    let typedArray;

    switch (attributeType) {
      case Float32Array:
        dracoArray = new this.draco.DracoFloat32Array();
        decoder.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
        typedArray = new Float32Array(numValues);
        break;

      case Int8Array:
        dracoArray = new this.draco.DracoInt8Array();
        decoder.GetAttributeInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
        typedArray = new Int8Array(numValues);
        break;

      case Int16Array:
        dracoArray = new this.draco.DracoInt16Array();
        decoder.GetAttributeInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
        typedArray = new Int16Array(numValues);
        break;

      case Int32Array:
        dracoArray = new this.draco.DracoInt32Array();
        decoder.GetAttributeInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
        typedArray = new Int32Array(numValues);
        break;

      case Uint8Array:
        dracoArray = new this.draco.DracoUInt8Array();
        decoder.GetAttributeUInt8ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
        typedArray = new Uint8Array(numValues);
        break;

      case Uint16Array:
        dracoArray = new this.draco.DracoUInt16Array();
        decoder.GetAttributeUInt16ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
        typedArray = new Uint16Array(numValues);
        break;

      case Uint32Array:
        dracoArray = new this.draco.DracoUInt32Array();
        decoder.GetAttributeUInt32ForAllPoints(dracoGeometry, dracoAttribute, dracoArray);
        typedArray = new Uint32Array(numValues);
        break;

      default:
        const errorMsg = 'DRACO decoder: unexpected attribute type.';
        // console.error(errorMsg);
        throw new Error(errorMsg);
    }

    // Copy data from decoder.
    for (let i = 0; i < numValues; i++) {
      typedArray[i] = dracoArray.GetValue(i);
    }

    this.draco.destroy(dracoArray);

    return {typedArray, components: numComponents};
  }

  /**
   * Deduce an attribute name.
   * @note DRACO does not save attribute names, just general type (POSITION, COLOR)
   * to help optimize compression. We generate GLTF compatible names for the Draco-recognized
   * types
   * @param {object} attributeData
   */
  _deduceAttributeName(attributeData, options) {
    const {extraAttributes = {}} = options;
    if (extraAttributes && typeof extraAttributes === 'object') {
      for (const [attributeName, attributeUniqueId] of Object.entries(extraAttributes)) {
        if (attributeUniqueId === attributeData.uniqueId) {
          return attributeName;
        }
      }
    }

    for (const dracoAttributeConstant in DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP) {
      const attributeType = this.draco[dracoAttributeConstant];
      if (attributeData.attributeType === attributeType) {
        // TODO - Return unique names if there multiple attributes per type
        // (e.g. multiple TEX_COORDS or COLORS)
        return DRACO_TO_GLTF_ATTRIBUTE_NAME_MAP[dracoAttributeConstant];
      }
    }

    if (attributeData.metadata) {
      const entryName = options.attributeNameEntry || 'name';
      if (attributeData.metadata[entryName]) {
        return attributeData.metadata[entryName].string;
      }
    }

    // Attribute of "GENERIC" type, we need to assign some name
    return `CUSTOM_ATTRIBUTE_${attributeData.uniqueId}`;
  }

  _getGeometryMetadata(decoder, dracoGeometry) {
    const dracoMetadata = decoder.GetMetadata(dracoGeometry);
    return this._queryDracoMetadata(dracoMetadata);
  }

  _getAttributeMetadata(decoder, dracoGeometry, attributeId) {
    const dracoMetadata = decoder.GetAttributeMetadata(dracoGeometry, attributeId);
    return this._queryDracoMetadata(dracoMetadata);
  }

  // The not so wonderful world of undocumented Draco APIs :(
  _queryDracoMetadata(dracoMetadata) {
    if (!dracoMetadata || !dracoMetadata.ptr) {
      return {};
    }
    const result = {};
    const numEntries = this.metadataQuerier.NumEntries(dracoMetadata);
    for (let entryIndex = 0; entryIndex < numEntries; entryIndex++) {
      const entryName = this.metadataQuerier.GetEntryName(dracoMetadata, entryIndex);
      result[entryName] = {
        int: this.metadataQuerier.GetIntEntry(dracoMetadata, entryName),
        string: this.metadataQuerier.GetStringEntry(dracoMetadata, entryName),
        double: this.metadataQuerier.GetDoubleEntry(dracoMetadata, entryName),
        intArray: this.metadataQuerier.GetIntEntryArray(dracoMetadata, entryName)
      };
    }
    return result;
  }

  // DEPRECATED

  decode(arrayBuffer, options) {
    return this.parseSync(arrayBuffer, options);
  }
}


/***/ }),

/***/ "../images/src/image-loader.js":
/*!*************************************!*\
  !*** ../images/src/image-loader.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parsers/parse-image */ "../images/src/lib/parsers/parse-image.js");
/* harmony import */ var _lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/category-api/binary-image-api */ "../images/src/lib/category-api/binary-image-api.js");


/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */

// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.1" : undefined;

const EXTENSIONS = ['png', 'jpg', 'jpeg', 'gif', 'webp', 'bmp', 'ico', 'svg'];
const MIME_TYPES = [
  'image/png',
  'image/jpeg',
  'image/gif',
  'image/webp',
  'image/bmp',
  'image/vnd.microsoft.icon',
  'image/svg+xml'
];

// Loads a platform-specific image type that can be used as input data to WebGL textures
/** @type {LoaderObject} */
const ImageLoader = {
  id: 'image',
  name: 'Images',
  version: VERSION,
  mimeTypes: MIME_TYPES,
  extensions: EXTENSIONS,
  parse: _lib_parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"],
  // TODO: byteOffset, byteLength;
  tests: [arrayBuffer => Boolean(Object(_lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_1__["getBinaryImageMetadata"])(new DataView(arrayBuffer)))],
  options: {
    image: {
      type: 'auto',
      decode: true // if format is HTML
    }
    // imagebitmap: {} - passes (platform dependent) parameters to ImageBitmap constructor
  }
};

/* harmony default export */ __webpack_exports__["default"] = (ImageLoader);


/***/ }),

/***/ "../images/src/image-writer.js":
/*!*************************************!*\
  !*** ../images/src/image-writer.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_encoders_encode_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encoders/encode-image */ "../images/src/lib/encoders/encode-image.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'Images',
  extensions: ['jpeg'],
  options: {
    image: {
      mimeType: 'image/png',
      jpegQuality: null
    }
  },
  encode: _lib_encoders_encode_image__WEBPACK_IMPORTED_MODULE_0__["encodeImage"]
});


/***/ }),

/***/ "../images/src/index.js":
/*!******************************!*\
  !*** ../images/src/index.js ***!
  \******************************/
/*! exports provided: ImageLoader, ImageWriter, getBinaryImageMetadata, isImageTypeSupported, getDefaultImageType, isImage, getImageType, getImageSize, getImageData, loadImage, loadImageArray, loadImageCube, HTMLImageLoader, getSupportedImageType, isBinaryImage, getBinaryImageMIMEType, getBinaryImageSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSupportedImageType", function() { return getSupportedImageType; });
/* harmony import */ var _image_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-loader */ "../images/src/image-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _image_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./image-writer */ "../images/src/image-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageWriter", function() { return _image_writer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/category-api/binary-image-api */ "../images/src/lib/category-api/binary-image-api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageMetadata", function() { return _lib_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__["getBinaryImageMetadata"]; });

/* harmony import */ var _lib_category_api_image_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/category-api/image-type */ "../images/src/lib/category-api/image-type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isImageTypeSupported", function() { return _lib_category_api_image_type__WEBPACK_IMPORTED_MODULE_3__["isImageTypeSupported"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultImageType", function() { return _lib_category_api_image_type__WEBPACK_IMPORTED_MODULE_3__["getDefaultImageType"]; });

/* harmony import */ var _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/category-api/parsed-image-api */ "../images/src/lib/category-api/parsed-image-api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__["isImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageType", function() { return _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__["getImageType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__["getImageSize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageData", function() { return _lib_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_4__["getImageData"]; });

/* harmony import */ var _lib_texture_api_load_image__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/texture-api/load-image */ "../images/src/lib/texture-api/load-image.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _lib_texture_api_load_image__WEBPACK_IMPORTED_MODULE_5__["loadImage"]; });

/* harmony import */ var _lib_texture_api_load_image_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/texture-api/load-image-array */ "../images/src/lib/texture-api/load-image-array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return _lib_texture_api_load_image_array__WEBPACK_IMPORTED_MODULE_6__["loadImageArray"]; });

/* harmony import */ var _lib_texture_api_load_image_cube__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/texture-api/load-image-cube */ "../images/src/lib/texture-api/load-image-cube.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImageCube", function() { return _lib_texture_api_load_image_cube__WEBPACK_IMPORTED_MODULE_7__["loadImageCube"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HTMLImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_deprecated_binary_image_api_deprecated__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/deprecated/binary-image-api-deprecated */ "../images/src/lib/deprecated/binary-image-api-deprecated.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBinaryImage", function() { return _lib_deprecated_binary_image_api_deprecated__WEBPACK_IMPORTED_MODULE_8__["isBinaryImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageMIMEType", function() { return _lib_deprecated_binary_image_api_deprecated__WEBPACK_IMPORTED_MODULE_8__["getBinaryImageMIMEType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageSize", function() { return _lib_deprecated_binary_image_api_deprecated__WEBPACK_IMPORTED_MODULE_8__["getBinaryImageSize"]; });




// IMAGE CATEGORY API

// Binary Image API


// Parsed Image API




// Texture Loading API




// DEPRECATED
// TODO - Remove in V3





function getSupportedImageType(imageType = null) {
  return Object(_lib_category_api_image_type__WEBPACK_IMPORTED_MODULE_3__["getDefaultImageType"])();
}




/***/ }),

/***/ "../images/src/lib/category-api/binary-image-api.js":
/*!**********************************************************!*\
  !*** ../images/src/lib/category-api/binary-image-api.js ***!
  \**********************************************************/
/*! exports provided: getBinaryImageMetadata, getBmpMetadata */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageMetadata", function() { return getBinaryImageMetadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBmpMetadata", function() { return getBmpMetadata; });
// Attributions
// * Based on binary-gltf-utils under MIT license: Copyright (c) 2016-17 Karl Cheng

// TODO: make these functions work for Node.js buffers?
// Quarantine references to Buffer to prevent bundler from adding big polyfills
// import {bufferToArrayBuffer} from '../node/buffer-to-array-buffer';
// TODO - this should be handled in @loaders.gl/polyfills

const BIG_ENDIAN = false;
const LITTLE_ENDIAN = true;

function getBinaryImageMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  return (
    getPngMetadata(dataView) ||
    getJpegMetadata(dataView) ||
    getGifMetadata(dataView) ||
    getBmpMetadata(dataView)
  );
}

// PNG

function getPngMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  // Check file contains the first 4 bytes of the PNG signature.
  const isPng = dataView.byteLength >= 24 && dataView.getUint32(0, BIG_ENDIAN) === 0x89504e47;
  if (!isPng) {
    return null;
  }

  // Extract size from a binary PNG file
  return {
    mimeType: 'image/png',
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}

// GIF

// Extract size from a binary GIF file
// TODO: GIF is not this simple
function getGifMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  // Check first 4 bytes of the GIF signature ("GIF8").
  const isGif = dataView.byteLength >= 10 && dataView.getUint32(0, BIG_ENDIAN) === 0x47494638;
  if (!isGif) {
    return null;
  }

  // GIF is little endian.
  return {
    mimeType: 'image/gif',
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}

// BMP

// TODO: BMP is not this simple
function getBmpMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  // Check magic number is valid (first 2 characters should be "BM").
  // The mandatory bitmap file header is 14 bytes long.
  const isBmp =
    dataView.byteLength >= 14 &&
    dataView.getUint16(0, BIG_ENDIAN) === 0x424d &&
    dataView.getUint32(2, LITTLE_ENDIAN) === dataView.byteLength;

  if (!isBmp) {
    return null;
  }

  // BMP is little endian.
  return {
    mimeType: 'image/bmp',
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}

// JPEG

// Extract width and height from a binary JPEG file
function getJpegMetadata(binaryData) {
  const dataView = toDataView(binaryData);
  // Check file contains the JPEG "start of image" (SOI) marker
  // followed by another marker.
  const isJpeg =
    dataView.byteLength >= 3 &&
    dataView.getUint16(0, BIG_ENDIAN) === 0xffd8 &&
    dataView.getUint8(2) === 0xff;

  if (!isJpeg) {
    return null;
  }

  const {tableMarkers, sofMarkers} = getJpegMarkers();

  // Exclude the two byte SOI marker.
  let i = 2;
  while (i + 9 < dataView.byteLength) {
    const marker = dataView.getUint16(i, BIG_ENDIAN);

    // The frame that contains the width and height of the JPEG image.
    if (sofMarkers.has(marker)) {
      return {
        mimeType: 'image/jpeg',
        height: dataView.getUint16(i + 5, BIG_ENDIAN), // Number of lines
        width: dataView.getUint16(i + 7, BIG_ENDIAN) // Number of pixels per line
      };
    }

    // Miscellaneous tables/data preceding the frame header.
    if (!tableMarkers.has(marker)) {
      return null;
    }

    // Length includes size of length parameter but not the two byte header.
    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }

  return null;
}

function getJpegMarkers() {
  // Tables/misc header markers.
  // DQT, DHT, DAC, DRI, COM, APP_n
  const tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);
  for (let i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }

  // SOF markers and DHP marker.
  // These markers are after tables/misc data.
  const sofMarkers = new Set([
    0xffc0,
    0xffc1,
    0xffc2,
    0xffc3,
    0xffc5,
    0xffc6,
    0xffc7,
    0xffc9,
    0xffca,
    0xffcb,
    0xffcd,
    0xffce,
    0xffcf,
    0xffde
  ]);

  return {tableMarkers, sofMarkers};
}

// TODO - move into image module?
function toDataView(data) {
  if (data instanceof DataView) {
    return data;
  }
  if (ArrayBuffer.isView(data)) {
    return new DataView(data.buffer);
  }

  // TODO: make these functions work for Node.js buffers?
  // if (bufferToArrayBuffer) {
  //   data = bufferToArrayBuffer(data);
  // }

  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
  if (data instanceof ArrayBuffer) {
    return new DataView(data);
  }
  throw new Error('toDataView');
}


/***/ }),

/***/ "../images/src/lib/category-api/image-type.js":
/*!****************************************************!*\
  !*** ../images/src/lib/category-api/image-type.js ***!
  \****************************************************/
/*! exports provided: isImageTypeSupported, getDefaultImageType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImageTypeSupported", function() { return isImageTypeSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultImageType", function() { return getDefaultImageType; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../images/src/lib/utils/globals.js");
/* global ImageBitmap, Image */


// @ts-ignore TS2339: Property does not exist on type
const {_parseImageNode} = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"];

const IMAGE_SUPPORTED = typeof Image !== 'undefined'; // NOTE: "false" positives if jsdom is installed
const IMAGE_BITMAP_SUPPORTED = typeof ImageBitmap !== 'undefined';
const NODE_IMAGE_SUPPORTED = Boolean(_parseImageNode);
const DATA_SUPPORTED = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] ? true : NODE_IMAGE_SUPPORTED;

// Checks if a loaders.gl image type is supported
function isImageTypeSupported(type) {
  switch (type) {
    case 'auto':
      // Should only ever be false in Node.js, if polyfills have not been installed...
      return IMAGE_BITMAP_SUPPORTED || IMAGE_SUPPORTED || DATA_SUPPORTED;

    case 'imagebitmap':
      return IMAGE_BITMAP_SUPPORTED;
    case 'image':
      return IMAGE_SUPPORTED;
    case 'data':
      return DATA_SUPPORTED;

    // DEPRECATED types
    case 'html':
      return IMAGE_SUPPORTED;
    case 'ndarray':
      return DATA_SUPPORTED;

    default:
      throw new Error(`@loaders.gl/images: image ${type} not supported in this environment`);
  }
}

// Returns the best loaders.gl image type supported on current run-time environment
function getDefaultImageType() {
  if (IMAGE_BITMAP_SUPPORTED) {
    return 'imagebitmap';
  }
  if (IMAGE_SUPPORTED) {
    return 'image';
  }
  if (DATA_SUPPORTED) {
    return 'data';
  }

  // This should only happen in Node.js
  throw new Error(`Install '@loaders.gl/polyfills' to parse images under Node.js`);
}


/***/ }),

/***/ "../images/src/lib/category-api/parsed-image-api.js":
/*!**********************************************************!*\
  !*** ../images/src/lib/category-api/parsed-image-api.js ***!
  \**********************************************************/
/*! exports provided: isImage, deleteImage, getImageType, getImageData, getImageSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return isImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deleteImage", function() { return deleteImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageType", function() { return getImageType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageData", function() { return getImageData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return getImageData; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../images/src/lib/utils/assert.js");
/* global Image, ImageBitmap */


function isImage(image) {
  return Boolean(getImageTypeOrNull(image));
}

function deleteImage(image) {
  switch (getImageType(image)) {
    case 'imagebitmap':
      image.close();
      break;
    default:
    // Nothing to do for images and image data objects
  }
}

function getImageType(image) {
  const format = getImageTypeOrNull(image);
  if (!format) {
    throw new Error('Not an image');
  }
  return format;
}

function getImageData(image) {
  switch (getImageType(image)) {
    case 'data':
      return image;

    case 'image':
    case 'imagebitmap':
      // Extract the image data from the image via a canvas
      /* global document */
      const canvas = document.createElement('canvas');
      // TODO - reuse the canvas?
      const context = canvas.getContext('2d');
      if (context) {
        canvas.width = image.width;
        canvas.height = image.height;
        context.drawImage(image, 0, 0);
        return context.getImageData(0, 0, image.width, image.height);
      }
    // eslint-disable no-fallthrough
    default:
      return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
  }
}

// TODO DEPRECATED not needed (use getImageData)


// PRIVATE

// eslint-disable-next-line complexity
function getImageTypeOrNull(image) {
  if (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    return 'imagebitmap';
  }
  if (typeof Image !== 'undefined' && image instanceof Image) {
    return 'image';
  }
  if (image && typeof image === 'object' && image.data && image.width && image.height) {
    return 'data';
  }
  return null;
}


/***/ }),

/***/ "../images/src/lib/deprecated/binary-image-api-deprecated.js":
/*!*******************************************************************!*\
  !*** ../images/src/lib/deprecated/binary-image-api-deprecated.js ***!
  \*******************************************************************/
/*! exports provided: isBinaryImage, getBinaryImageMIMEType, getBinaryImageSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBinaryImage", function() { return isBinaryImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageMIMEType", function() { return getBinaryImageMIMEType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBinaryImageSize", function() { return getBinaryImageSize; });
/* harmony import */ var _category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../category-api/binary-image-api */ "../images/src/lib/category-api/binary-image-api.js");


// Supported image types are PNG, JPEG, GIF and BMP.
function isBinaryImage(arrayBuffer, mimeType) {
  const metadata = Object(_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_0__["getBinaryImageMetadata"])(arrayBuffer);
  if (mimeType) {
    return Boolean(metadata && metadata.mimeType === mimeType);
  }
  // return true if any known type
  return Boolean(metadata);
}

// Sniffs the contents of a file to attempt to deduce the image type
function getBinaryImageMIMEType(arrayBuffer) {
  const metadata = Object(_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_0__["getBinaryImageMetadata"])(arrayBuffer);
  return metadata ? metadata.mimeType : null;
}

function getBinaryImageSize(arrayBuffer, mimeType = null) {
  const metadata = Object(_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_0__["getBinaryImageMetadata"])(arrayBuffer);

  if (metadata) {
    return {
      width: metadata.width,
      height: metadata.height
    };
  }

  mimeType = mimeType || 'unknown';
  throw new Error(`invalid image data for type: ${mimeType}`);
}


/***/ }),

/***/ "../images/src/lib/encoders/encode-image.js":
/*!**************************************************!*\
  !*** ../images/src/lib/encoders/encode-image.js ***!
  \**************************************************/
/*! exports provided: encodeImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeImage", function() { return encodeImage; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../images/src/lib/utils/globals.js");
/* harmony import */ var _category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../category-api/parsed-image-api */ "../images/src/lib/category-api/parsed-image-api.js");
// Image loading/saving for browser and Node.js
/* global document, ImageBitmap, ImageData */



// @ts-ignore TS2339: Property does not exist on type
const {_encodeImageNode} = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"];

async function encodeImage(image, options) {
  options = options || {};
  options.image = options.image || {};

  return _encodeImageNode
    ? _encodeImageNode(image, {type: options.image.mimeType})
    : encodeImageInBrowser(image, options);
}

// In case we get exceptions from canvas.toBlob(resolve, type, quality)
let qualityParamSupported = true;

/**
 *
 * @param image
 * @param options
 * @note Based on canvas.toBlob
 * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob
 */
async function encodeImageInBrowser(image, options) {
  const {mimeType, jpegQuality} = options.image;

  const {width, height} = Object(_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_1__["getImageSize"])(image);

  // create a canvas and resize it to the size of our image
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;

  drawImageToCanvas(image, canvas);

  // The actual encoding is done asynchronously with `canvas.toBlob()`
  const blob = await new Promise((resolve, reject) => {
    // get it back as a Blob
    if (jpegQuality && qualityParamSupported) {
      try {
        canvas.toBlob(resolve, mimeType, jpegQuality);
        return;
      } catch (error) {
        qualityParamSupported = false;
      }
    }
    canvas.toBlob(resolve, mimeType);
  });

  return await blob.arrayBuffer();
}

function drawImageToCanvas(image, canvas, x = 0, y = 0) {
  // Try optimized path for ImageBitmaps via bitmaprenderer context
  if (x === 0 && y === 0 && typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
    const context = canvas.getContext('bitmaprenderer');
    if (context) {
      // transfer the ImageBitmap to it
      context.transferFromImageBitmap(image);
      return canvas;
    }
  }

  // Available on most platforms, except IE11 and Andriod WebViews...
  const context = canvas.getContext('2d');
  if (image.data) {
    // ImageData constructor expects clamped array even though getImageData does not return a clamped array...
    const clampedArray = new Uint8ClampedArray(image.data);
    const imageData = new ImageData(clampedArray, image.width, image.height);
    context.putImageData(imageData, 0, 0);
    return canvas;
  }

  // Fall back to generic image/image bitmap rendering path
  context.drawImage(image, 0, 0);
  return canvas;
}


/***/ }),

/***/ "../images/src/lib/parsers/parse-image.js":
/*!************************************************!*\
  !*** ../images/src/lib/parsers/parse-image.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseImage; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../images/src/lib/utils/assert.js");
/* harmony import */ var _category_api_image_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../category-api/image-type */ "../images/src/lib/category-api/image-type.js");
/* harmony import */ var _category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../category-api/parsed-image-api */ "../images/src/lib/category-api/parsed-image-api.js");
/* harmony import */ var _parse_to_image__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parse-to-image */ "../images/src/lib/parsers/parse-to-image.js");
/* harmony import */ var _parse_to_image_bitmap__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse-to-image-bitmap */ "../images/src/lib/parsers/parse-to-image-bitmap.js");
/* harmony import */ var _parse_to_node_image__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse-to-node-image */ "../images/src/lib/parsers/parse-to-node-image.js");







// Parse to platform defined image type (data on node, ImageBitmap or HTMLImage on browser)
// eslint-disable-next-line complexity
async function parseImage(arrayBuffer, options, context) {
  options = options || {};
  const imageOptions = options.image || {};

  // The user can request a specific output format via `options.image.type`
  const imageType = imageOptions.type || 'auto';

  const {url} = context || {};

  // Note: For options.image.type === `data`, we may still need to load as `image` or `imagebitmap`
  const loadType = getLoadableImageType(imageType);

  let image;
  switch (loadType) {
    case 'imagebitmap':
      image = await Object(_parse_to_image_bitmap__WEBPACK_IMPORTED_MODULE_4__["default"])(arrayBuffer, options, url);
      break;
    case 'image':
      image = await Object(_parse_to_image__WEBPACK_IMPORTED_MODULE_3__["default"])(arrayBuffer, options, url);
      break;
    case 'data':
      // Node.js loads imagedata directly
      image = await Object(_parse_to_node_image__WEBPACK_IMPORTED_MODULE_5__["default"])(arrayBuffer, options);
      break;
    default:
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
  }

  // Browser: if options.image.type === 'data', we can now extract data from the loaded image
  if (imageType === 'data') {
    image = Object(_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__["getImageData"])(image);
  }

  return image;
}

// Get a loadable image type from image type
function getLoadableImageType(type) {
  switch (type) {
    case 'auto':
    case 'data':
      // Browser: For image data we need still need to load using an image format
      // Node: the default image type is `data`.
      return Object(_category_api_image_type__WEBPACK_IMPORTED_MODULE_1__["getDefaultImageType"])();
    default:
      // Throw an error if not supported
      Object(_category_api_image_type__WEBPACK_IMPORTED_MODULE_1__["isImageTypeSupported"])(type);
      return type;
  }
}


/***/ }),

/***/ "../images/src/lib/parsers/parse-to-image-bitmap.js":
/*!**********************************************************!*\
  !*** ../images/src/lib/parsers/parse-to-image-bitmap.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseToImageBitmap; });
/* harmony import */ var _svg_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svg-utils */ "../images/src/lib/parsers/svg-utils.js");
/* harmony import */ var _parse_to_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse-to-image */ "../images/src/lib/parsers/parse-to-image.js");
/* global createImageBitmap */



const EMPTY_OBJECT = {};

let imagebitmapOptionsSupported = true;

/**
 * Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data
 * ImageBitmaps are supported on worker threads, but not supported on Edge, IE11 and Safari
 * https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility
 *
 * TODO - createImageBitmap supports source rect (5 param overload), pass through?
 */
async function parseToImageBitmap(arrayBuffer, options, url) {
  let blob;

  // Cannot parse SVG directly to ImageBitmap, parse to Image first
  if (Object(_svg_utils__WEBPACK_IMPORTED_MODULE_0__["isSVG"])(url)) {
    // Note: this only works on main thread
    const image = await Object(_parse_to_image__WEBPACK_IMPORTED_MODULE_1__["default"])(arrayBuffer, options, url);
    blob = image;
  } else {
    // Create blob from the array buffer
    blob = Object(_svg_utils__WEBPACK_IMPORTED_MODULE_0__["getBlob"])(arrayBuffer, url);
  }

  const imagebitmapOptions = options && options.imagebitmap;

  return await safeCreateImageBitmap(blob, imagebitmapOptions);
}

/**
 * Safely creates an imageBitmap with options
 * *
 * Firefox crashes if imagebitmapOptions is supplied
 * Avoid supplying if not provided or supported, remember if not supported
 */
async function safeCreateImageBitmap(blob, imagebitmapOptions = null) {
  if (isEmptyObject(imagebitmapOptions) || !imagebitmapOptionsSupported) {
    imagebitmapOptions = null;
  }

  if (imagebitmapOptions) {
    try {
      // @ts-ignore Options
      return await createImageBitmap(blob, imagebitmapOptions);
    } catch (error) {
      console.warn(error); // eslint-disable-line
      imagebitmapOptionsSupported = false;
    }
  }

  return await createImageBitmap(blob);
}

function isEmptyObject(object) {
  for (const key in object || EMPTY_OBJECT) {
    return false;
  }
  return true;
}


/***/ }),

/***/ "../images/src/lib/parsers/parse-to-image.js":
/*!***************************************************!*\
  !*** ../images/src/lib/parsers/parse-to-image.js ***!
  \***************************************************/
/*! exports provided: default, loadToImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseToImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadToImage", function() { return loadToImage; });
/* harmony import */ var _svg_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./svg-utils */ "../images/src/lib/parsers/svg-utils.js");
/* global self, Image */


// Parses html image from array buffer
async function parseToImage(arrayBuffer, options, url) {
  // Note: image parsing requires conversion to Blob (for createObjectURL).
  // Potentially inefficient for not using `response.blob()` (and for File / Blob inputs)...
  // But presumably not worth adding 'blob' flag to loader objects?

  const blobOrDataUrl = Object(_svg_utils__WEBPACK_IMPORTED_MODULE_0__["getBlobOrSVGDataUrl"])(arrayBuffer, url);
  const URL = self.URL || self.webkitURL;
  const objectUrl = typeof blobOrDataUrl !== 'string' && URL.createObjectURL(blobOrDataUrl);
  try {
    return await loadToImage(objectUrl || blobOrDataUrl, options);
  } finally {
    if (objectUrl) {
      URL.revokeObjectURL(objectUrl);
    }
  }
}

async function loadToImage(url, options) {
  const image = new Image();
  image.src = url;

  // The `image.onload()` callback does not guarantee that the image has been decoded
  // so a main thread "freeze" can be incurred when using the image for the first time.
  // `Image.decode()` returns a promise that completes when image is decoded.

  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/decode
  // Note: When calling `img.decode()`, we do not need to wait for `img.onload()`
  // Note: `HTMLImageElement.decode()` is not available in Edge and IE11
  if (options.image && options.image.decode && image.decode) {
    await image.decode();
    return image;
  }

  // Create a promise that tracks onload/onerror callbacks
  return await new Promise((resolve, reject) => {
    try {
      image.onload = () => resolve(image);
      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));
    } catch (error) {
      reject(error);
    }
  });
}


/***/ }),

/***/ "../images/src/lib/parsers/parse-to-node-image.js":
/*!********************************************************!*\
  !*** ../images/src/lib/parsers/parse-to-node-image.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseToNodeImage; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../images/src/lib/utils/globals.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "../images/src/lib/utils/assert.js");
/* harmony import */ var _category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../category-api/binary-image-api */ "../images/src/lib/category-api/binary-image-api.js");




// Use polyfills if installed to p[arsed image using get-pixels
function parseToNodeImage(arrayBuffer, options) {
  const {mimeType} = Object(_category_api_binary_image_api__WEBPACK_IMPORTED_MODULE_2__["getBinaryImageMetadata"])(arrayBuffer) || {};

  // @ts-ignore
  const {_parseImageNode} = _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"];
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(_parseImageNode); // '@loaders.gl/polyfills not installed'

  return _parseImageNode(arrayBuffer, mimeType, options);
}


/***/ }),

/***/ "../images/src/lib/parsers/svg-utils.js":
/*!**********************************************!*\
  !*** ../images/src/lib/parsers/svg-utils.js ***!
  \**********************************************/
/*! exports provided: isSVG, getBlobOrSVGDataUrl, getBlob */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSVG", function() { return isSVG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlobOrSVGDataUrl", function() { return getBlobOrSVGDataUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBlob", function() { return getBlob; });
/* global TextDecoder, Blob, btoa */
// SVG parsing has limitations, e.g:
// https://bugs.chromium.org/p/chromium/issues/detail?id=606319

const SVG_DATA_URL_PATTERN = /^data:image\/svg\+xml/;
const SVG_URL_PATTERN = /\.svg((\?|#).*)?$/;

function isSVG(url) {
  return url && (SVG_DATA_URL_PATTERN.test(url) || SVG_URL_PATTERN.test(url));
}

function getBlobOrSVGDataUrl(arrayBuffer, url) {
  if (isSVG(url)) {
    // Prepare a properly tagged data URL, and load using normal mechanism
    const textDecoder = new TextDecoder();
    const xmlText = textDecoder.decode(arrayBuffer);
    // TODO Escape in browser to support e.g. Chinese characters
    // if (typeof unescape === 'function' && typeof encodeURLComponent === 'function') {
    //   xmlText = unescape(encodeURLComponent(xmlText));
    // }
    // base64 encoding is safer. utf-8 fails in some browsers
    const src = `data:image/svg+xml;base64,${btoa(xmlText)}`;
    return src;
  }
  return getBlob(arrayBuffer, url);
}

function getBlob(arrayBuffer, url) {
  if (isSVG(url)) {
    // https://bugs.chromium.org/p/chromium/issues/detail?id=606319
    // return new Blob([new Uint8Array(arrayBuffer)], {type: 'image/svg+xml'});
    throw new Error('SVG cannot be parsed directly to imagebitmap');
  }
  // TODO - how to determine mime type? Param? Sniff here?
  return new Blob([new Uint8Array(arrayBuffer)]); // MIME type not needed?
}


/***/ }),

/***/ "../images/src/lib/texture-api/async-deep-map.js":
/*!*******************************************************!*\
  !*** ../images/src/lib/texture-api/async-deep-map.js ***!
  \*******************************************************/
/*! exports provided: asyncDeepMap, mapSubtree */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asyncDeepMap", function() { return asyncDeepMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapSubtree", function() { return mapSubtree; });
/*
Asynchronously maps a deep structure of values (e.g. objects and arrays of urls).

E.g. a mipmapped cubemap
{
  [CUBE_FACE_FRONT]: [
    "image-front-0.jpg",
    "image-front-1.jpg",
    "image-front-2.jpg",
  ],
  [CUBE_MAP_BACK]: [
    ...
  ]
}
*/

const isObject = value => value && typeof value === 'object';

// Loads a deep structure of urls (objects and arrays of urls)
// Returns an object with six key-value pairs containing the images (or image mip arrays)
// for each cube face
async function asyncDeepMap(tree, func, options = {}) {
  return await mapSubtree(tree, func, options);
}

async function mapSubtree(object, func, options) {
  if (Array.isArray(object)) {
    return await mapArray(object, func, options);
  }

  if (isObject(object)) {
    return await mapObject(object, func, options);
  }

  // TODO - ignore non-urls, non-arraybuffers?
  const url = object;
  return await func(url, options);
}

// HELPERS

async function mapObject(object, func, options) {
  const promises = [];
  const values = {};

  for (const key in object) {
    const url = object[key];
    const promise = mapSubtree(url, func, options).then(value => {
      values[key] = value;
    });
    promises.push(promise);
  }

  await Promise.all(promises);

  return values;
}

async function mapArray(urlArray, func, options = {}) {
  const promises = urlArray.map(url => mapSubtree(url, func, options));
  return await Promise.all(promises);
}


/***/ }),

/***/ "../images/src/lib/texture-api/deep-load.js":
/*!**************************************************!*\
  !*** ../images/src/lib/texture-api/deep-load.js ***!
  \**************************************************/
/*! exports provided: deepLoad, shallowLoad */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepLoad", function() { return deepLoad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shallowLoad", function() { return shallowLoad; });
/* harmony import */ var _async_deep_map__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./async-deep-map */ "../images/src/lib/texture-api/async-deep-map.js");
/* global fetch */


async function deepLoad(urlTree, load, options) {
  return await Object(_async_deep_map__WEBPACK_IMPORTED_MODULE_0__["asyncDeepMap"])(urlTree, url => shallowLoad(url, load, options));
}

async function shallowLoad(url, load, options) {
  // console.error('loading', url);
  const response = await fetch(url, options.fetch);
  const arrayBuffer = await response.arrayBuffer();
  return await load(arrayBuffer, options);
}


/***/ }),

/***/ "../images/src/lib/texture-api/generate-url.js":
/*!*****************************************************!*\
  !*** ../images/src/lib/texture-api/generate-url.js ***!
  \*****************************************************/
/*! exports provided: generateUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateUrl", function() { return generateUrl; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/assert */ "../images/src/lib/utils/assert.js");



// Generate a url by calling getUrl with mix of options, applying options.baseUrl
function generateUrl(getUrl, options, urlOptions) {
  // Get url
  let url = getUrl;
  if (typeof getUrl === 'function') {
    url = getUrl({...options, ...urlOptions});
  }
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(typeof url === 'string');

  // Apply options.baseUrl
  const {baseUrl} = options;
  if (baseUrl) {
    url = baseUrl[baseUrl.length - 1] === '/' ? `${baseUrl}${url}` : `${baseUrl}/${url}`;
  }

  return Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["resolvePath"])(url);
}


/***/ }),

/***/ "../images/src/lib/texture-api/load-image-array.js":
/*!*********************************************************!*\
  !*** ../images/src/lib/texture-api/load-image-array.js ***!
  \*********************************************************/
/*! exports provided: loadImageArray, getImageArrayUrls */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImageArray", function() { return loadImageArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageArrayUrls", function() { return getImageArrayUrls; });
/* harmony import */ var _parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parsers/parse-image */ "../images/src/lib/parsers/parse-image.js");
/* harmony import */ var _load_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load-image */ "../images/src/lib/texture-api/load-image.js");
/* harmony import */ var _deep_load__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deep-load */ "../images/src/lib/texture-api/deep-load.js");




async function loadImageArray(count, getUrl, options = {}) {
  const imageUrls = await getImageArrayUrls(count, getUrl, options);
  return await Object(_deep_load__WEBPACK_IMPORTED_MODULE_2__["deepLoad"])(imageUrls, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"], options);
}

async function getImageArrayUrls(count, getUrl, options = {}) {
  const promises = [];
  for (let index = 0; index < count; index++) {
    const promise = Object(_load_image__WEBPACK_IMPORTED_MODULE_1__["getImageUrls"])(getUrl, options, {index});
    promises.push(promise);
  }
  return await Promise.all(promises);
}


/***/ }),

/***/ "../images/src/lib/texture-api/load-image-cube.js":
/*!********************************************************!*\
  !*** ../images/src/lib/texture-api/load-image-cube.js ***!
  \********************************************************/
/*! exports provided: getImageCubeUrls, loadImageCube */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageCubeUrls", function() { return getImageCubeUrls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImageCube", function() { return loadImageCube; });
/* harmony import */ var _parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parsers/parse-image */ "../images/src/lib/parsers/parse-image.js");
/* harmony import */ var _load_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load-image */ "../images/src/lib/texture-api/load-image.js");
/* harmony import */ var _deep_load__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./deep-load */ "../images/src/lib/texture-api/deep-load.js");




// Returned map will be have keys corresponding to GL cubemap constants
const GL_TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
const GL_TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
const GL_TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;

const CUBE_FACES = [
  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_X, direction: 'right', axis: 'x', sign: 'positive'},
  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_X, direction: 'left', axis: 'x', sign: 'negative'},
  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Y, direction: 'top', axis: 'y', sign: 'positive'},
  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, direction: 'bottom', axis: 'y', sign: 'negative'},
  {face: GL_TEXTURE_CUBE_MAP_POSITIVE_Z, direction: 'front', axis: 'z', sign: 'positive'},
  {face: GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, direction: 'back', axis: 'z', sign: 'negative'}
];

// Returns an object with six key-value pairs containing the urls (or url mip arrays)
// for each cube face
async function getImageCubeUrls(getUrl, options) {
  // Calculate URLs
  const urls = {};
  const promises = [];

  let index = 0;
  for (const face in CUBE_FACES) {
    const faceValues = CUBE_FACES[index];
    const promise = Object(_load_image__WEBPACK_IMPORTED_MODULE_1__["getImageUrls"])(getUrl, options, {...faceValues, index: index++}).then(url => {
      urls[face] = url;
    });
    promises.push(promise);
  }

  await Promise.all(promises);

  return urls;
}

// Returns an object with six key-value pairs containing the images (or image mip arrays)
// for each cube face
async function loadImageCube(getUrl, options = {}) {
  const urls = await getImageCubeUrls(getUrl, options);
  return await Object(_deep_load__WEBPACK_IMPORTED_MODULE_2__["deepLoad"])(urls, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_0__["default"], options);
}


/***/ }),

/***/ "../images/src/lib/texture-api/load-image.js":
/*!***************************************************!*\
  !*** ../images/src/lib/texture-api/load-image.js ***!
  \***************************************************/
/*! exports provided: loadImage, getImageUrls, getMipLevels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageUrls", function() { return getImageUrls; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMipLevels", function() { return getMipLevels; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../images/src/lib/utils/assert.js");
/* harmony import */ var _parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parsers/parse-image */ "../images/src/lib/parsers/parse-image.js");
/* harmony import */ var _category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../category-api/parsed-image-api */ "../images/src/lib/category-api/parsed-image-api.js");
/* harmony import */ var _generate_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generate-url */ "../images/src/lib/texture-api/generate-url.js");
/* harmony import */ var _deep_load__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./deep-load */ "../images/src/lib/texture-api/deep-load.js");






async function loadImage(getUrl, options = {}) {
  const imageUrls = await getImageUrls(getUrl, options);
  return await Object(_deep_load__WEBPACK_IMPORTED_MODULE_4__["deepLoad"])(imageUrls, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__["default"], options);
}

async function getImageUrls(getUrl, options, urlOptions = {}) {
  const mipLevels = (options && options.image && options.image.mipLevels) || 0;
  return mipLevels !== 0
    ? await getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions)
    : Object(_generate_url__WEBPACK_IMPORTED_MODULE_3__["generateUrl"])(getUrl, options, urlOptions);
}

async function getMipmappedImageUrls(getUrl, mipLevels, options, urlOptions) {
  const urls = [];

  // If no mip levels supplied, we need to load the level 0 image and calculate based on size
  if (mipLevels === 'auto') {
    const url = Object(_generate_url__WEBPACK_IMPORTED_MODULE_3__["generateUrl"])(getUrl, options, {...urlOptions, lod: 0});
    const image = await Object(_deep_load__WEBPACK_IMPORTED_MODULE_4__["shallowLoad"])(url, _parsers_parse_image__WEBPACK_IMPORTED_MODULE_1__["default"], options);

    const {width, height} = Object(_category_api_parsed_image_api__WEBPACK_IMPORTED_MODULE_2__["getImageSize"])(image);
    mipLevels = getMipLevels({width, height});

    // TODO - push image and make `deepLoad` pass through non-url values, avoid loading twice?
    urls.push(url);
  }

  // We now know how many mipLevels we need, remaining image urls can now be constructed
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(mipLevels > 0);

  for (let mipLevel = urls.length; mipLevel < mipLevels; ++mipLevel) {
    const url = Object(_generate_url__WEBPACK_IMPORTED_MODULE_3__["generateUrl"])(getUrl, options, {...urlOptions, lod: mipLevel});
    urls.push(url);
  }

  return urls;
}

// Calculates number of mipmaps based on texture size (log2)
function getMipLevels({width, height}) {
  return 1 + Math.floor(Math.log2(Math.max(width, height)));
}


/***/ }),

/***/ "../images/src/lib/utils/assert.js":
/*!*****************************************!*\
  !*** ../images/src/lib/utils/assert.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}


/***/ }),

/***/ "../images/src/lib/utils/globals.js":
/*!******************************************!*\
  !*** ../images/src/lib/utils/globals.js ***!
  \******************************************/
/*! exports provided: self, window, global, document, isBrowser, isWorker, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return isWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

/* eslint-disable no-restricted-globals */
/* global process, window, global, document, self, importScripts */
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};

const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};



const isBrowser =
  // @ts-ignore
  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;

const isWorker = typeof importScripts === 'function';

// Extract node major version
const matches =
  typeof process !== 'undefined' && process.version && process.version.match(/v([0-9]*)/);
const nodeVersion = (matches && parseFloat(matches[1])) || 0;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../loader-utils/src/categories/mesh/mesh-utils.js":
/*!*********************************************************!*\
  !*** ../loader-utils/src/categories/mesh/mesh-utils.js ***!
  \*********************************************************/
/*! exports provided: getMeshSize, getMeshBoundingBox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshSize", function() { return getMeshSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshBoundingBox", function() { return getMeshBoundingBox; });
function getMeshSize(attributes) {
  let size = 0;
  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    if (ArrayBuffer.isView(attribute)) {
      // @ts-ignore DataView doesn't have BYTES_PER_ELEMENT
      size += attribute.byteLength * attribute.BYTES_PER_ELEMENT;
    }
  }
  return size;
}

// eslint-disable-next-line complexity
function getMeshBoundingBox(attributes) {
  if (!attributes || !attributes.POSITION) {
    return null;
  }

  let minX = Infinity;
  let minY = Infinity;
  let minZ = Infinity;
  let maxX = -Infinity;
  let maxY = -Infinity;
  let maxZ = -Infinity;

  const positions = attributes.POSITION.value;
  const len = positions && positions.length;

  if (!len) {
    return null;
  }

  for (let i = 0; i < len; i += 3) {
    const x = positions[i];
    const y = positions[i + 1];
    const z = positions[i + 2];

    minX = x < minX ? x : minX;
    minY = y < minY ? y : minY;
    minZ = z < minZ ? z : minZ;

    maxX = x > maxX ? x : maxX;
    maxY = y > maxY ? y : maxY;
    maxZ = z > maxZ ? z : maxZ;
  }
  return [[minX, minY, minZ], [maxX, maxY, maxZ]];
}


/***/ }),

/***/ "../loader-utils/src/index.js":
/*!************************************!*\
  !*** ../loader-utils/src/index.js ***!
  \************************************/
/*! exports provided: assert, isBrowser, isWorker, nodeVersion, self, window, global, document, createWorker, validateLoaderVersion, makeTransformIterator, getTransferList, _WorkerFarm, _WorkerPool, _WorkerThread, getLibraryUrl, loadLibrary, parseJSON, isBuffer, toBuffer, bufferToArrayBuffer, toArrayBuffer, sliceArrayBuffer, concatenateArrayBuffers, compareArrayBuffers, padTo4Bytes, copyToArray, copyArrayBuffer, copyPaddedArrayBufferToDataView, copyPaddedStringToDataView, padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView, getFirstCharacters, getMagicString, path, setPathPrefix, getPathPrefix, resolvePath, _addAliases, makeTextEncoderIterator, makeTextDecoderIterator, makeLineIterator, makeNumberedLineIterator, forEach, concatenateChunksAsync, RequestScheduler, ChildProcessProxy, _getMeshSize, getMeshBoundingBox, getZeroOffsetArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/env-utils/globals */ "../loader-utils/src/lib/env-utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["isWorker"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["nodeVersion"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _lib_env_utils_globals__WEBPACK_IMPORTED_MODULE_1__["document"]; });

/* harmony import */ var _lib_worker_loader_utils_create_worker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/worker-loader-utils/create-worker */ "../loader-utils/src/lib/worker-loader-utils/create-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createWorker", function() { return _lib_worker_loader_utils_create_worker__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _lib_worker_loader_utils_validate_loader_version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/worker-loader-utils/validate-loader-version */ "../loader-utils/src/lib/worker-loader-utils/validate-loader-version.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "validateLoaderVersion", function() { return _lib_worker_loader_utils_validate_loader_version__WEBPACK_IMPORTED_MODULE_3__["validateLoaderVersion"]; });

/* harmony import */ var _lib_iterator_utils_make_transform_iterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/iterator-utils/make-transform-iterator */ "../loader-utils/src/lib/iterator-utils/make-transform-iterator.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeTransformIterator", function() { return _lib_iterator_utils_make_transform_iterator__WEBPACK_IMPORTED_MODULE_4__["makeTransformIterator"]; });

/* harmony import */ var _lib_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/worker-utils/get-transfer-list */ "../loader-utils/src/lib/worker-utils/get-transfer-list.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return _lib_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_5__["getTransferList"]; });

/* harmony import */ var _lib_worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/worker-utils/worker-farm */ "../loader-utils/src/lib/worker-utils/worker-farm.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerFarm", function() { return _lib_worker_utils_worker_farm__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _lib_worker_utils_worker_pool__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/worker-utils/worker-pool */ "../loader-utils/src/lib/worker-utils/worker-pool.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerPool", function() { return _lib_worker_utils_worker_pool__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _lib_worker_utils_worker_thread__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/worker-utils/worker-thread */ "../loader-utils/src/lib/worker-utils/worker-thread.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_WorkerThread", function() { return _lib_worker_utils_worker_thread__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/library-utils/library-utils */ "../loader-utils/src/lib/library-utils/library-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getLibraryUrl", function() { return _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_9__["getLibraryUrl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadLibrary", function() { return _lib_library_utils_library_utils__WEBPACK_IMPORTED_MODULE_9__["loadLibrary"]; });

/* harmony import */ var _lib_parser_utils_parse_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/parser-utils/parse-json */ "../loader-utils/src/lib/parser-utils/parse-json.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseJSON", function() { return _lib_parser_utils_parse_json__WEBPACK_IMPORTED_MODULE_10__["parseJSON"]; });

/* harmony import */ var _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/binary-utils/buffer-utils */ "../loader-utils/src/lib/binary-utils/buffer-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBuffer", function() { return _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_11__["isBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toBuffer", function() { return _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_11__["toBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "bufferToArrayBuffer", function() { return _lib_binary_utils_buffer_utils__WEBPACK_IMPORTED_MODULE_11__["bufferToArrayBuffer"]; });

/* harmony import */ var _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/binary-utils/array-buffer-utils */ "../loader-utils/src/lib/binary-utils/array-buffer-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__["toArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sliceArrayBuffer", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__["sliceArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__["concatenateArrayBuffers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "compareArrayBuffers", function() { return _lib_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_12__["compareArrayBuffers"]; });

/* harmony import */ var _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./lib/binary-utils/memory-copy-utils */ "../loader-utils/src/lib/binary-utils/memory-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__["padTo4Bytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__["copyToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__["copyArrayBuffer"]; });

/* harmony import */ var _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/binary-utils/binary-copy-utils */ "../loader-utils/src/lib/binary-utils/binary-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_14__["copyPaddedArrayBufferToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return _lib_binary_utils_binary_copy_utils__WEBPACK_IMPORTED_MODULE_14__["copyPaddedStringToDataView"]; });

/* harmony import */ var _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./lib/binary-utils/encode-utils */ "../loader-utils/src/lib/binary-utils/encode-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_15__["padStringToByteAlignment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_15__["copyStringToDataView"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return _lib_binary_utils_encode_utils__WEBPACK_IMPORTED_MODULE_15__["copyBinaryToDataView"]; });

/* harmony import */ var _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./lib/binary-utils/get-first-characters */ "../loader-utils/src/lib/binary-utils/get-first-characters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFirstCharacters", function() { return _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_16__["getFirstCharacters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMagicString", function() { return _lib_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_16__["getMagicString"]; });

/* harmony import */ var _lib_path_utils_path__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./lib/path-utils/path */ "../loader-utils/src/lib/path-utils/path.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "path", function() { return _lib_path_utils_path__WEBPACK_IMPORTED_MODULE_17__; });
/* harmony import */ var _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./lib/path-utils/file-aliases */ "../loader-utils/src/lib/path-utils/file-aliases.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__["getPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__["resolvePath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_addAliases", function() { return _lib_path_utils_file_aliases__WEBPACK_IMPORTED_MODULE_18__["addAliases"]; });

/* harmony import */ var _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./lib/iterator-utils/text-iterators */ "../loader-utils/src/lib/iterator-utils/text-iterators.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeTextEncoderIterator", function() { return _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__["makeTextEncoderIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeTextDecoderIterator", function() { return _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__["makeTextDecoderIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeLineIterator", function() { return _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__["makeLineIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "makeNumberedLineIterator", function() { return _lib_iterator_utils_text_iterators__WEBPACK_IMPORTED_MODULE_19__["makeNumberedLineIterator"]; });

/* harmony import */ var _lib_iterator_utils_async_iteration__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./lib/iterator-utils/async-iteration */ "../loader-utils/src/lib/iterator-utils/async-iteration.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _lib_iterator_utils_async_iteration__WEBPACK_IMPORTED_MODULE_20__["forEach"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateChunksAsync", function() { return _lib_iterator_utils_async_iteration__WEBPACK_IMPORTED_MODULE_20__["concatenateChunksAsync"]; });

/* harmony import */ var _lib_request_utils_request_scheduler__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./lib/request-utils/request-scheduler */ "../loader-utils/src/lib/request-utils/request-scheduler.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "RequestScheduler", function() { return _lib_request_utils_request_scheduler__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _lib_process_utils_child_process_proxy__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./lib/process-utils/child-process-proxy */ "../loader-utils/src/lib/process-utils/child-process-proxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ChildProcessProxy", function() { return _lib_process_utils_child_process_proxy__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./categories/mesh/mesh-utils */ "../loader-utils/src/categories/mesh/mesh-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getMeshSize", function() { return _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_23__["getMeshSize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getMeshBoundingBox", function() { return _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_23__["getMeshBoundingBox"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getZeroOffsetArrayBuffer", function() { return _lib_binary_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_13__["getZeroOffsetArrayBuffer"]; });

// GENERAL UTILS



// WORKER LOADER UTILS




// WORKER UTILS





// LIBRARY UTILS


// PARSER UTILS


// MEMORY COPY UTILS







// PATH UTILS






// ITERATOR UTILS




// REQUEST UTILS


// PROCESS UTILS


// MESH CATEGORY UTILS
// Note: Should move to category specific module if code size increases


// DEPRECATED IN 2.3



/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/array-buffer-utils.js":
/*!******************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/array-buffer-utils.js ***!
  \******************************************************************/
/*! exports provided: toArrayBuffer, compareArrayBuffers, concatenateArrayBuffers, sliceArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return toArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compareArrayBuffers", function() { return compareArrayBuffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return concatenateArrayBuffers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sliceArrayBuffer", function() { return sliceArrayBuffer; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/buffer-utils.node */ 1);
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__);
/** @typedef {import('./array-buffer-utils')} types */
/* global TextEncoder */



/** @type {types['toArrayBuffer']} */
function toArrayBuffer(data) {
  // Note: Should be called first, Buffers can trigger other detections below
  if (_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__["toArrayBuffer"]) {
    // TODO - per docs we should just be able to call buffer.buffer, but there are issues
    data = _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_1__["toArrayBuffer"](data);
  }

  if (data instanceof ArrayBuffer) {
    return data;
  }

  // Careful - Node Buffers will look like ArrayBuffers (keep after isBuffer)
  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    const text = data;
    const uint8Array = new TextEncoder().encode(text);
    return uint8Array.buffer;
  }

  // HACK to support Blob polyfill
  if (data && typeof data === 'object' && data._toArrayBuffer) {
    return data._toArrayBuffer();
  }

  return Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}

/** @type {types['compareArrayBuffers']} */
function compareArrayBuffers(arrayBuffer1, arrayBuffer2, byteLength) {
  byteLength = byteLength || arrayBuffer1.byteLength;
  if (arrayBuffer1.byteLength < byteLength || arrayBuffer2.byteLength < byteLength) {
    return false;
  }
  const array1 = new Uint8Array(arrayBuffer1);
  const array2 = new Uint8Array(arrayBuffer2);
  for (let i = 0; i < array1.length; ++i) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}

// Concatenate ArrayBuffers
/** @type {types['concatenateArrayBuffers']} */
function concatenateArrayBuffers(...sources) {
  // Make sure all inputs are wrapped in typed arrays
  const sourceArrays = sources.map(
    source2 => (source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2)
  );

  // Get length of all inputs
  const byteLength = sourceArrays.reduce((length, typedArray) => length + typedArray.byteLength, 0);

  // Allocate array with space for all inputs
  const result = new Uint8Array(byteLength);

  // Copy the subarrays
  let offset = 0;
  for (const sourceArray of sourceArrays) {
    result.set(sourceArray, offset);
    offset += sourceArray.byteLength;
  }

  // We work with ArrayBuffers, discard the typed array wrapper
  return result.buffer;
}

// Copy a view of an ArrayBuffer into new ArrayBuffer with byteOffset = 0
function sliceArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  const subArray =
    byteLength !== undefined
      ? new Uint8Array(arrayBuffer).subarray(byteOffset, byteOffset + byteLength)
      : new Uint8Array(arrayBuffer).subarray(byteOffset);
  const arrayCopy = new Uint8Array(subArray);
  return arrayCopy.buffer;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/binary-copy-utils.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/binary-copy-utils.js ***!
  \*****************************************************************/
/*! exports provided: copyPaddedArrayBufferToDataView, copyPaddedStringToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedArrayBufferToDataView", function() { return copyPaddedArrayBufferToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyPaddedStringToDataView", function() { return copyPaddedStringToDataView; });
/* harmony import */ var _memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./memory-copy-utils */ "../loader-utils/src/lib/binary-utils/memory-copy-utils.js");
/* global TextEncoder */


function copyPaddedArrayBufferToDataView(dataView, byteOffset, sourceBuffer) {
  const paddedLength = Object(_memory_copy_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(sourceBuffer.byteLength);
  const padLength = paddedLength - sourceBuffer.byteLength;

  if (dataView) {
    // Copy array
    const targetArray = new Uint8Array(
      dataView.buffer,
      dataView.byteOffset + byteOffset,
      sourceBuffer.byteLength
    );
    const sourceArray = new Uint8Array(sourceBuffer);
    targetArray.set(sourceArray);

    // Add PADDING
    for (let i = 0; i < padLength; ++i) {
      // json chunk is padded with spaces (ASCII 0x20)
      dataView.setUint8(byteOffset + sourceBuffer.byteLength + i, 0x20);
    }
  }
  byteOffset += paddedLength;
  return byteOffset;
}

function copyPaddedStringToDataView(dataView, byteOffset, string) {
  const textEncoder = new TextEncoder();
  // PERFORMANCE IDEA: We encode twice, once to get size and once to store
  // PERFORMANCE IDEA: Use TextEncoder.encodeInto() to avoid temporary copy
  const stringBuffer = textEncoder.encode(string);

  byteOffset = copyPaddedArrayBufferToDataView(dataView, byteOffset, stringBuffer);

  return byteOffset;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/buffer-utils.js":
/*!************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/buffer-utils.js ***!
  \************************************************************/
/*! exports provided: isBuffer, toBuffer, bufferToArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBuffer", function() { return isBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toBuffer", function() { return toBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToArrayBuffer", function() { return bufferToArrayBuffer; });
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node/buffer-utils.node */ 1);
/* harmony import */ var _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__);
/** @typedef {import('./buffer-utils')} types */


/** @type {types['isBuffer']} */
function isBuffer(x) {
  return x && typeof x === 'object' && x.isBuffer;
}

/** @type {types['toBuffer']} */
function toBuffer(data) {
  return _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toBuffer"] ? _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toBuffer"](data) : data;
}

/** @type {types['bufferToArrayBuffer']} */
function bufferToArrayBuffer(data) {
  if (_node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"]) {
    // TODO - per docs we should just be able to call buffer.buffer, but there are issues
    return _node_buffer_utils_node__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"](data);
  }
  return data;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/encode-utils.js":
/*!************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/encode-utils.js ***!
  \************************************************************/
/*! exports provided: padStringToByteAlignment, copyStringToDataView, copyBinaryToDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padStringToByteAlignment", function() { return padStringToByteAlignment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyStringToDataView", function() { return copyStringToDataView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyBinaryToDataView", function() { return copyBinaryToDataView; });
// UTILITIES

// PERFORMANCE IDEA: No need to copy string twice...
function padStringToByteAlignment(string, byteAlignment) {
  const length = string.length;
  const paddedLength = Math.ceil(length / byteAlignment) * byteAlignment; // Round up to the required alignment
  const padding = paddedLength - length;
  let whitespace = '';
  for (let i = 0; i < padding; ++i) {
    whitespace += ' ';
  }
  return string + whitespace;
}

function copyStringToDataView(dataView, byteOffset, string, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, string.charCodeAt(i));
    }
  }
  return byteOffset + byteLength;
}

function copyBinaryToDataView(dataView, byteOffset, binary, byteLength) {
  if (dataView) {
    for (let i = 0; i < byteLength; i++) {
      dataView.setUint8(byteOffset + i, binary[i]);
      byteOffset++;
    }
  }
  return byteOffset + byteLength;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/get-first-characters.js":
/*!********************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/get-first-characters.js ***!
  \********************************************************************/
/*! exports provided: getFirstCharacters, getMagicString */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFirstCharacters", function() { return getFirstCharacters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMagicString", function() { return getMagicString; });
function getFirstCharacters(data, length = 5) {
  if (typeof data === 'string') {
    return data.slice(0, length);
  } else if (ArrayBuffer.isView(data)) {
    // Typed Arrays can have offsets into underlying buffer
    return getMagicString(data.buffer, data.byteOffset, length);
  } else if (data instanceof ArrayBuffer) {
    const byteOffset = 0;
    return getMagicString(data, byteOffset, length);
  }
  return '';
}

function getMagicString(arrayBuffer, byteOffset, length) {
  if (arrayBuffer.byteLength <= byteOffset + length) {
    return '';
  }
  const dataView = new DataView(arrayBuffer);
  let magic = '';
  for (let i = 0; i < length; i++) {
    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));
  }
  return magic;
}


/***/ }),

/***/ "../loader-utils/src/lib/binary-utils/memory-copy-utils.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/binary-utils/memory-copy-utils.js ***!
  \*****************************************************************/
/*! exports provided: padTo4Bytes, getZeroOffsetArrayBuffer, copyArrayBuffer, copyToArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return padTo4Bytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getZeroOffsetArrayBuffer", function() { return getZeroOffsetArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return copyArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return copyToArray; });
/* harmony import */ var _array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array-buffer-utils */ "../loader-utils/src/lib/binary-utils/array-buffer-utils.js");


function padTo4Bytes(byteLength) {
  return (byteLength + 3) & ~3;
}

function getZeroOffsetArrayBuffer(arrayBuffer, byteOffset, byteLength) {
  return Object(_array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__["sliceArrayBuffer"])(arrayBuffer, byteOffset, byteLength);
}

/* Creates a new Uint8Array based on two different ArrayBuffers
 * @private
 * @param {ArrayBuffers} buffer1 The first buffer.
 * @param {ArrayBuffers} buffer2 The second buffer.
 * @return {ArrayBuffers} The new ArrayBuffer created out of the two.
 */
function copyArrayBuffer(
  targetBuffer,
  sourceBuffer,
  byteOffset,
  byteLength = sourceBuffer.byteLength
) {
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

/**
 * Copy from source to target at the targetOffset
 *
 * @param {ArrayBuffer|any} source - The data to copy
 * @param {any} target - The destination to copy data into
 * @param {Number} targetOffset - The start offset into target to place the copied data
 *
 * @return {Number} Returns the new offset taking into account proper padding
 */
function copyToArray(source, target, targetOffset) {
  let sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    // Pack buffer onto the big target array
    //
    // 'source.data.buffer' could be a view onto a larger buffer.
    // We MUST use this constructor to ensure the byteOffset and byteLength is
    // set to correct values from 'source.data' and not the underlying
    // buffer for target.set() to work properly.
    const srcByteOffset = source.byteOffset;
    const srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);
  }

  // Pack buffer onto the big target array
  target.set(sourceArray, targetOffset);

  return targetOffset + padTo4Bytes(sourceArray.byteLength);
}


/***/ }),

/***/ "../loader-utils/src/lib/env-utils/assert.js":
/*!***************************************************!*\
  !*** ../loader-utils/src/lib/env-utils/assert.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/env-utils/globals.js":
/*!****************************************************!*\
  !*** ../loader-utils/src/lib/env-utils/globals.js ***!
  \****************************************************/
/*! exports provided: self, window, global, document, isBrowser, isWorker, nodeVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWorker", function() { return isWorker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nodeVersion", function() { return nodeVersion; });
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global' and 'is-browser';

// @ts-nocheck
/* eslint-disable no-restricted-globals */
/* global process, window, global, document, self, importScripts */
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};

const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};



const isBrowser =
  typeof process !== 'object' || String(process) !== '[object process]' || process.browser;

const isWorker = typeof importScripts === 'function';

// Extract node major version
const matches =
  typeof process !== 'undefined' && process.version && process.version.match(/v([0-9]*)/);
const nodeVersion = (matches && parseFloat(matches[1])) || 0;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../loader-utils/src/lib/iterator-utils/async-iteration.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/iterator-utils/async-iteration.js ***!
  \*****************************************************************/
/*! exports provided: forEach, concatenateChunksAsync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateChunksAsync", function() { return concatenateChunksAsync; });
/* harmony import */ var _binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary-utils/array-buffer-utils */ "../loader-utils/src/lib/binary-utils/array-buffer-utils.js");
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");



// GENERAL UTILITIES

/**
 * Iterate over async iterator, without resetting iterator if end is not reached
 * - forEach intentionally does not reset iterator if exiting loop prematurely
 *   so that iteration can continue in a second loop
 * - It is recommended to use a standard for-await as last loop to ensure
 *   iterator gets properly reset
 *
 * TODO - optimize using sync iteration if argument is an Iterable?
 *
 * @param iterator
 * @param visitor
 */
async function forEach(iterator, visitor) {
  // eslint-disable-next-line
  while (true) {
    const {done, value} = await iterator.next();
    if (done) {
      iterator.return();
      return;
    }
    const cancel = visitor(value);
    if (cancel) {
      return;
    }
  }
}

// Breaking big data into iterable chunks, concatenating iterable chunks into big data objects

/**
 * Concatenates all data chunks yielded by an (async) iterator
 * Supports strings and ArrayBuffers
 *
 * This function can e.g. be used to enable atomic parsers to work on (async) iterator inputs
 */
async function concatenateChunksAsync(asyncIterator) {
  /** @type {ArrayBuffer[]} */
  const arrayBuffers = [];
  /** @type {string[]} */
  const strings = [];
  for await (const chunk of asyncIterator) {
    if (typeof chunk === 'string') {
      strings.push(chunk);
    } else {
      arrayBuffers.push(chunk);
    }
  }

  if (strings.length > 0) {
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(arrayBuffers.length === 0);
    return strings.join('');
  }

  return Object(_binary_utils_array_buffer_utils__WEBPACK_IMPORTED_MODULE_0__["concatenateArrayBuffers"])(...arrayBuffers);
}


/***/ }),

/***/ "../loader-utils/src/lib/iterator-utils/make-transform-iterator.js":
/*!*************************************************************************!*\
  !*** ../loader-utils/src/lib/iterator-utils/make-transform-iterator.js ***!
  \*************************************************************************/
/*! exports provided: makeTransformIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTransformIterator", function() { return makeTransformIterator; });
async function* makeTransformIterator(asyncIterator, IncrementalTransform, options) {
  const transform = new IncrementalTransform(options);
  for await (const chunk of asyncIterator) {
    const output = await transform.write(chunk);
    if (output) {
      yield output;
    }
  }
  const output = await transform.end();
  if (output) {
    yield output;
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/iterator-utils/text-iterators.js":
/*!****************************************************************!*\
  !*** ../loader-utils/src/lib/iterator-utils/text-iterators.js ***!
  \****************************************************************/
/*! exports provided: makeTextDecoderIterator, makeTextEncoderIterator, makeLineIterator, makeNumberedLineIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTextDecoderIterator", function() { return makeTextDecoderIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeTextEncoderIterator", function() { return makeTextEncoderIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeLineIterator", function() { return makeLineIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "makeNumberedLineIterator", function() { return makeNumberedLineIterator; });
// TextDecoder iterators
// TextDecoder will keep any partial undecoded bytes between calls to `decode`

/* global TextDecoder, TextEncoder */

async function* makeTextDecoderIterator(arrayBufferIterator, options) {
  const textDecoder = new TextDecoder(options);
  for await (const arrayBuffer of arrayBufferIterator) {
    yield typeof arrayBuffer === 'string'
      ? arrayBuffer
      : textDecoder.decode(arrayBuffer, {stream: true});
  }
}

// TextEncoder iterator
// TODO - this is not useful unless min chunk size is given
// TextEncoder will keep any partial undecoded bytes between calls to `encode`
// If iterator does not yield strings, assume arrayBuffer and return unencoded

async function* makeTextEncoderIterator(textIterator, options) {
  const textEncoder = new TextEncoder();
  for await (const text of textIterator) {
    yield typeof text === 'string' ? textEncoder.encode(text) : text;
  }
}

/**
 * @param textIterator async iterable yielding strings
 * @returns an async iterable over lines
 * See http://2ality.com/2018/04/async-iter-nodejs.html
 */

async function* makeLineIterator(textIterator) {
  let previous = '';
  for await (const textChunk of textIterator) {
    previous += textChunk;
    let eolIndex;
    while ((eolIndex = previous.indexOf('\n')) >= 0) {
      // line includes the EOL
      const line = previous.slice(0, eolIndex + 1);
      previous = previous.slice(eolIndex + 1);
      yield line;
    }
  }

  if (previous.length > 0) {
    yield previous;
  }
}

/**
 * @param lineIterator async iterable yielding lines
 * @returns async iterable yielding numbered lines
 *
 * See http://2ality.com/2018/04/async-iter-nodejs.html
 */
async function* makeNumberedLineIterator(lineIterator) {
  let counter = 1;
  for await (const line of lineIterator) {
    yield {counter, line};
    counter++;
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/library-utils/library-utils.js":
/*!**************************************************************!*\
  !*** ../loader-utils/src/lib/library-utils/library-utils.js ***!
  \**************************************************************/
/*! exports provided: loadLibrary, getLibraryUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadLibrary", function() { return loadLibrary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLibraryUrl", function() { return getLibraryUrl; });
/* harmony import */ var _env_utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/globals */ "../loader-utils/src/lib/env-utils/globals.js");
/* harmony import */ var _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/require-utils.node */ 0);
/* harmony import */ var _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* global fetch, document */




// TODO - unpkg.com doesn't seem to have a `latest` specifier for alpha releases...
const LATEST = 'beta';

// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.1" : undefined;

const loadLibraryPromises = {}; // promises

// Dynamically loads a library ("module")
async function loadLibrary(libraryUrl, moduleName = null, options = {}) {
  if (moduleName) {
    libraryUrl = getLibraryUrl(libraryUrl, moduleName, options);
  }

  // Ensure libraries are only loaded once
  loadLibraryPromises[libraryUrl] =
    loadLibraryPromises[libraryUrl] || loadLibraryFromFile(libraryUrl);
  return await loadLibraryPromises[libraryUrl];
}

// TODO - sort out how to resolve paths for main/worker and dev/prod
function getLibraryUrl(library, moduleName, options) {
  // Allow application to import and supply libraries through `options.modules`
  const modules = options.modules || {};
  if (modules[library]) {
    return modules[library];
  }

  // Load from local files, not from CDN scripts in Node.js
  // TODO - needs to locate the modules directory when installed!
  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return `modules/${moduleName}/dist/libs/${library}`;
  }

  // In browser, load from external scripts
  if (options.CDN) {
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(options.CDN.startsWith('http'));
    return `${options.CDN}/${moduleName}@${VERSION}/dist/libs/${library}`;
  }

  // TODO - loading inside workers requires paths relative to worker script location...
  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    return `../src/libs/${library}`;
  }

  return `modules/${moduleName}/src/libs/${library}`;
}

async function loadLibraryFromFile(libraryUrl) {
  if (libraryUrl.endsWith('wasm')) {
    const response = await fetch(libraryUrl);
    return await response.arrayBuffer();
  }

  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromFile"] && _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromFile"](libraryUrl);
  }
  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    /* global importScripts */
    return importScripts(libraryUrl);
  }
  // TODO - fix - should be more secure than string parsing since observes CORS
  // if (isBrowser) {
  //   return await loadScriptFromFile(libraryUrl);
  // }

  const response = await fetch(libraryUrl);
  const scriptSource = await response.text();
  return loadLibraryFromString(scriptSource, libraryUrl);
}

/*
async function loadScriptFromFile(libraryUrl) {
  const script = document.createElement('script');
  script.src = libraryUrl;
  return await new Promise((resolve, reject) => {
    script.onload = data => {
      resolve(data);
    };
    script.onerror = reject;
  });
}
*/

// TODO - Needs security audit...
//  - Raw eval call
//  - Potentially bypasses CORS
// Upside is that this separates fetching and parsing
// we could create a`LibraryLoader` or`ModuleLoader`
function loadLibraryFromString(scriptSource, id) {
  if (!_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromString"] && _node_require_utils_node__WEBPACK_IMPORTED_MODULE_1__["requireFromString"](scriptSource, id);
  }

  if (_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isWorker"]) {
    // Use lvalue trick to make eval run in global scope
    eval.call(_env_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"], scriptSource); // eslint-disable-line no-eval
    // https://stackoverflow.com/questions/9107240/1-evalthis-vs-evalthis-in-javascript
    // http://perfectionkills.com/global-eval-what-are-the-options/
    return null;
  }

  const script = document.createElement('script');
  script.id = id;
  // most browsers like a separate text node but some throw an error. The second method covers those.
  try {
    script.appendChild(document.createTextNode(scriptSource));
  } catch (e) {
    script.text = scriptSource;
  }
  document.body.appendChild(script);
  return null;
}

// TODO - technique for module injection into worker, from THREE.DracoLoader...
/*
function combineWorkerWithLibrary(worker, jsContent) {
  var fn = wWorker.toString();
  var body = [
    '// injected',
    jsContent,
    '',
    '// worker',
    fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))
  ].join('\n');
  this.workerSourceURL = URL.createObjectURL(new Blob([body]));
}
*/


/***/ }),

/***/ "../loader-utils/src/lib/parser-utils/parse-json.js":
/*!**********************************************************!*\
  !*** ../loader-utils/src/lib/parser-utils/parse-json.js ***!
  \**********************************************************/
/*! exports provided: parseJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseJSON", function() { return parseJSON; });
/* harmony import */ var _binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../binary-utils/get-first-characters */ "../loader-utils/src/lib/binary-utils/get-first-characters.js");


// Minimal JSON parser with a meaningful error message
function parseJSON(string) {
  try {
    return JSON.parse(string);
  } catch (_) {
    throw new Error(`Failed to parse JSON from data starting with "${Object(_binary_utils_get_first_characters__WEBPACK_IMPORTED_MODULE_0__["getFirstCharacters"])(string)}"`);
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/path-utils/file-aliases.js":
/*!**********************************************************!*\
  !*** ../loader-utils/src/lib/path-utils/file-aliases.js ***!
  \**********************************************************/
/*! exports provided: setPathPrefix, getPathPrefix, addAliases, resolvePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return getPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAliases", function() { return addAliases; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return resolvePath; });
// Simple file alias mechanisms for tests.

let pathPrefix = '';
const fileAliases = {};

/*
 * Set a relative path prefix
 */
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

function getPathPrefix() {
  return pathPrefix;
}

// Note: addAliases are an experimental export,
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}

function resolvePath(filename) {
  for (const alias in fileAliases) {
    if (filename.startsWith(alias)) {
      const replacement = fileAliases[alias];
      filename = filename.replace(alias, replacement);
    }
  }
  if (!filename.startsWith('http://') && !filename.startsWith('https://')) {
    filename = `${pathPrefix}${filename}`;
  }
  return filename;
}


/***/ }),

/***/ "../loader-utils/src/lib/path-utils/path.js":
/*!**************************************************!*\
  !*** ../loader-utils/src/lib/path-utils/path.js ***!
  \**************************************************/
/*! exports provided: dirname */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dirname", function() { return dirname; });
// Beginning of a minimal implementation of the Node.js path API, that doesn't pull in big polyfills.
function dirname(url) {
  const slashIndex = url && url.lastIndexOf('/');
  return slashIndex >= 0 ? url.substr(0, slashIndex) : '';
}


/***/ }),

/***/ "../loader-utils/src/lib/process-utils/child-process-proxy.js":
/*!********************************************************************!*\
  !*** ../loader-utils/src/lib/process-utils/child-process-proxy.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ChildProcessProxy; });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ 2);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* harmony import */ var _process_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./process-utils */ "../loader-utils/src/lib/process-utils/process-utils.js");
// Forked from probe.gl under MIT license, Copyright (c) 2015 - 2017 Uber Technologies, Inc.

/* eslint-disable no-console */
/* global process, setTimeout, clearTimeout, console */




const DEFAULT_PROCESS_OPTIONS = {
  command: null,
  arguments: [],
  portArg: null,
  port: 'auto',
  basePort: 5000,
  wait: 2000,
  nodeSpawnOptions: {maxBuffer: 5000 * 1024},
  onSuccess: processProxy => {
    console.log(`Started ${processProxy.options.command}`);
  }
};

class ChildProcessProxy {
  constructor({id = 'browser-driver'} = {}) {
    this.id = id;
    this.childProcess = null;
    this.port = null;
  }

  async start(options = {}) {
    options = {...DEFAULT_PROCESS_OPTIONS, ...options};
    Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(options.command && typeof options.command === 'string');
    this.options = options;

    const args = [...options.arguments];

    // If portArg is set, we can look up an available port
    this.port = options.port;
    if (options.portArg) {
      if (this.port === 'auto') {
        this.port = await Object(_process_utils__WEBPACK_IMPORTED_MODULE_2__["getAvailablePort"])(options.basePort);
      }
      args.push(options.portArg, this.port);
    }

    return await new Promise((resolve, reject) => {
      try {
        const successTimer = setTimeout(() => {
          if (options.onSuccess) {
            options.onSuccess(this);
          }
          resolve({});
        }, options.wait);

        console.log(`Spawning ${options.command} ${options.arguments.join(' ')}`);
        this.childProcess = child_process__WEBPACK_IMPORTED_MODULE_0___default.a.spawn(options.command, args, options.spawn);

        // TODO - add option regarding whether stderr should be treated as data
        this.childProcess.stderr.on('data', data => {
          console.log(`Child process wrote to stderr: "${data}".`);
          clearTimeout(successTimer);
          reject(new Error(data));
        });
        this.childProcess.on('error', error => {
          console.log(`Child process errored with ${error}`);
          clearTimeout(successTimer);
          reject(error);
        });
        this.childProcess.on('close', code => {
          console.log(`Child process exited with ${code}`);
          this.childProcess = null;
        });
      } catch (error) {
        reject(error);
      }
    });
  }

  async stop() {
    if (this.childProcess) {
      this.childProcess.kill();
      this.childProcess = null;
    }
  }

  async exit(statusCode = 0) {
    try {
      await this.stop();
      // eslint-disable-next-line no-process-exit
      process.exit(statusCode);
    } catch (error) {
      console.error(error.message || error);
      // eslint-disable-next-line no-process-exit
      process.exit(1);
    }
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../loader-utils/src/lib/process-utils/process-utils.js":
/*!**************************************************************!*\
  !*** ../loader-utils/src/lib/process-utils/process-utils.js ***!
  \**************************************************************/
/*! exports provided: getAvailablePort */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAvailablePort", function() { return getAvailablePort; });
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! child_process */ 2);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_0__);


// Get an available port
// Works on Unix systems
function getAvailablePort(defaultPort = 3000) {
  return new Promise((resolve, reject) => {
    // Get a list of all ports in use
    child_process__WEBPACK_IMPORTED_MODULE_0___default.a.exec('lsof -i -P -n | grep LISTEN', (error, stdout, stderr) => {
      if (error) {
        // likely no permission, e.g. CI
        resolve(defaultPort);
        return;
      }

      const portsInUse = [];
      const regex = /:(\d+) \(LISTEN\)/;
      stdout.split('\n').forEach(line => {
        const match = line.match(regex);
        if (match) {
          portsInUse.push(Number(match[1]));
        }
      });
      let port = defaultPort;
      while (portsInUse.includes(port)) {
        port++;
      }
      resolve(port);
    });
  });
}


/***/ }),

/***/ "../loader-utils/src/lib/request-utils/request-scheduler.js":
/*!******************************************************************!*\
  !*** ../loader-utils/src/lib/request-utils/request-scheduler.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RequestScheduler; });
/* harmony import */ var _probe_gl_stats__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @probe.gl/stats */ "../../node_modules/@probe.gl/stats/dist/esm/index.js");
// TODO - this should move to core when test cases are more complete

/* global setTimeout */


const STAT_QUEUED_REQUESTS = 'Queued Requests';
const STAT_ACTIVE_REQUESTS = 'Active Requests';
const STAT_CANCELLED_REQUESTS = 'Cancelled Requests';
const STAT_QUEUED_REQUESTS_EVER = 'Queued Requests Ever';
const STAT_ACTIVE_REQUESTS_EVER = 'Active Requests Ever';

const DEFAULT_PROPS = {
  id: 'request-scheduler',
  // Specifies if the request scheduler should throttle incoming requests, mainly for comparative testing
  throttleRequests: true,
  // The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.
  maxRequests: 6
};

// TODO - Track requests globally, across multiple servers
class RequestScheduler {
  constructor(props = {}) {
    this.props = {...DEFAULT_PROPS, ...props};

    // Tracks the number of active requests and prioritizes/cancels queued requests.
    this.requestQueue = [];
    this.activeRequestCount = 0;
    this.requestMap = new Map();

    // Returns the statistics used by the request scheduler.
    this.stats = new _probe_gl_stats__WEBPACK_IMPORTED_MODULE_0__["Stats"]({id: props.id});
    this.stats.get(STAT_QUEUED_REQUESTS);
    this.stats.get(STAT_ACTIVE_REQUESTS);
    this.stats.get(STAT_CANCELLED_REQUESTS);
    this.stats.get(STAT_QUEUED_REQUESTS_EVER);
    this.stats.get(STAT_ACTIVE_REQUESTS_EVER);

    this._deferredUpdate = null;
  }

  // Called by an application that wants to issue a request, without having it deeply queued
  // Parameter `getPriority` will be called when request "slots" open up,
  //    allowing the caller to update priority or cancel the request
  //    Highest priority executes first, priority < 0 cancels the request
  // Returns: a promise that resolves to a request token when the request can be issued without queueing,
  //    or `false` if the request has been cancelled (by getPriority)
  scheduleRequest(handle, getPriority = () => 0) {
    // Allows throttling to be disabled
    if (!this.props.throttleRequests) {
      return Promise.resolve({done: () => {}});
    }

    // dedupe
    if (this.requestMap.has(handle)) {
      return this.requestMap.get(handle);
    }

    const request = {handle, getPriority};
    const promise = new Promise(resolve => {
      request.resolve = resolve;
      return request;
    });

    this.requestQueue.push(request);
    this.requestMap.set(handle, promise);
    this._issueNewRequests();
    return promise;
  }

  // PRIVATE

  _issueRequest(request) {
    const {handle, resolve} = request;
    let isDone = false;

    const done = () => {
      // can only be called once
      if (!isDone) {
        isDone = true;

        // Stop tracking a request - it has completed, failed, cancelled etc
        this.requestMap.delete(handle);
        this.activeRequestCount--;
        // A slot just freed up, see if any queued requests are waiting
        this._issueNewRequests();
      }
    };

    // Track this request
    this.activeRequestCount++;

    return resolve ? resolve({done}) : Promise.resolve({done});
  }

  // We check requests asynchronously, to prevent multiple updates
  _issueNewRequests() {
    if (!this._deferredUpdate) {
      this._deferredUpdate = setTimeout(() => this._issueNewRequestsAsync(), 0);
    }
  }

  // Refresh all requests and
  _issueNewRequestsAsync() {
    this._deferredUpdate = null;

    const freeSlots = Math.max(this.props.maxRequests - this.activeRequestCount, 0);

    if (freeSlots === 0) {
      return;
    }

    this._updateAllRequests();

    // Resolve pending promises for the top-priority requests
    for (let i = 0; i < freeSlots; ++i) {
      if (this.requestQueue.length > 0) {
        const request = this.requestQueue.shift();
        this._issueRequest(request);
      }
    }

    // Uncomment to debug
    // console.log(`${freeSlots} free slots, ${this.requestQueue.length} queued requests`);
  }

  // Ensure all requests have updated priorities, and that no longer valid requests are cancelled
  _updateAllRequests() {
    const requestQueue = this.requestQueue;
    for (let i = 0; i < requestQueue.length; ++i) {
      const request = requestQueue[i];
      if (!this._updateRequest(request)) {
        // Remove the element and make sure to adjust the counter to account for shortened array
        requestQueue.splice(i, 1);
        this.requestMap.delete(request.handle);
        i--;
      }
    }

    // Sort the remaining requests based on priority
    requestQueue.sort((a, b) => a.priority - b.priority);
  }

  // Update a single request by calling the callback
  _updateRequest(request) {
    request.priority = request.getPriority(request.handle); // eslint-disable-line callback-return

    // by returning a negative priority, the callback cancels the request
    if (request.priority < 0) {
      request.resolve(null);
      return false;
    }
    return true;
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-loader-utils/create-worker.js":
/*!********************************************************************!*\
  !*** ../loader-utils/src/lib/worker-loader-utils/create-worker.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createWorker; });
/* harmony import */ var _worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../worker-utils/get-transfer-list */ "../loader-utils/src/lib/worker-utils/get-transfer-list.js");
/* harmony import */ var _validate_loader_version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./validate-loader-version */ "../loader-utils/src/lib/worker-loader-utils/validate-loader-version.js");
/* eslint-disable no-restricted-globals */
/* global TextDecoder, self */




function createWorker(loader) {
  // TODO - explain when this happens? Just a sanity check? Throw an error or log a warning?
  if (typeof self === 'undefined') {
    return;
  }

  let requestId = 0;
  const parse = (arraybuffer, options = {}, url) =>
    new Promise((resolve, reject) => {
      const id = requestId++;

      const onMessage = ({data}) => {
        if (!data || data.id !== id) {
          // not ours
          return;
        }
        switch (data.type) {
          case 'parse-done':
            self.removeEventListener('message', onMessage);
            resolve(data.result);
            break;

          case 'parse-error':
            self.removeEventListener('message', onMessage);
            reject(data.message);
            break;

          default:
          // ignore
        }
      };
      self.addEventListener('message', onMessage);
      // Ask the main thread to decode data
      // @ts-ignore self is WorkerGlobalScope
      self.postMessage({type: 'parse', id, arraybuffer, options, url}, [arraybuffer]);
    });

  self.onmessage = async evt => {
    const {data} = evt;

    try {
      if (!isKnownMessage(data, loader.name)) {
        return;
      }

      Object(_validate_loader_version__WEBPACK_IMPORTED_MODULE_1__["validateLoaderVersion"])(loader, data.source.split('@')[1]);

      const {arraybuffer, byteOffset = 0, byteLength = 0, options = {}} = data;

      const result = await parseData({
        loader,
        arraybuffer,
        byteOffset,
        byteLength,
        options,
        context: {parse}
      });
      const transferList = Object(_worker_utils_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__["getTransferList"])(result);
      // @ts-ignore self is WorkerGlobalScope
      self.postMessage({type: 'done', result}, transferList);
    } catch (error) {
      // @ts-ignore self is WorkerGlobalScope
      self.postMessage({type: 'error', message: error.message});
    }
  };
}

// TODO - Support byteOffset and byteLength (enabling parsing of embedded binaries without copies)
// TODO - Why not support async loader.parse* funcs here?
// TODO - Why not reuse a common function instead of reimplementing loader.parse* selection logic? Keeping loader small?
// TODO - Lack of appropriate parser functions can be detected when we create worker, no need to wait until parse
async function parseData({loader, arraybuffer, byteOffset, byteLength, options, context}) {
  let data;
  let parser;
  if (loader.parseSync || loader.parse) {
    data = arraybuffer;
    parser = loader.parseSync || loader.parse;
  } else if (loader.parseTextSync) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(arraybuffer);
    parser = loader.parseTextSync;
  } else {
    throw new Error(`Could not load data with ${loader.name} loader`);
  }

  // TODO - proper merge in of loader options...
  options = {
    ...options,
    modules: (loader && loader.options && loader.options.modules) || {},
    worker: false
  };

  return await parser(data, {...options}, context, loader);
}

// Filter out noise messages sent to workers
function isKnownMessage(data, name) {
  return data && data.type === 'parse' && data.source && data.source.startsWith('loaders.gl');
}

/*
function checkMessage(evt, name) {
  switch (evt.data && evt.data.source) {
    // Ignore known noise event from react-dev-tools bridge, webpack build progress etc...
    case 'react-devtools-bridge':
    case 'react-devtools-content-script':
    case 'react-devtools-detector':
      return false;
    default:
      // fall through
  }

  switch (evt.data && evt.data.type) {
    case 'webpackProgress':
    case 'webpackOk':
      return false;
    default:
      // Enable to debug messages
      // const message = `${name.toLowerCase()}-worker: ignoring unknown message`;
      // console.log(message, evt.data, evt); // eslint-disable-line
      return false;
  }
}
*/


/***/ }),

/***/ "../loader-utils/src/lib/worker-loader-utils/validate-loader-version.js":
/*!******************************************************************************!*\
  !*** ../loader-utils/src/lib/worker-loader-utils/validate-loader-version.js ***!
  \******************************************************************************/
/*! exports provided: validateLoaderVersion */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateLoaderVersion", function() { return validateLoaderVersion; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");


// __VERSION__ is injected by babel-plugin-version-inline

// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.1" : undefined;

// Returns `true` if the two versions are compatible
function validateLoaderVersion(loader, coreVersion = VERSION) {
  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(loader, 'no loader provided');

  let loaderVersion = loader.version;
  if (!coreVersion || !loaderVersion) {
    return;
  }

  coreVersion = parseVersion(coreVersion);
  loaderVersion = parseVersion(loaderVersion);

  // TODO enable when fix the __version__ injection
  // assert(
  //   coreVersion.major === loaderVersion.major && coreVersion.minor <= loaderVersion.minor,
  //   `loader: ${loader.name} is not compatible. ${coreVersion.major}.${
  //     coreVersion.minor
  //   }+ is required.`
  // );
}

function parseVersion(version) {
  const parts = version.split('.').map(Number);
  return {major: parts[0], minor: parts[1]};
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/get-transfer-list.js":
/*!*****************************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/get-transfer-list.js ***!
  \*****************************************************************/
/*! exports provided: getTransferList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTransferList", function() { return getTransferList; });
// NOTE - there is a copy of this function is both in core and loader-utils
// core does not need all the utils in loader-utils, just this one.

/* global MessagePort, ImageBitmap, OffscreenCanvas */

// Returns an array of Transferrable objects that can be used with postMessage
// https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage
function getTransferList(object, recursive = true, transfers) {
  // Make sure that items in the transfer list is unique
  const transfersSet = transfers || new Set();

  if (!object) {
    // ignore
  } else if (isTransferable(object)) {
    transfersSet.add(object);
  } else if (isTransferable(object.buffer)) {
    // Typed array
    transfersSet.add(object.buffer);
  } else if (ArrayBuffer.isView(object)) {
    // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)
    // Do not iterate through the content in this case
  } else if (recursive && typeof object === 'object') {
    for (const key in object) {
      // Avoid perf hit - only go one level deep
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  // If transfers is defined, is internal recursive call
  // Otherwise it's called by the user
  return transfers === undefined ? Array.from(transfersSet) : [];
}

// https://developer.mozilla.org/en-US/docs/Web/API/Transferable
function isTransferable(object) {
  if (!object) {
    return false;
  }
  if (object instanceof ArrayBuffer) {
    return true;
  }
  if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {
    return true;
  }
  if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {
    return true;
  }
  if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {
    return true;
  }
  return false;
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/get-worker-url.js":
/*!**************************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/get-worker-url.js ***!
  \**************************************************************/
/*! exports provided: getWorkerURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getWorkerURL", function() { return getWorkerURL; });
/* harmony import */ var _env_utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env-utils/assert */ "../loader-utils/src/lib/env-utils/assert.js");
/* global URL, Blob */


const workerURLCache = new Map();

// Creates a URL from worker source that can be used to create `Worker` instances
// Packages (and then caches) the result of `webworkify` as an "Object URL"
function getWorkerURL(workerSource, workerName = 'Worker') {
  Object(_env_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof workerSource === 'string', 'worker source');

  // CASE: url(./worker.js)
  // This pattern is used to differentiate worker urls from worker source code
  // Load from url is needed for testing, when using Webpack & webworker target
  if (workerSource.startsWith('url(') && workerSource.endsWith(')')) {
    const workerUrl = workerSource.match(/^url\((.*)\)$/)[1];

    // A local script url, we can use it to initialize a Worker directly
    if (workerUrl && !workerUrl.startsWith('http')) {
      return workerUrl;
    }

    // Per spec, worker cannot be initialized with a script from a different origin
    // However a local worker script can still import scripts from other origins,
    // so we simply build a wrapper script
    workerSource = buildScript(workerUrl);
  }

  let workerURL = workerURLCache.get(workerSource);

  if (!workerURL) {
    // NOTE: webworkify was previously used
    // const blob = webworkify(workerSource, {bare: true});
    const blob = new Blob([workerSource], {type: 'application/javascript'});
    workerURL = URL.createObjectURL(blob);
    workerURLCache.set(workerSource, workerURL);
  }

  return workerURL;
}

// Only use trusted sources!
function buildScript(workerUrl) {
  return `\
try {
  importScripts('${workerUrl}');
} catch (error) {
  console.error(error);
}`;
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/worker-farm.js":
/*!***********************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/worker-farm.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerFarm; });
/* harmony import */ var _worker_pool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-pool */ "../loader-utils/src/lib/worker-utils/worker-pool.js");


const DEFAULT_MAX_CONCURRENCY = 5;

/**
 * Process multiple data messages with a "farm" of different workers (in worker pools)
 */
class WorkerFarm {
  static isSupported() {
    return typeof Worker !== 'undefined';
  }

  constructor({maxConcurrency = DEFAULT_MAX_CONCURRENCY, onMessage = null, onDebug = () => {}}) {
    this.maxConcurrency = maxConcurrency;
    this.onMessage = onMessage;
    this.onDebug = onDebug;
    this.workerPools = new Map();
  }

  setProps(props) {
    if ('maxConcurrency' in props) {
      this.maxConcurrency = props.maxConcurrency;
    }

    if ('onDebug' in props) {
      this.onDebug = props.onDebug;
    }
  }

  destroy() {
    this.workerPools.forEach(workerPool => workerPool.destroy());
  }

  /**
   * Process binary data in a worker
   * @param {any} data - data (containing binary typed arrays) to be transferred to worker
   * @returns a Promise with data containing typed arrays transferred back from work
   */
  async process(workerSource, workerName, data) {
    const workerPool = this._getWorkerPool(workerSource, workerName);
    return workerPool.process(data);
  }

  // PRIVATE

  _getWorkerPool(workerSource, workerName) {
    let workerPool = this.workerPools.get(workerName);
    if (!workerPool) {
      workerPool = new _worker_pool__WEBPACK_IMPORTED_MODULE_0__["default"]({
        source: workerSource,
        name: workerName,
        onMessage: onWorkerMessage.bind(null, this.onMessage),
        maxConcurrency: this.maxConcurrency,
        onDebug: this.onDebug
      });
      this.workerPools.set(workerName, workerPool);
    }
    return workerPool;
  }
}

function onWorkerMessage(onMessage, {worker, data, resolve, reject}) {
  if (onMessage) {
    onMessage({worker, data, resolve, reject});
    return;
  }

  switch (data.type) {
    case 'done':
      resolve(data.result);
      break;

    case 'error':
      reject(data.message);
      break;

    default:
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/worker-pool.js":
/*!***********************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/worker-pool.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerPool; });
/* harmony import */ var _worker_thread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./worker-thread */ "../loader-utils/src/lib/worker-utils/worker-thread.js");


/**
 * Process multiple data messages with small pool of identical workers
 */
class WorkerPool {
  constructor({source, name = 'unnamed', maxConcurrency = 1, onMessage, onDebug = () => {}}) {
    this.source = source;
    this.name = name;
    this.maxConcurrency = maxConcurrency;
    this.onMessage = onMessage;
    this.onDebug = onDebug;

    this.jobQueue = [];
    this.idleQueue = [];
    this.count = 0;
    this.isDestroyed = false;
  }

  destroy() {
    // Destroy idle workers, active Workers will be destroyed on completion
    this.idleQueue.forEach(worker => worker.destroy());
    this.isDestroyed = true;
  }

  /**
   * Process binary data in a worker
   */
  process(data, jobName) {
    return new Promise((resolve, reject) => {
      this.jobQueue.push({data, jobName, resolve, reject});
      this._startQueuedJob();
    });
  }

  // PRIVATE

  async _startQueuedJob() {
    if (!this.jobQueue.length) {
      return;
    }
    const worker = this._getAvailableWorker();
    if (!worker) {
      return;
    }

    // We have a worker, dequeue and start the job
    const job = this.jobQueue.shift();

    // @ts-ignore
    this.onDebug({
      message: 'processing',
      worker: worker.name,
      job: job.jobName,
      backlog: this.jobQueue.length
    });

    try {
      job.resolve(await worker.process(job.data));
    } catch (error) {
      job.reject(error);
    } finally {
      this._onWorkerDone(worker);
    }
  }

  _onWorkerDone(worker) {
    if (this.isDestroyed) {
      worker.destroy();
    } else {
      this.idleQueue.push(worker);
      this._startQueuedJob();
    }
  }

  _getAvailableWorker() {
    // If a worker has completed and returned to the queue, it can be used
    if (this.idleQueue.length > 0) {
      return this.idleQueue.shift();
    }

    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source
    if (this.count < this.maxConcurrency) {
      this.count++;
      const name = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
      return new _worker_thread__WEBPACK_IMPORTED_MODULE_0__["default"]({source: this.source, onMessage: this.onMessage, name});
    }

    // No worker available, have to wait
    return null;
  }
}


/***/ }),

/***/ "../loader-utils/src/lib/worker-utils/worker-thread.js":
/*!*************************************************************!*\
  !*** ../loader-utils/src/lib/worker-utils/worker-thread.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WorkerThread; });
/* harmony import */ var _get_worker_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-worker-url */ "../loader-utils/src/lib/worker-utils/get-worker-url.js");
/* harmony import */ var _get_transfer_list__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-transfer-list */ "../loader-utils/src/lib/worker-utils/get-transfer-list.js");
/* global Worker */



let count = 0;

// By default resolves to the first message the worker sends back
function defaultOnMessage({data, resolve}) {
  resolve(data);
}

class WorkerThread {
  constructor({source, name = `web-worker-${count++}`, onMessage}) {
    const url = Object(_get_worker_url__WEBPACK_IMPORTED_MODULE_0__["getWorkerURL"])(source, name);
    this.worker = new Worker(url, {name});
    this.name = name;
    this.onMessage = onMessage || defaultOnMessage;
  }

  /**
   * Process binary data in a worker
   */
  async process(data) {
    return new Promise((resolve, reject) => {
      this.worker.onmessage = event => {
        this.onMessage({worker: this.worker, data: event.data, resolve, reject});
      };
      this.worker.onerror = error => {
        // Note Error object does not have the expected fields if loading failed completely
        // https://developer.mozilla.org/en-US/docs/Web/API/Worker#Event_handlers
        // https://developer.mozilla.org/en-US/docs/Web/API/ErrorEvent
        let message = `${this.name}: WorkerThread.process() failed`;
        if (error.message) {
          message += ` ${error.message} ${error.filename}:${error.lineno}:${error.colno}`;
        }
        const betterError = new Error(message);
        console.error(error); // eslint-disable-line
        reject(betterError);
      };
      const transferList = Object(_get_transfer_list__WEBPACK_IMPORTED_MODULE_1__["getTransferList"])(data);
      this.worker.postMessage(data, transferList);
    });
  }

  destroy() {
    this.worker.terminate();
    // @ts-ignore
    this.worker = null;
  }
}


/***/ }),

/***/ "./src/bundle.js":
/*!***********************!*\
  !*** ./src/bundle.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global window, global */
const moduleExports = __webpack_require__(/*! ./index */ "./src/index.js");
const _global = typeof window === 'undefined' ? global : window;
// @ts-ignore
_global.loaders = _global.loaders || {};
// @ts-ignore
module.exports = Object.assign(_global.loaders, moduleExports);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/glb-loader.js":
/*!***************************!*\
  !*** ./src/glb-loader.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_parse_glb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parse-glb */ "./src/lib/parse-glb.js");
// GLB is the binary container format for GLTF

/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */

// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.1" : undefined;

/** @type {LoaderObject} */
/* harmony default export */ __webpack_exports__["default"] = ({
  id: 'glb',
  name: 'GLB',
  version: VERSION,
  extensions: ['glb'],
  mimeTypes: ['model/gltf-binary'],
  binary: true,
  parse: async (arrayBuffer, options) => parseSync(arrayBuffer, options),
  parseSync,
  options: {
    glb: {
      strict: false // Enables deprecated XVIZ support (illegal CHUNK formats)
    }
  }
});

function parseSync(arrayBuffer, options) {
  const {byteOffset = 0} = options;
  const glb = {};
  Object(_lib_parse_glb__WEBPACK_IMPORTED_MODULE_0__["default"])(glb, arrayBuffer, byteOffset, options);
  return glb;
}


/***/ }),

/***/ "./src/glb-writer.js":
/*!***************************!*\
  !*** ./src/glb-writer.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_encode_glb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encode-glb */ "./src/lib/encode-glb.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'GLB',
  extensions: ['glb'],
  mimeTypes: ['model/gltf-binary'],
  encodeSync,
  binary: true,
  options: {
    glb: {}
  }
});

function encodeSync(glb, options) {
  const {byteOffset = 0} = options;

  // Calculate length and allocate buffer
  const byteLength = Object(_lib_encode_glb__WEBPACK_IMPORTED_MODULE_0__["default"])(glb, null, byteOffset, options);
  const arrayBuffer = new ArrayBuffer(byteLength);

  // Encode into buffer
  const dataView = new DataView(arrayBuffer);
  Object(_lib_encode_glb__WEBPACK_IMPORTED_MODULE_0__["default"])(glb, dataView, byteOffset, options);

  return arrayBuffer;
}


/***/ }),

/***/ "./src/gltf-loader.js":
/*!****************************!*\
  !*** ./src/gltf-loader.js ***!
  \****************************/
/*! exports provided: default, parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony import */ var _lib_parse_gltf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parse-gltf */ "./src/lib/parse-gltf.js");

/** @typedef {import('@loaders.gl/loader-utils').LoaderObject} LoaderObject */

// __VERSION__ is injected by babel-plugin-version-inline
// @ts-ignore TS2304: Cannot find name '__VERSION__'.
const VERSION =  true ? "2.3.1" : undefined;

/** @type {LoaderObject} */
const GLTFLoader = {
  id: 'gltf',
  name: 'glTF',
  version: VERSION,
  extensions: ['gltf', 'glb'],
  mimeTypes: ['model/gltf+json', 'model/gltf-binary'],

  text: true,
  binary: true,
  tests: ['glTF'],
  parse,

  options: {
    gltf: {
      normalize: false, // Normalize glTF v1 to glTF v2 format (not yet stable)
      loadBuffers: true, // Fetch any linked .BIN buffers, decode base64
      loadImages: true, // Create image objects
      decompressMeshes: true, // Decompress Draco encoded meshes
      postProcess: true // Postprocess glTF and return json structure directly
    },

    // common?
    uri: '', // base URI
    log: console // eslint-disable-line
  },
  deprecatedOptions: {
    fetchImages: 'gltf.loadImages',
    createImages: 'gltf.loadImages',
    decompress: 'gltf.decompressMeshes',
    postProcess: 'gltf.postProcess',
    gltf: {
      decompress: 'gltf.decompressMeshes'
    }
  }
};

/* harmony default export */ __webpack_exports__["default"] = (GLTFLoader);

async function parse(arrayBuffer, options = {}, context) {
  // Apps can call the parse method directly, we so apply default options here
  options = {...GLTFLoader.options, ...options};
  // @ts-ignore
  options.gltf = {...GLTFLoader.options.gltf, ...options.gltf};
  addDeprecatedGLTFOptions(options);

  const {byteOffset = 0} = options;
  const gltf = {};
  return await Object(_lib_parse_gltf__WEBPACK_IMPORTED_MODULE_0__["parseGLTF"])(gltf, arrayBuffer, byteOffset, options, context);
}

// DEPRECATED

function addDeprecatedGLTFOptions(options) {
  if ('fetchImages' in options) {
    options.gltf.loadImages = options.fetchImages;
  }
  if ('createImages' in options) {
    options.gltf.loadImages = options.createImages;
  }
  if ('fetchLinkedResources' in options) {
    options.gltf.fetchBuffers = options.fetchLinkedResources;
  }
  if ('decompress' in options) {
    options.gltf.decompressMeshes = options.decompress;
  }
  if ('decompress' in options.gltf) {
    options.gltf.decompressMeshes = options.gltf.decompress;
  }
  if ('postProcess' in options) {
    options.gltf.postProcess = options.postProcess;
  }
}


/***/ }),

/***/ "./src/gltf-writer.js":
/*!****************************!*\
  !*** ./src/gltf-writer.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_encode_gltf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encode-gltf */ "./src/lib/encode-gltf.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'glTF',
  extensions: ['glb'], // We only support encoding to binary GLB, not to JSON GLTF
  mimeTypes: ['model/gltf-binary'], // 'model/gltf+json',
  encodeSync,
  binary: true,
  options: {}
});

function encodeSync(gltf, options = {}) {
  const {byteOffset = 0} = options;

  // Calculate length, then create arraybuffer and encode
  const byteLength = Object(_lib_encode_gltf__WEBPACK_IMPORTED_MODULE_0__["encodeGLTFSync"])(gltf, null, byteOffset, options);
  const arrayBuffer = new ArrayBuffer(byteLength);
  const dataView = new DataView(arrayBuffer);
  Object(_lib_encode_gltf__WEBPACK_IMPORTED_MODULE_0__["encodeGLTFSync"])(gltf, dataView, byteOffset, options);

  return arrayBuffer;
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: KHR_DRACO_MESH_COMPRESSION, UBER_POINT_CLOUD_EXTENSION, GLTFLoader, GLTFWriter, GLBLoader, GLBWriter, GLTFScenegraph, postProcessGLTF, GLBBuilder, encodeGLTFSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_gltf_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/gltf-constants */ "./src/lib/gltf-constants.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "KHR_DRACO_MESH_COMPRESSION", function() { return _lib_gltf_constants__WEBPACK_IMPORTED_MODULE_0__["KHR_DRACO_MESH_COMPRESSION"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UBER_POINT_CLOUD_EXTENSION", function() { return _lib_gltf_constants__WEBPACK_IMPORTED_MODULE_0__["UBER_POINT_CLOUD_EXTENSION"]; });

/* harmony import */ var _gltf_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gltf-loader */ "./src/gltf-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFLoader", function() { return _gltf_loader__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _gltf_writer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gltf-writer */ "./src/gltf-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFWriter", function() { return _gltf_writer__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _glb_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./glb-loader */ "./src/glb-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBLoader", function() { return _glb_loader__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _glb_writer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./glb-writer */ "./src/glb-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBWriter", function() { return _glb_writer__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _lib_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/gltf-scenegraph */ "./src/lib/gltf-scenegraph.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLTFScenegraph", function() { return _lib_gltf_scenegraph__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _lib_post_process_gltf__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/post-process-gltf */ "./src/lib/post-process-gltf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "postProcessGLTF", function() { return _lib_post_process_gltf__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _lib_deprecated_glb_builder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/deprecated/glb-builder */ "./src/lib/deprecated/glb-builder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GLBBuilder", function() { return _lib_deprecated_glb_builder__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _lib_encode_gltf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/encode-gltf */ "./src/lib/encode-gltf.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeGLTFSync", function() { return _lib_encode_gltf__WEBPACK_IMPORTED_MODULE_8__["encodeGLTFSync"]; });

// Constants


// glTF loader/writer definition objects



// GLB Loader & Writer (for custom formats that want to leverage the GLB binary "envelope")



// glTF Data Access Helper Class



// DEPRECATED


 // For 3D Tiles


/***/ }),

/***/ "./src/lib/deprecated/glb-builder.js":
/*!*******************************************!*\
  !*** ./src/lib/deprecated/glb-builder.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLBBuilder; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/images */ "../images/src/index.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");
/* harmony import */ var _encode_glb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../encode-glb */ "./src/lib/encode-glb.js");
// @ts-nocheck

/* eslint-disable camelcase, max-statements */





class GLBBuilder {
  constructor(options = {}) {
    // Lets us keep track of how large the body will be, as well as the offset for each of the
    // original buffers.
    this.byteLength = 0;

    this.json = {
      buffers: [
        {
          // Just the single BIN chunk buffer
          byteLength: 0 // Updated at end of conversion
        }
      ],
      bufferViews: [],
      accessors: [],
      images: [],
      meshes: []
    };

    // list of binary buffers to be written to the BIN chunk
    // (Each call to addBuffer, addImage etc adds an entry here)
    this.sourceBuffers = [];

    this.log = options.log || console; // eslint-disable-line
  }

  // ACCESSORS

  getByteLength() {
    return this.byteLength;
  }

  // Checks if a binary buffer is a recognized image format (PNG, JPG, GIF, ...)
  isImage(imageData) {
    return Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__["isImage"])(imageData);
  }

  // MODIFERS
  encodeSync(options = {}) {
    return this.encodeAsGLB(options);
  }

  // Encode the full glTF file as a binary GLB file
  // Returns an ArrayBuffer that represents the complete GLB image that can be saved to file
  // Encode the full GLB buffer with header etc
  // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#
  // glb-file-format-specification
  encodeAsGLB(options = {}) {
    // TODO - avoid double array buffer creation
    this._packBinaryChunk();

    if (options.magic) {
      console.warn('Custom glTF magic number no longer supported'); // eslint-disable-line
    }

    const glb = {
      version: 2,
      json: this.json,
      binary: this.arrayBuffer
    };

    // Calculate length and allocate buffer
    const byteLength = Object(_encode_glb__WEBPACK_IMPORTED_MODULE_3__["default"])(glb, null, 0, options);
    const glbArrayBuffer = new ArrayBuffer(byteLength);

    // Encode into buffer
    const dataView = new DataView(glbArrayBuffer);
    Object(_encode_glb__WEBPACK_IMPORTED_MODULE_3__["default"])(glb, dataView, 0, options);

    return glbArrayBuffer;
  }

  // Add an extra application-defined key to the top-level data structure
  // By default packs JSON by extracting binary data and replacing it with JSON pointers
  addApplicationData(key, data, packOptions = {}) {
    this.json[key] = data;
    return this;
  }

  // Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
  // Buffer will be copied into BIN chunk during "pack"
  // Currently encodes buffers as glTF accessors, but this could be optimized
  addBuffer(sourceBuffer, accessor = {size: 3}) {
    const bufferViewIndex = this.addBufferView(sourceBuffer);

    const accessorDefaults = {
      size: accessor.size,
      componentType: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__["getComponentTypeFromArray"])(sourceBuffer),
      count: Math.round(sourceBuffer.length / accessor.size)
    };

    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }

  // Basic glTF adders: basic memory buffer/image type fields
  // Scenegraph specific adders are placed in glTFBuilder
  // TODO: These should be moved to glTFBuilder once addBuffer
  // have been rewritten to not depend on these.

  // Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
  addBufferView(buffer) {
    const byteLength = buffer.byteLength || buffer.length;

    // Add a bufferView indicating start and length of this binary sub-chunk
    this.json.bufferViews.push({
      buffer: 0,
      // Write offset from the start of the binary body
      byteOffset: this.byteLength,
      byteLength
    });

    // We've now written the contents to the body, so update the total length
    // Every sub-chunk needs to be 4-byte aligned
    this.byteLength += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(byteLength);

    // Add this buffer to the list of buffers to be written to the body.
    this.sourceBuffers.push(buffer);

    // Return the index to the just created bufferView
    return this.json.bufferViews.length - 1;
  }

  // Adds an accessor to a bufferView
  addAccessor(bufferViewIndex, accessor) {
    // Add an accessor pointing to the new buffer view
    this.json.accessors.push({
      bufferView: bufferViewIndex,
      type: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_2__["getAccessorTypeFromSize"])(accessor.size),
      componentType: accessor.componentType,
      count: accessor.count
    });

    return this.json.accessors.length - 1;
  }

  // PRIVATE

  // For testing
  _pack() {
    this._packBinaryChunk();
    return {arrayBuffer: this.arrayBuffer, json: this.json};
  }

  // Pack the binary chunk
  _packBinaryChunk() {
    // Already packed
    if (this.arrayBuffer) {
      return;
    }

    // Allocate total array
    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);

    // Copy each array into
    let dstByteOffset = 0;
    for (let i = 0; i < this.sourceBuffers.length; i++) {
      const sourceBuffer = this.sourceBuffers[i];
      dstByteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyToArray"])(sourceBuffer, targetArray, dstByteOffset);
    }

    // Update the glTF BIN CHUNK byte length
    this.json.buffers[0].byteLength = totalByteLength;

    // Save generated arrayBuffer
    this.arrayBuffer = arrayBuffer;

    // Clear out sourceBuffers
    this.sourceBuffers = [];
  }

  // Report internal buffer sizes for debug and testing purposes
  _getInternalCounts() {
    return {
      buffers: this.json.buffers.length,
      bufferViews: this.json.bufferViews.length,
      accessors: this.json.accessors.length,
      images: this.json.images.length
    };
  }
}


/***/ }),

/***/ "./src/lib/encode-glb.js":
/*!*******************************!*\
  !*** ./src/lib/encode-glb.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return encodeGLBSync; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* eslint-disable camelcase, max-statements */


const MAGIC_glTF = 0x46546c67; // glTF in ASCII
const MAGIC_JSON = 0x4e4f534a; // JSON in ASCII
const MAGIC_BIN = 0x004e4942; // BIN\0 in ASCII

const LE = true; // Binary GLTF is little endian.

// Encode the full GLB buffer with header etc
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#
// glb-file-format-specification
function encodeGLBSync(glb, dataView, byteOffset = 0, options = {}) {
  const {magic = MAGIC_glTF, version = 2, json = {}, binary} = glb;

  const byteOffsetStart = byteOffset;

  // Write GLB Header
  if (dataView) {
    dataView.setUint32(byteOffset + 0, magic, LE); // Magic number (the ASCII string 'glTF').
    dataView.setUint32(byteOffset + 4, version, LE); // Version 2 of binary glTF container format uint32
    dataView.setUint32(byteOffset + 8, 0, LE); // Total byte length of generated file (uint32), will be set last
  }
  const byteOffsetFileLength = byteOffset + 8;
  byteOffset += 12; // GLB_FILE_HEADER_SIZE

  // Write the JSON chunk header
  const byteOffsetJsonHeader = byteOffset;
  if (dataView) {
    dataView.setUint32(byteOffset + 0, 0, LE); // Byte length of json chunk (will be written later)
    dataView.setUint32(byteOffset + 4, MAGIC_JSON, LE); // Chunk type
  }
  byteOffset += 8; // GLB_CHUNK_HEADER_SIZE

  // Write the JSON chunk
  const jsonString = JSON.stringify(json);
  byteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyPaddedStringToDataView"])(dataView, byteOffset, jsonString);

  // Now we know the JSON chunk length so we can write it.
  if (dataView) {
    const jsonByteLength = byteOffset - byteOffsetJsonHeader - 8; // GLB_CHUNK_HEADER_SIZE
    dataView.setUint32(byteOffsetJsonHeader + 0, jsonByteLength, LE); // Byte length of json chunk (uint32)
  }

  // Write the BIN chunk if present. The BIN chunk is optional.
  if (binary) {
    const byteOffsetBinHeader = byteOffset;

    // Write the BIN chunk header
    if (dataView) {
      dataView.setUint32(byteOffset + 0, 0, LE); // Byte length BIN (uint32)
      dataView.setUint32(byteOffset + 4, MAGIC_BIN, LE); // Chunk type
    }
    byteOffset += 8; // GLB_CHUNK_HEADER_SIZE

    byteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["copyPaddedArrayBufferToDataView"])(dataView, byteOffset, binary);

    // Now we know the BIN chunk length so we can write it.
    if (dataView) {
      const binByteLength = byteOffset - byteOffsetBinHeader - 8; // GLB_CHUNK_HEADER_SIZE
      dataView.setUint32(byteOffsetBinHeader + 0, binByteLength, LE); // Byte length BIN (uint32)
    }
  }

  // Now we know the glb file length so we can write it.
  if (dataView) {
    const fileByteLength = byteOffset - byteOffsetStart;
    dataView.setUint32(byteOffsetFileLength, fileByteLength, LE); // Total byte length of generated file (uint32)
  }

  return byteOffset;
}


/***/ }),

/***/ "./src/lib/encode-gltf.js":
/*!********************************!*\
  !*** ./src/lib/encode-gltf.js ***!
  \********************************/
/*! exports provided: encodeGLTFSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeGLTFSync", function() { return encodeGLTFSync; });
/* harmony import */ var _encode_glb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode-glb */ "./src/lib/encode-glb.js");


// Encode the full glTF file as a binary GLB file
// Returns an ArrayBuffer that represents the complete GLB image that can be saved to file
//
// TODO - Does not support encoding to non-GLB versions of glTF format
// - Encode as a textual JSON file with binary data in base64 data URLs.
// - Encode as a JSON with all images (and buffers?) in separate binary files
//
// glb-file-format-specification
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#

function encodeGLTFSync(gltf, arrayBuffer, byteOffset, options) {
  convertBuffersToBase64(gltf);

  // TODO: Copy buffers to binary

  return Object(_encode_glb__WEBPACK_IMPORTED_MODULE_0__["default"])(gltf, arrayBuffer, byteOffset, options);
}

function convertBuffersToBase64(gltf, {firstBuffer = 0} = {}) {
  if (gltf.buffers && gltf.buffers.length > firstBuffer) {
    throw new Error('encodeGLTF: multiple buffers not yet implemented');
  }
}


/***/ }),

/***/ "./src/lib/extensions/KHR_binary_gltf.js":
/*!***********************************************!*\
  !*** ./src/lib/extensions/KHR_binary_gltf.js ***!
  \***********************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gltf-scenegraph */ "./src/lib/gltf-scenegraph.js");
/* harmony import */ var _gltf_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-constants */ "./src/lib/gltf-constants.js");
// GLTF 1.0 EXTENSION: KHR_binary_glTF
// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF




function decode(gltfData, options) {
  const gltfScenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
  const {json} = gltfScenegraph;

  // Note: json.buffers.binary_glTF also needs to be replaced
  // This is currently done during gltf normalization

  // Image and shader nodes can have the extension
  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/image.KHR_binary_glTF.schema.json
  for (const node of json.images || []) {
    const extension = gltfScenegraph.removeObjectExtension(node, _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_BINARY_GLTF"]);
    // The data in the extension is valid as glTF 2.0 data inside the object, so just copy it in
    if (extension) {
      Object.assign(node, extension);
    }
  }

  // TODO shaders
  // https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Khronos/KHR_binary_glTF/schema/shader.KHR_binary_glTF.schema.json

  // glTF v1 one files have a partially formed URI field that is not expected in (and causes problems in) 2.0
  if (json.buffers && json.buffers[0]) {
    delete json.buffers[0].uri;
  }

  // Remove the top-level extension as it has now been removed from all nodes
  gltfScenegraph.removeExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_BINARY_GLTF"]);
}

// KHR_binary_gltf is a 1.0 extension that is supported natively by 2.0
function encode(gltfData, options) {
  throw new Error(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_BINARY_GLTF"]);
}


/***/ }),

/***/ "./src/lib/extensions/KHR_draco_mesh_compression.js":
/*!**********************************************************!*\
  !*** ./src/lib/extensions/KHR_draco_mesh_compression.js ***!
  \**********************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _loaders_gl_draco__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/draco */ "../draco/src/index.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gltf-scenegraph */ "./src/lib/gltf-scenegraph.js");
/* harmony import */ var _gltf_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../gltf-constants */ "./src/lib/gltf-constants.js");
/* harmony import */ var _gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../gltf-utils/gltf-attribute-utils */ "./src/lib/gltf-utils/gltf-attribute-utils.js");
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported

/* eslint-disable camelcase */







// Note: We have a "soft dependency" on Draco to avoid bundling it when not needed
async function decode(gltfData, options, context) {
  if (!options.gltf.decompressMeshes) {
    return;
  }

  const scenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_2__["default"](gltfData);
  const promises = [];
  for (const primitive of makeMeshPrimitiveIterator(scenegraph)) {
    if (scenegraph.getObjectExtension(primitive, _gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"])) {
      promises.push(decompressPrimitive(primitive, scenegraph, options, context));
    }
  }

  // Decompress meshes in parallel
  await Promise.all(promises);

  // We have now decompressed all primitives, so remove the top-level extensions
  scenegraph.removeExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]);
}

function encode(gltfData, options = {}) {
  const scenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_2__["default"](gltfData);

  for (const mesh of scenegraph.json.meshes || []) {
    // eslint-disable-next-line camelcase
    compressMesh(mesh, options);
    // NOTE: Only add the extension if something was actually compressed
    scenegraph.addRequiredExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]);
  }
}

// DECODE

// Unpacks one mesh primitive and removes the extension from the primitive
// DracoDecoder needs to be imported and registered by app
// Returns: Promise that resolves when all pending draco decoder jobs for this mesh complete

// TODO - Implement fallback behavior per KHR_DRACO_MESH_COMPRESSION spec

async function decompressPrimitive(primitive, scenegraph, options, context) {
  const compressedPrimitive = scenegraph.getObjectExtension(primitive, _gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]);

  const buffer = scenegraph.getTypedArrayForBufferView(compressedPrimitive.bufferView);
  // TODO - parse does not yet deal well with byte offsets embedded in typed arrays. Copy buffer
  // TODO - remove when `parse` is fixed to handle `byteOffset`s
  const bufferCopy = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["getZeroOffsetArrayBuffer"])(buffer.buffer, buffer.byteOffset); // , buffer.byteLength);

  // this will generate an exception if DracoLoader is not installed
  const {parse} = context;
  const decodedData = await parse(bufferCopy, _loaders_gl_draco__WEBPACK_IMPORTED_MODULE_0__["DracoLoader"], options, context);

  primitive.attributes = Object(_gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_4__["getGLTFAccessors"])(decodedData.attributes);
  if (decodedData.indices) {
    primitive.indices = Object(_gltf_utils_gltf_attribute_utils__WEBPACK_IMPORTED_MODULE_4__["getGLTFAccessor"])(decodedData.indices);
  }

  // Extension has been processed, delete it
  // delete primitive.extensions[KHR_DRACO_MESH_COMPRESSION];

  checkPrimitive(primitive);
}

// ENCODE

// eslint-disable-next-line max-len
// Only TRIANGLES: 0x0004 and TRIANGLE_STRIP: 0x0005 are supported
function compressMesh(attributes, indices, mode = 4, options, context) {
  if (!options.DracoWriter || !options.DracoLoader) {
    throw new Error('DracoWriter/DracoLoader not available');
  }

  // TODO - use DracoWriter using encode w/ registered DracoWriter...
  const compressedData = options.DracoWriter.encodeSync({attributes});

  // Draco compression may change the order and number of vertices in a mesh.
  // To satisfy the requirement that accessors properties be correct for both
  // compressed and uncompressed data, generators should create uncompressed
  // attributes and indices using data that has been decompressed from the Draco buffer,
  // rather than the original source data.
  const {parseSync} = context;
  const decodedData = parseSync({attributes});
  const fauxAccessors = options._addFauxAttributes(decodedData.attributes);

  const bufferViewIndex = options.addBufferView(compressedData);

  const glTFMesh = {
    primitives: [
      {
        attributes: fauxAccessors, // TODO - verify with spec
        mode, // GL.POINTS
        extensions: {
          [_gltf_constants__WEBPACK_IMPORTED_MODULE_3__["KHR_DRACO_MESH_COMPRESSION"]]: {
            bufferView: bufferViewIndex,
            attributes: fauxAccessors // TODO - verify with spec
          }
        }
      }
    ]
  };

  return glTFMesh;
}

// UTILS

function checkPrimitive(primitive) {
  if (!primitive.attributes && Object.keys(primitive.attributes).length > 0) {
    throw new Error('Empty glTF primitive detected: Draco decompression failure?');
  }
}

function* makeMeshPrimitiveIterator(scenegraph) {
  for (const mesh of scenegraph.json.meshes || []) {
    for (const primitive of mesh.primitives) {
      yield primitive;
    }
  }
}


/***/ }),

/***/ "./src/lib/extensions/KHR_lights_punctual.js":
/*!***************************************************!*\
  !*** ./src/lib/extensions/KHR_lights_punctual.js ***!
  \***************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-scenegraph */ "./src/lib/gltf-scenegraph.js");
/* harmony import */ var _gltf_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../gltf-constants */ "./src/lib/gltf-constants.js");
// GLTF EXTENSION: KHR_lights_punctual
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual





function decode(gltfData, options) {
  const gltfScenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_1__["default"](gltfData);
  const {json} = gltfScenegraph;

  // Move the light array out of the extension and remove the extension
  const extension = gltfScenegraph.getExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);
  if (extension) {
    // @ts-ignore
    gltfScenegraph.json.lights = extension.lights;
    gltfScenegraph.removeExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);
  }

  // Any nodes that have the extension, add lights field pointing to light object
  // and remove the extension
  for (const node of json.nodes || []) {
    const nodeExtension = gltfScenegraph.getObjectExtension(node, _gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);
    if (nodeExtension) {
      // @ts-ignore
      node.light = nodeExtension.light;
    }
    gltfScenegraph.removeObjectExtension(node, _gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);
  }
}

// Move the light ar ray out of the extension and remove the extension
function encode(gltfData, options) {
  const gltfScenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_1__["default"](gltfData);
  const {json} = gltfScenegraph;

  if (json.lights) {
    const extension = gltfScenegraph.addExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"]);
    // @ts-ignore
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(!extension.lights);
    // @ts-ignore
    extension.lights = json.lights;
    delete json.lights;
  }

  // Any nodes that have lights field pointing to light object
  // add the extension
  if (gltfScenegraph.json.lights) {
    for (const light of gltfScenegraph.json.lights) {
      const node = light.node;
      gltfScenegraph.addObjectExtension(node, _gltf_constants__WEBPACK_IMPORTED_MODULE_2__["KHR_LIGHTS_PUNCTUAL"], light);
    }
    delete gltfScenegraph.json.lights;
  }
}


/***/ }),

/***/ "./src/lib/extensions/KHR_materials_unlit.js":
/*!***************************************************!*\
  !*** ./src/lib/extensions/KHR_materials_unlit.js ***!
  \***************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gltf-scenegraph */ "./src/lib/gltf-scenegraph.js");
/* harmony import */ var _gltf_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-constants */ "./src/lib/gltf-constants.js");
// GLTF EXTENSION: KHR_materials_unlit
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit




function decode(gltfData, options) {
  const gltfScenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
  const {json} = gltfScenegraph;

  // Remove the top-level extension
  gltfScenegraph.removeExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_MATERIALS_UNLIT"]);

  // Any nodes that have the extension, add lights field pointing to light object
  // and remove the extension
  for (const material of json.materials || []) {
    const extension = material.extensions && material.extensions.KHR_materials_unlit;
    if (extension) {
      material.unlit = true;
    }
    gltfScenegraph.removeObjectExtension(material, _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_MATERIALS_UNLIT"]);
  }
}

function encode(gltfData, options) {
  const gltfScenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
  const {json} = gltfScenegraph;

  // Any nodes that have lights field pointing to light object
  // add the extension
  // @ts-ignore
  if (gltfScenegraph.materials) {
    for (const material of json.materials) {
      if (material.unlit) {
        delete material.unlit;
        gltfScenegraph.addObjectExtension(material, _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_MATERIALS_UNLIT"], {});
        gltfScenegraph.addExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_MATERIALS_UNLIT"]);
      }
    }
  }
}


/***/ }),

/***/ "./src/lib/extensions/KHR_techniques_webgl.js":
/*!****************************************************!*\
  !*** ./src/lib/extensions/KHR_techniques_webgl.js ***!
  \****************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../gltf-scenegraph */ "./src/lib/gltf-scenegraph.js");
/* harmony import */ var _gltf_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../gltf-constants */ "./src/lib/gltf-constants.js");
// GLTF EXTENSION: KHR_techniques_webgl
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_techniques_webgl
/* global TextDecoder */



function decode(gltfData, options) {
  const gltfScenegraph = new _gltf_scenegraph__WEBPACK_IMPORTED_MODULE_0__["default"](gltfData);
  const {json} = gltfScenegraph;

  const extension = gltfScenegraph.getExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_TECHNIQUES_WEBGL"]);
  if (extension) {
    const techniques = resolveTechniques(extension, gltfScenegraph);

    for (const material of json.materials || []) {
      const materialExtension = gltfScenegraph.getObjectExtension(material, _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_TECHNIQUES_WEBGL"]);
      if (materialExtension) {
        material.technique = Object.assign(
          {},
          materialExtension,
          // @ts-ignore
          techniques[materialExtension.technique]
        );
        material.technique.values = resolveValues(material.technique, gltfScenegraph);
      }
      gltfScenegraph.removeObjectExtension(material, _gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_TECHNIQUES_WEBGL"]);
    }

    gltfScenegraph.removeExtension(_gltf_constants__WEBPACK_IMPORTED_MODULE_1__["KHR_TECHNIQUES_WEBGL"]);
  }
}

function encode(gltfData, options) {
  // TODO
}

function resolveTechniques({programs = [], shaders = [], techniques = []}, gltfScenegraph) {
  const textDecoder = new TextDecoder();

  shaders.forEach(shader => {
    if (Number.isFinite(shader.bufferView)) {
      shader.code = textDecoder.decode(
        gltfScenegraph.getTypedArrayForBufferView(shader.bufferView)
      );
    } else {
      // TODO: handle URI shader
      throw new Error('KHR_techniques_webgl: no shader code');
    }
  });

  programs.forEach(program => {
    program.fragmentShader = shaders[program.fragmentShader];
    program.vertexShader = shaders[program.vertexShader];
  });

  techniques.forEach(technique => {
    technique.program = programs[technique.program];
  });

  return techniques;
}

function resolveValues(technique, gltfScenegraph) {
  const values = Object.assign({}, technique.values);

  // merge values from uniforms
  Object.keys(technique.uniforms || {}).forEach(uniform => {
    if (technique.uniforms[uniform].value && !(uniform in values)) {
      values[uniform] = technique.uniforms[uniform].value;
    }
  });

  // resolve textures
  Object.keys(values).forEach(uniform => {
    if (typeof values[uniform] === 'object' && values[uniform].index !== undefined) {
      // Assume this is a texture
      // TODO: find if there are any other types that can be referenced
      values[uniform].texture = gltfScenegraph.getTexture(values[uniform].index);
    }
  });

  return values;
}


/***/ }),

/***/ "./src/lib/extensions/gltf-extensions.js":
/*!***********************************************!*\
  !*** ./src/lib/extensions/gltf-extensions.js ***!
  \***********************************************/
/*! exports provided: EXTENSIONS, decodeExtensions */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EXTENSIONS", function() { return EXTENSIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeExtensions", function() { return decodeExtensions; });
/* harmony import */ var _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KHR_draco_mesh_compression */ "./src/lib/extensions/KHR_draco_mesh_compression.js");
/* harmony import */ var _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KHR_lights_punctual */ "./src/lib/extensions/KHR_lights_punctual.js");
/* harmony import */ var _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./KHR_materials_unlit */ "./src/lib/extensions/KHR_materials_unlit.js");
/* harmony import */ var _KHR_techniques_webgl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./KHR_techniques_webgl */ "./src/lib/extensions/KHR_techniques_webgl.js");
/* eslint-disable camelcase */

// GLTF 1.0 extensions (read only)
// Note: KHR_binary_gltf needs to be processed before other loading starts
// import * as KHR_binary_gltf from './KHR_draco_mesh_compression';

// GLTF 2.0 extensions (read/write)





// other extensions
// import UBER_POINT_CLOUD_COMPRESSION from './KHR_draco_mesh_compression';

const EXTENSIONS = {
  // 1.0
  // KHR_binary_gltf,

  // 2.0
  KHR_draco_mesh_compression: _KHR_draco_mesh_compression__WEBPACK_IMPORTED_MODULE_0__,
  KHR_lights_punctual: _KHR_lights_punctual__WEBPACK_IMPORTED_MODULE_1__,
  KHR_materials_unlit: _KHR_materials_unlit__WEBPACK_IMPORTED_MODULE_2__,
  KHR_techniques_webgl: _KHR_techniques_webgl__WEBPACK_IMPORTED_MODULE_3__
};

async function decodeExtensions(gltf, options = {}, context) {
  options.gltf = options.gltf || {};
  for (const extensionName in EXTENSIONS) {
    const excludes = options.gltf.excludeExtensions || {};
    const exclude = extensionName in excludes && !excludes[extensionName];
    if (!exclude) {
      const extension = EXTENSIONS[extensionName];
      // Note: We decode async extensions sequentially, this might not be necessary
      // Currently we only have Draco, but when we add Basis we may revisit
      await extension.decode(gltf, options, context);
    }
  }
}


/***/ }),

/***/ "./src/lib/gltf-constants.js":
/*!***********************************!*\
  !*** ./src/lib/gltf-constants.js ***!
  \***********************************/
/*! exports provided: KHR_BINARY_GLTF, KHR_DRACO_MESH_COMPRESSION, KHR_LIGHTS_PUNCTUAL, KHR_MATERIALS_UNLIT, KHR_TECHNIQUES_WEBGL, UBER_POINT_CLOUD_EXTENSION, getBytesFromComponentType, getSizeFromAccessorType, getGLEnumFromSamplerParameter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_BINARY_GLTF", function() { return KHR_BINARY_GLTF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_DRACO_MESH_COMPRESSION", function() { return KHR_DRACO_MESH_COMPRESSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_LIGHTS_PUNCTUAL", function() { return KHR_LIGHTS_PUNCTUAL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_MATERIALS_UNLIT", function() { return KHR_MATERIALS_UNLIT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KHR_TECHNIQUES_WEBGL", function() { return KHR_TECHNIQUES_WEBGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UBER_POINT_CLOUD_EXTENSION", function() { return UBER_POINT_CLOUD_EXTENSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBytesFromComponentType", function() { return getBytesFromComponentType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSizeFromAccessorType", function() { return getSizeFromAccessorType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLEnumFromSamplerParameter", function() { return getGLEnumFromSamplerParameter; });
// GLTF 1.0 extensions
const KHR_BINARY_GLTF = 'KHR_binary_glTF';

// GLTF 2.0 extensions
const KHR_DRACO_MESH_COMPRESSION = 'KHR_draco_mesh_compression';
const KHR_LIGHTS_PUNCTUAL = 'KHR_lights_punctual';
const KHR_MATERIALS_UNLIT = 'KHR_materials_unlit';
const KHR_TECHNIQUES_WEBGL = 'KHR_techniques_webgl';

// Ideally we should just use KHR_draco_mesh_compression, but it does not support point clouds
const UBER_POINT_CLOUD_EXTENSION = 'UBER_draco_point_cloud_compression';

const COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};

const BYTES = {
  5120: 1, // BYTE
  5121: 1, // UNSIGNED_BYTE
  5122: 2, // SHORT
  5123: 2, // UNSIGNED_SHORT
  5125: 4, // UNSIGNED_INT
  5126: 4 // FLOAT
};

// ENUM LOOKUP

function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}

function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}

function getGLEnumFromSamplerParameter(parameter) {
  const GL_TEXTURE_MAG_FILTER = 0x2800;
  const GL_TEXTURE_MIN_FILTER = 0x2801;
  const GL_TEXTURE_WRAP_S = 0x2802;
  const GL_TEXTURE_WRAP_T = 0x2803;

  const PARAMETER_MAP = {
    magFilter: GL_TEXTURE_MAG_FILTER,
    minFilter: GL_TEXTURE_MIN_FILTER,
    wrapS: GL_TEXTURE_WRAP_S,
    wrapT: GL_TEXTURE_WRAP_T
  };

  return PARAMETER_MAP[parameter];
}


/***/ }),

/***/ "./src/lib/gltf-scenegraph.js":
/*!************************************!*\
  !*** ./src/lib/gltf-scenegraph.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GLTFScenegraph; });
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/images */ "../images/src/index.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");





// Class for structured access to GLTF data
class GLTFScenegraph {
  // eslint-disable-next-line consistent-return
  constructor(gltf) {
    // Signature: new GLTFScenegraph(data : GLTFScenegraph)
    // Allow creation of a `GLTFScenegraph` object from gltf data without checking if already a `GLTFScenegraph`
    if (gltf instanceof GLTFScenegraph) {
      return gltf;
    }

    if (!gltf) {
      gltf = {
        json: {
          asset: {
            version: '2.0',
            generator: 'loaders.gl'
          },
          buffers: []
        },
        buffers: []
      };
    }

    this.byteLength = 0;
    // TODO - this is too sloppy, define inputs more clearly
    this.gltf = gltf;
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(this.gltf.json);
  }

  // Accessors

  get json() {
    return this.gltf.json;
  }

  getApplicationData(key) {
    // TODO - Data is already unpacked by GLBParser
    const data = this.json[key];
    return data;
  }

  getExtraData(key) {
    // TODO - Data is already unpacked by GLBParser
    const extras = this.json.extras || {};
    return extras[key];
  }

  getExtension(extensionName) {
    const isExtension = this.getUsedExtensions().find(name => name === extensionName);
    const extensions = this.json.extensions || {};
    return isExtension ? extensions[extensionName] || true : null;
  }

  getRequiredExtension(extensionName) {
    const isRequired = this.getRequiredExtensions().find(name => name === extensionName);
    return isRequired ? this.getExtension(extensionName) : null;
  }

  getRequiredExtensions() {
    return this.json.extensionsRequired || [];
  }

  getUsedExtensions() {
    return this.json.extensionsUsed || [];
  }

  getObjectExtension(object, extensionName) {
    const extensions = object.extensions || {};
    return extensions[extensionName];
  }

  getScene(index) {
    return this.getObject('scenes', index);
  }

  getNode(index) {
    return this.getObject('nodes', index);
  }

  getSkin(index) {
    return this.getObject('skins', index);
  }

  getMesh(index) {
    return this.getObject('meshes', index);
  }

  getMaterial(index) {
    return this.getObject('materials', index);
  }

  getAccessor(index) {
    return this.getObject('accessors', index);
  }

  getCamera(index) {
    return null; // TODO: fix this
  }

  getTexture(index) {
    return this.getObject('textures', index);
  }

  getSampler(index) {
    return this.getObject('samplers', index);
  }

  getImage(index) {
    return this.getObject('images', index);
  }

  getBufferView(index) {
    return this.getObject('bufferViews', index);
  }

  getBuffer(index) {
    return this.getObject('buffers', index);
  }

  getObject(array, index) {
    // check if already resolved
    if (typeof index === 'object') {
      return index;
    }
    const object = this.json[array] && this.json[array][index];
    if (!object) {
      throw new Error(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line
    }
    return object;
  }

  // accepts buffer view index or buffer view object
  // returns a `Uint8Array`
  getTypedArrayForBufferView(bufferView) {
    bufferView = this.getBufferView(bufferView);
    const bufferIndex = bufferView.buffer;

    // Get hold of the arrayBuffer
    // const buffer = this.getBuffer(bufferIndex);
    const binChunk = this.gltf.buffers[bufferIndex];
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(binChunk);

    const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
    return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
  }

  // accepts accessor index or accessor object
  // returns a typed array with type that matches the types
  getTypedArrayForAccessor(accessor) {
    accessor = this.getAccessor(accessor);
    const bufferView = this.getBufferView(accessor.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;

    // Create a new typed array as a view into the combined buffer
    const {ArrayType, length} = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_3__["getAccessorArrayTypeAndLength"])(accessor, bufferView);
    const byteOffset = bufferView.byteOffset + accessor.byteOffset;
    return new ArrayType(arrayBuffer, byteOffset, length);
  }

  // accepts accessor index or accessor object
  // returns a `Uint8Array`
  getTypedArrayForImageData(image) {
    image = this.getAccessor(image);
    const bufferView = this.getBufferView(image.bufferView);
    const buffer = this.getBuffer(bufferView.buffer);
    const arrayBuffer = buffer.data;

    const byteOffset = bufferView.byteOffset || 0;
    return new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
  }

  // MODIFERS

  // Add an extra application-defined key to the top-level data structure
  addApplicationData(key, data) {
    this.json[key] = data;
    return this;
  }

  // `extras` - Standard GLTF field for storing application specific data
  addExtraData(key, data) {
    this.json.extras = this.json.extras || {};
    this.json.extras[key] = data;
    return this;
  }

  addObjectExtension(object, extensionName, data) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(data);
    object.extensions = object.extensions || {};
    // TODO - clobber or merge?
    object.extensions[extensionName] = data;
    this.registerUsedExtension(extensionName);
    return this;
  }

  setObjectExtension(object, extensionName, data) {
    const extensions = object.extensions || {};
    extensions[extensionName] = data;
    // TODO - add to usedExtensions...
  }

  removeObjectExtension(object, extensionName) {
    const extensions = object.extensions || {};
    const extension = extensions[extensionName];
    delete extensions[extensionName];
    return extension;
  }

  // Add to standard GLTF top level extension object, mark as used
  addExtension(extensionName, extensionData = {}) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(extensionData);
    this.json.extensions = this.json.extensions || {};
    this.json.extensions[extensionName] = extensionData;
    this.registerUsedExtension(extensionName);
    return extensionData;
  }

  // Standard GLTF top level extension object, mark as used and required
  addRequiredExtension(extensionName, extensionData = {}) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(extensionData);
    this.addExtension(extensionName, extensionData);
    this.registerRequiredExtension(extensionName);
    return extensionData;
  }

  // Add extensionName to list of used extensions
  registerUsedExtension(extensionName) {
    this.json.extensionsUsed = this.json.extensionsUsed || [];
    if (!this.json.extensionsUsed.find(ext => ext === extensionName)) {
      this.json.extensionsUsed.push(extensionName);
    }
  }

  // Add extensionName to list of required extensions
  registerRequiredExtension(extensionName) {
    this.registerUsedExtension(extensionName);
    this.json.extensionsRequired = this.json.extensionsRequired || [];
    if (!this.json.extensionsRequired.find(ext => ext === extensionName)) {
      this.json.extensionsRequired.push(extensionName);
    }
  }

  // Removes an extension from the top-level list
  removeExtension(extensionName) {
    if (this.json.extensionsRequired) {
      this._removeStringFromArray(this.json.extensionsRequired, extensionName);
    }
    if (this.json.extensionsUsed) {
      this._removeStringFromArray(this.json.extensionsUsed, extensionName);
    }
    if (this.json.extensions) {
      delete this.json.extensions[extensionName];
    }
  }

  addMesh(attributes, indices, mode = 4) {
    // @ts-ignore
    const accessors = this._addAttributes(attributes);

    const glTFMesh = {
      primitives: [
        {
          attributes: accessors,
          indices,
          mode
        }
      ]
    };

    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  addPointCloud(attributes) {
    // @ts-ignore
    const accessorIndices = this._addAttributes(attributes);

    const glTFMesh = {
      primitives: [
        {
          attributes: accessorIndices,
          mode: 0 // GL.POINTS
        }
      ]
    };

    this.json.meshes = this.json.meshes || [];
    this.json.meshes.push(glTFMesh);
    return this.json.meshes.length - 1;
  }

  // Adds a binary image. Builds glTF "JSON metadata" and saves buffer reference
  // Buffer will be copied into BIN chunk during "pack"
  // Currently encodes as glTF image
  addImage(imageData, mimeType) {
    // If image is referencing a bufferView instead of URI, mimeType must be defined:
    //   https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#images
    //   "a reference to a bufferView; in that case mimeType must be defined."
    mimeType = mimeType || Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__["getBinaryImageMIMEType"])(imageData);

    const bufferViewIndex = this.addBufferView(imageData);

    const glTFImage = {
      bufferView: bufferViewIndex,
      mimeType
    };

    this.json.images = this.json.images || [];
    this.json.images.push(glTFImage);
    return this.json.images.length - 1;
  }

  // Add one untyped source buffer, create a matching glTF `bufferView`, and return its index
  addBufferView(buffer) {
    const byteLength = buffer.byteLength;
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(Number.isFinite(byteLength));

    // Add this buffer to the list of buffers to be written to the body.
    this.sourceBuffers = this.sourceBuffers || [];
    this.sourceBuffers.push(buffer);

    const glTFBufferView = {
      buffer: 0,
      // Write offset from the start of the binary body
      byteOffset: this.byteLength,
      byteLength
    };

    // We've now added the contents to the body, so update the total length
    // Every sub-chunk needs to be 4-byte align ed
    this.byteLength += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["padTo4Bytes"])(byteLength);

    // Add a bufferView indicating start and length of this binary sub-chunk
    this.json.bufferViews = this.json.bufferViews || [];
    this.json.bufferViews.push(glTFBufferView);
    return this.json.bufferViews.length - 1;
  }

  // Adds an accessor to a bufferView
  addAccessor(bufferViewIndex, accessor) {
    const glTFAccessor = {
      bufferView: bufferViewIndex,
      type: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_3__["getAccessorTypeFromSize"])(accessor.size),
      componentType: accessor.componentType,
      count: accessor.count
    };

    this.json.accessors = this.json.accessors || [];
    this.json.accessors.push(glTFAccessor);
    return this.json.accessors.length - 1;
  }

  // Add a binary buffer. Builds glTF "JSON metadata" and saves buffer reference
  // Buffer will be copied into BIN chunk during "pack"
  // Currently encodes buffers as glTF accessors, but this could be optimized
  addBinaryBuffer(sourceBuffer, accessor = {size: 3}) {
    const bufferViewIndex = this.addBufferView(sourceBuffer);

    const accessorDefaults = {
      size: accessor.size,
      componentType: Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_3__["getComponentTypeFromArray"])(sourceBuffer),
      count: Math.round(sourceBuffer.length / accessor.size)
    };

    return this.addAccessor(bufferViewIndex, Object.assign(accessorDefaults, accessor));
  }

  // Pack the binary chunk
  createBinaryChunk() {
    // Already packed
    if (this.arrayBuffer) {
      return;
    }

    // Allocate total array
    const totalByteLength = this.byteLength;
    const arrayBuffer = new ArrayBuffer(totalByteLength);
    const targetArray = new Uint8Array(arrayBuffer);

    // Copy each array into
    let dstByteOffset = 0;
    for (let i = 0; i < this.sourceBuffers.length; i++) {
      const sourceBuffer = this.sourceBuffers[i];
      dstByteOffset = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["copyToArray"])(sourceBuffer, targetArray, dstByteOffset);
    }

    // Update the glTF BIN CHUNK byte length
    this.json.buffers[0].byteLength = totalByteLength;

    // Save generated arrayBuffer
    this.arrayBuffer = arrayBuffer;

    // Clear out sourceBuffers
    this.sourceBuffers = [];
  }

  // PRIVATE

  _removeStringFromArray(array, string) {
    let found = true;
    while (found) {
      const index = array.indexOf(string);
      if (index > -1) {
        array.splice(index, 1);
      } else {
        found = false;
      }
    }
  }
}


/***/ }),

/***/ "./src/lib/gltf-utils/get-typed-array.js":
/*!***********************************************!*\
  !*** ./src/lib/gltf-utils/get-typed-array.js ***!
  \***********************************************/
/*! exports provided: getTypedArrayForBufferView, getTypedArrayForImageData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypedArrayForBufferView", function() { return getTypedArrayForBufferView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypedArrayForImageData", function() { return getTypedArrayForImageData; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");
// TODO - GLTFScenegraph should use these


// accepts buffer view index or buffer view object
// returns a `Uint8Array`
function getTypedArrayForBufferView(json, buffers, bufferViewIndex) {
  const bufferView = json.bufferViews[bufferViewIndex];
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(bufferView);

  // Get hold of the arrayBuffer
  const bufferIndex = bufferView.buffer;
  const binChunk = buffers[bufferIndex];
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(binChunk);

  const byteOffset = (bufferView.byteOffset || 0) + binChunk.byteOffset;
  return new Uint8Array(binChunk.arrayBuffer, byteOffset, bufferView.byteLength);
}

// accepts accessor index or accessor object
// returns a `Uint8Array`
function getTypedArrayForImageData(json, buffers, imageIndex) {
  const image = json.images[imageIndex];
  const bufferViewIndex = json.bufferViews[image.bufferView];
  return getTypedArrayForBufferView(json, buffers, bufferViewIndex);
}

/*
// accepts accessor index or accessor object
// returns a typed array with type that matches the types
export function getTypedArrayForAccessor(accessor) {
  accessor = this.getAccessor(accessor);
  const bufferView = this.getBufferView(accessor.bufferView);
  const buffer = this.getBuffer(bufferView.buffer);
  const arrayBuffer = buffer.data;

  // Create a new typed array as a view into the combined buffer
  const {ArrayType, length} = getAccessorArrayTypeAndLength(accessor, bufferView);
  const byteOffset = bufferView.byteOffset + accessor.byteOffset;
  return new ArrayType(arrayBuffer, byteOffset, length);
}
*/


/***/ }),

/***/ "./src/lib/gltf-utils/gltf-attribute-utils.js":
/*!****************************************************!*\
  !*** ./src/lib/gltf-utils/gltf-attribute-utils.js ***!
  \****************************************************/
/*! exports provided: getGLTFAccessors, getGLTFAccessor, getGLTFAttribute */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTFAccessors", function() { return getGLTFAccessors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTFAccessor", function() { return getGLTFAccessor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTFAttribute", function() { return getGLTFAttribute; });
/* harmony import */ var _gltf_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");
// TODO - remove


// Returns a fresh attributes object with glTF-standardized attributes names
// Attributes that cannot be identified will not be included
// Removes `indices` if present, as it should be stored separately from the attributes
function getGLTFAccessors(attributes) {
  const accessors = {};
  for (const name in attributes) {
    const attribute = attributes[name];
    if (name !== 'indices') {
      const glTFAccessor = getGLTFAccessor(attribute);
      accessors[name] = glTFAccessor;
    }
  }
  return accessors;
}

// Fix up a single accessor.
// Input: typed array or a partial accessor object
// Return: accessor object
function getGLTFAccessor(attribute, gltfAttributeName) {
  const {buffer, size, count} = getAccessorData(attribute, gltfAttributeName);

  const glTFAccessor = {
    // TODO: Deprecate `value` in favor of bufferView?
    value: buffer,
    size, // Decoded `type` (e.g. SCALAR)

    // glTF Accessor values
    // TODO: Instead of a bufferView index we could have an actual buffer (typed array)
    bufferView: null,
    byteOffset: 0,
    count,
    type: Object(_gltf_utils__WEBPACK_IMPORTED_MODULE_0__["getAccessorTypeFromSize"])(size),
    componentType: Object(_gltf_utils__WEBPACK_IMPORTED_MODULE_0__["getComponentTypeFromArray"])(buffer)
  };

  return glTFAccessor;
}

function getGLTFAttribute(data, gltfAttributeName) {
  return data.attributes[data.glTFAttributeMap[gltfAttributeName]];
}

function getAccessorData(attribute, attributeName) {
  let buffer = attribute;
  let size = 1;
  let count = 0;

  if (attribute && attribute.value) {
    buffer = attribute.value;
    size = attribute.size || 1;
  }

  if (buffer) {
    if (!ArrayBuffer.isView(buffer)) {
      buffer = toTypedArray(buffer, Float32Array);
    }
    count = buffer.length / size;
  }

  return {buffer, size, count};
}

// Convert non-typed arrays to arrays of specified format
function toTypedArray(array, ArrayType, convertTypedArrays = false) {
  if (!array) {
    return null;
  }
  if (Array.isArray(array)) {
    return new ArrayType(array);
  }
  if (convertTypedArrays && !(array instanceof ArrayType)) {
    return new ArrayType(array);
  }
  return array;
}


/***/ }),

/***/ "./src/lib/gltf-utils/gltf-utils.js":
/*!******************************************!*\
  !*** ./src/lib/gltf-utils/gltf-utils.js ***!
  \******************************************/
/*! exports provided: ATTRIBUTE_TYPE_TO_COMPONENTS, ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE, ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY, getAccessorTypeFromSize, getComponentTypeFromArray, getAccessorArrayTypeAndLength */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_TYPE_TO_COMPONENTS", function() { return ATTRIBUTE_TYPE_TO_COMPONENTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE", function() { return ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY", function() { return ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAccessorTypeFromSize", function() { return getAccessorTypeFromSize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComponentTypeFromArray", function() { return getComponentTypeFromArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAccessorArrayTypeAndLength", function() { return getAccessorArrayTypeAndLength; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "./src/lib/utils/assert.js");


const TYPES = ['SCALAR', 'VEC2', 'VEC3', 'VEC4'];

// @ts-ignore
const ARRAY_TO_COMPONENT_TYPE = new Map([
  [Int8Array, 5120],
  [Uint8Array, 5121],
  [Int16Array, 5122],
  [Uint16Array, 5123],
  [Uint32Array, 5125],
  [Float32Array, 5126]
]);

const ATTRIBUTE_TYPE_TO_COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};

const ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE = {
  5120: 1,
  5121: 1,
  5122: 2,
  5123: 2,
  5125: 4,
  5126: 4
};

const ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};

function getAccessorTypeFromSize(size) {
  const type = TYPES[size - 1];
  return type || TYPES[0];
}

function getComponentTypeFromArray(typedArray) {
  const componentType = ARRAY_TO_COMPONENT_TYPE.get(typedArray.constructor);
  if (!componentType) {
    throw new Error('Illegal typed array');
  }
  return componentType;
}

function getAccessorArrayTypeAndLength(accessor, bufferView) {
  const ArrayType = ATTRIBUTE_COMPONENT_TYPE_TO_ARRAY[accessor.componentType];
  const components = ATTRIBUTE_TYPE_TO_COMPONENTS[accessor.type];
  const bytesPerComponent = ATTRIBUTE_COMPONENT_TYPE_TO_BYTE_SIZE[accessor.componentType];
  const length = accessor.count * components;
  const byteLength = accessor.count * components * bytesPerComponent;
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(byteLength >= 0 && byteLength <= bufferView.byteLength);
  return {ArrayType, length, byteLength};
}


/***/ }),

/***/ "./src/lib/gltf-utils/resolve-url.js":
/*!*******************************************!*\
  !*** ./src/lib/gltf-utils/resolve-url.js ***!
  \*******************************************/
/*! exports provided: resolveUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveUrl", function() { return resolveUrl; });
// Resolves a relative url against a baseUrl
// If url is absolute, return it unchanged
function resolveUrl(url, options) {
  // TODO: Use better logic to handle all protocols plus not delay on data
  const absolute = url.startsWith('data:') || url.startsWith('http:') || url.startsWith('https:');
  if (absolute) {
    return url;
  }
  const baseUrl = options.baseUri || options.uri;
  if (!baseUrl) {
    throw new Error(`'baseUri' must be provided to resolve relative url ${url}`);
  }
  return baseUrl.substr(0, baseUrl.lastIndexOf('/') + 1) + url;
}


/***/ }),

/***/ "./src/lib/normalize-gltf-v1.js":
/*!**************************************!*\
  !*** ./src/lib/normalize-gltf-v1.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return normalizeGLTFV1; });
/* harmony import */ var _extensions_KHR_binary_gltf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./extensions/KHR_binary_gltf */ "./src/lib/extensions/KHR_binary_gltf.js");
/* eslint-disable camelcase */


// Binary format changes (mainly implemented by GLBLoader)
// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF

// JSON format changes:
// https://github.com/khronosgroup/gltf/issues/605

// - [x] Top-level JSON objects are arrays now
// - [ ] Removed indirection from animation: sampler now refers directly to accessors, #712
// - [ ] material.parameter.value and technique.parameter.value must be an array, #690
// - [ ] Node can have only one mesh #821
// - [ ] Added reqs on JSON encoding
// - [ ] Added reqs on binary data alignment #802 (comment)

// Additions:
// - [ ] Added accessor.normalized, #691, #706
// - [ ] Added glExtensionsUsed property and 5125 (UNSIGNED_INT) accessor.componentType value, #619
// - [ ] Added extensionsRequired property, #720, #721
// - [ ] Added "STEP" as valid animation.sampler.interpolation value, #712

// Removals:
// - [x] Removed buffer.type, #786, #629
// - [ ] Removed revision number from profile.version, #709
// - [ ] Removed technique.functions.scissor and removed 3089 (SCISSOR_TEST) as a valid value for technique.states.enable, #681
// - [ ] Techniques, programs, and shaders were moved out to KHR_technique_webgl extension.

// Other edits:
// - [x] asset is now required, #642
// - [ ] buffer.byteLength and bufferView.byteLength are now required, #560.
// - [ ] accessor.min and accessor.max are now required, #593, and clarified that the JSON value and binary data must be the same, #628.
// - [ ] Clarified animation.sampler and animation.channel restrictions, #712
// - [ ] skin.inverseBindMatrices is now optional, #461.
// - [ ] Attribute parameters can't have a value defined in the technique or parameter, #563 (comment).
// - [ ] Only TEXCOORD and COLOR attribute semantics can be written in the form [semantic]_[set_index], #563 (comment).
// - [ ] TEXCOORD and COLOR attribute semantics must be written in the form [semantic]_[set_index], e.g., just TEXCOORD should be TEXCOORD_0, and just COLOR should be COLOR_0, #649
// - [ ] camera.perspective.aspectRatio and camera.perspective.yfov must now be > 0, not >= 0, #563 (comment).
// - [ ] Application-specific parameter semantics must start with an underscore, e.g., _TEMPERATURE and _SIMULATION_TIME, #563 (comment).
// - [ ] Properties in technique.parameters must be defined in technique.uniforms or technique.attributes,

// #563 (comment).
// - [ ] technique.parameter.count can only be defined when the semantic is JOINTMATRIX or an application-specific semantic is used. It can never be defined for attribute parameters; only uniforms, d2f6945
// - [ ] technique.parameter.semantic is required when the parameter is an attribute, 28e113d
// - [ ] Mesh-only models are allowed, e.g., without materials, #642
// - [ ] Skeleton hierarchies (nodes containing jointName) must be separated from non-skeleton hierarchies., #647
// - [ ] technique.states.functions.blendColor and technique.states.functions.depthRange parameters now must match WebGL function min/max, #707

const GLTF_ARRAYS = {
  accessors: 'accessor',
  animations: 'animation',
  buffers: 'buffer',
  bufferViews: 'bufferView',
  images: 'image',
  materials: 'material',
  meshes: 'mesh',
  nodes: 'node',
  samplers: 'sampler',
  scenes: 'scene',
  skins: 'skin',
  textures: 'texture'
};

const GLTF_KEYS = {
  accessor: 'accessors',
  animations: 'animation',
  buffer: 'buffers',
  bufferView: 'bufferViews',
  image: 'images',
  material: 'materials',
  mesh: 'meshes',
  node: 'nodes',
  sampler: 'samplers',
  scene: 'scenes',
  skin: 'skins',
  texture: 'textures'
};

/**
 * Converts (normalizes) glTF v1 to v2
 */
class GLTFV1Normalizer {
  constructor(gltf) {
    this.idToIndexMap = {
      animations: {},
      accessors: {},
      buffers: {},
      bufferViews: {},
      images: {},
      materials: {},
      meshes: {},
      nodes: {},
      samplers: {},
      scenes: {},
      skins: {},
      textures: {}
    };
  }

  /**
   * Convert (normalize) glTF < 2.0 to glTF 2.0
   * @param {*} gltf - object with json and binChunks
   * @param {object} options
   * @param {boolean} [options.normalize] Whether to actually normalize
   */
  normalize(gltf, options) {
    this.json = gltf.json;
    const json = gltf.json;

    // Check version
    switch (json.asset && json.asset.version) {
      // We are converting to v2 format. Return if there is nothing to do
      case '2.0':
        return;

      // This class is written to convert 1.0
      case undefined:
      case '1.0':
        break;

      default:
        // eslint-disable-next-line no-undef, no-console
        console.warn(`glTF: Unknown version ${json.asset.version}`);
        return;
    }

    if (!options.normalize) {
      // We are still missing a few conversion tricks, remove once addressed
      throw new Error('glTF v1 is not supported.');
    }

    // eslint-disable-next-line no-undef, no-console
    console.warn('Converting glTF v1 to glTF v2 format. This is experimental and may fail.');

    this._addAsset(json);

    // In glTF2 top-level fields are Arrays not Object maps
    this._convertTopLevelObjectsToArrays(json);

    // Extract bufferView indices for images
    // (this extension needs to be invoked early in the normalization process)
    _extensions_KHR_binary_gltf__WEBPACK_IMPORTED_MODULE_0__["decode"](gltf, options);

    // Convert object references from ids to indices
    this._convertObjectIdsToArrayIndices(json);

    this._updateObjects(json);
  }

  // asset is now required, #642 https://github.com/KhronosGroup/glTF/issues/639
  _addAsset(json) {
    json.asset = json.asset || {};
    // We are normalizing to glTF v2, so change version to "2.0"
    json.asset.version = '2.0';
    json.asset.generator = json.asset.generator || 'Normalized to glTF 2.0 by loaders.gl';
  }

  _convertTopLevelObjectsToArrays(json) {
    // TODO check that all arrays are covered
    for (const arrayName in GLTF_ARRAYS) {
      this._convertTopLevelObjectToArray(json, arrayName);
    }
  }

  /** Convert one top level object to array */
  _convertTopLevelObjectToArray(json, mapName) {
    const objectMap = json[mapName];
    if (!objectMap || Array.isArray(objectMap)) {
      return;
    }

    // Rewrite the top-level field as an array
    json[mapName] = [];
    // Copy the map key into object.id
    for (const id in objectMap) {
      const object = objectMap[id];
      object.id = object.id || id; // Mutates the loaded object
      const index = json[mapName].length;
      json[mapName].push(object);
      this.idToIndexMap[mapName][id] = index;
    }
  }

  /** Go through all objects in all top-level arrays and replace ids with indices */
  _convertObjectIdsToArrayIndices(json) {
    for (const arrayName in GLTF_ARRAYS) {
      this._convertIdsToIndices(json, arrayName);
    }
    if ('scene' in json) {
      json.scene = this._convertIdToIndex(json.scene, 'scene');
    }

    // Convert any index references that are not using array names

    // texture.source (image)
    for (const texture of json.textures) {
      this._convertTextureIds(texture);
    }
    for (const mesh of json.meshes) {
      this._convertMeshIds(mesh);
    }
    for (const node of json.nodes) {
      this._convertNodeIds(node);
    }
    for (const node of json.scenes) {
      this._convertSceneIds(node);
    }
  }

  _convertTextureIds(texture) {
    if (texture.source) {
      texture.source = this._convertIdToIndex(texture.source, 'image');
    }
  }

  _convertMeshIds(mesh) {
    for (const primitive of mesh.primitives) {
      const {attributes, indices, material} = primitive;
      for (const attributeName in attributes) {
        attributes[attributeName] = this._convertIdToIndex(attributes[attributeName], 'accessor');
      }
      if (indices) {
        primitive.indices = this._convertIdToIndex(indices, 'accessor');
      }
      if (material) {
        primitive.material = this._convertIdToIndex(material, 'material');
      }
    }
  }

  _convertNodeIds(node) {
    if (node.children) {
      node.children = node.children.map(child => this._convertIdToIndex(child, 'node'));
    }
  }

  _convertSceneIds(scene) {
    if (scene.nodes) {
      scene.nodes = scene.nodes.map(node => this._convertIdToIndex(node, 'node'));
    }
  }

  /** Go through all objects in a top-level array and replace ids with indices */
  _convertIdsToIndices(json, topLevelArrayName) {
    for (const object of json[topLevelArrayName]) {
      for (const key in object) {
        const id = object[key];
        const index = this._convertIdToIndex(id, key);
        object[key] = index;
      }
    }
  }

  _convertIdToIndex(id, key) {
    const arrayName = GLTF_KEYS[key];
    if (arrayName in this.idToIndexMap) {
      const index = this.idToIndexMap[arrayName][id];
      if (!Number.isFinite(index)) {
        throw new Error(`gltf v1: failed to resolve ${key} with id ${id}`);
      }
      return index;
    }
    return id;
  }

  /**
   *
   * @param {*} json
   */
  _updateObjects(json) {
    for (const buffer of this.json.buffers) {
      // - [x] Removed buffer.type, #786, #629
      delete buffer.type;
    }
  }
}

function normalizeGLTFV1(gltf, options = {}) {
  return new GLTFV1Normalizer().normalize(gltf, options);
}


/***/ }),

/***/ "./src/lib/parse-glb.js":
/*!******************************!*\
  !*** ./src/lib/parse-glb.js ***!
  \******************************/
/*! exports provided: isGLB, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isGLB", function() { return isGLB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseGLBSync; });
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* eslint-disable camelcase, max-statements */
/* global TextDecoder */
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#glb-file-format-specification
// https://github.com/KhronosGroup/glTF/tree/master/extensions/1.0/Khronos/KHR_binary_glTF



const MAGIC_glTF = 0x676c5446; // glTF in Big-Endian ASCII

const GLB_FILE_HEADER_SIZE = 12;
const GLB_CHUNK_HEADER_SIZE = 8;

const GLB_CHUNK_TYPE_JSON = 0x4e4f534a;
const GLB_CHUNK_TYPE_BIN = 0x004e4942;
const GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED = 0; // DEPRECATED - Backward compatibility for old xviz files
const GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED = 1; // DEPRECATED - Backward compatibility for old xviz files

const GLB_V1_CONTENT_FORMAT_JSON = 0x0;

const LE = true; // Binary GLTF is little endian.

function getMagicString(dataView, byteOffset = 0) {
  return `\
${String.fromCharCode(dataView.getUint8(byteOffset + 0))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 1))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 2))}\
${String.fromCharCode(dataView.getUint8(byteOffset + 3))}`;
}

// Check if a data view is a GLB
function isGLB(arrayBuffer, byteOffset = 0, options = {}) {
  const dataView = new DataView(arrayBuffer);
  // Check that GLB Header starts with the magic number
  const {magic = MAGIC_glTF} = options;
  const magic1 = dataView.getUint32(byteOffset, false);
  return magic1 === magic || magic1 === MAGIC_glTF;
}

function parseGLBSync(glb, arrayBuffer, byteOffset = 0, options = {}) {
  // Check that GLB Header starts with the magic number
  const dataView = new DataView(arrayBuffer);

  // Compare format with GLBLoader documentation
  glb.type = getMagicString(dataView, byteOffset + 0);
  glb.version = dataView.getUint32(byteOffset + 4, LE); // Version 2 of binary glTF container format
  const byteLength = dataView.getUint32(byteOffset + 8, LE); // Total byte length of binary file

  // Put less important stuff in a header, to avoid clutter
  glb.header = {
    byteOffset, // Byte offset into the initial arrayBuffer
    byteLength
  };

  // Per spec we must iterate over chunks, ignoring all except JSON and BIN
  glb.json = {};
  glb.binChunks = [];

  byteOffset += GLB_FILE_HEADER_SIZE;

  switch (glb.version) {
    case 1:
      // eslint-disable-next-line
      return parseGLBV1(glb, dataView, byteOffset, (options = {}));
    case 2:
      return parseGLBV2(glb, dataView, byteOffset, (options = {}));
    default:
      throw new Error(`Invalid GLB version ${glb.version}. Only supports v1 and v2.`);
  }
}

function parseGLBV1(glb, dataView, byteOffset, options) {
  // Sanity: ensure file is big enough to hold at least the headers
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);

  // Explanation of GLB structure:
  // https://cloud.githubusercontent.com/assets/3479527/22600725/36b87122-ea55-11e6-9d40-6fd42819fcab.png
  const contentLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk
  const contentFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32
  byteOffset += GLB_CHUNK_HEADER_SIZE;

  // GLB v1 only supports a single chunk type
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(contentFormat === GLB_V1_CONTENT_FORMAT_JSON);

  parseJSONChunk(glb, dataView, byteOffset, contentLength, options);
  // No need to call the function padTo4Bytes() from parseJSONChunk()
  byteOffset += contentLength;
  byteOffset += parseBINChunk(glb, dataView, byteOffset, glb.header.byteLength, options);

  return byteOffset;
}

function parseGLBV2(glb, dataView, byteOffset, options) {
  // Sanity: ensure file is big enough to hold at least the first chunk header
  Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(glb.header.byteLength > GLB_FILE_HEADER_SIZE + GLB_CHUNK_HEADER_SIZE);

  parseGLBChunksSync(glb, dataView, byteOffset, options);

  return byteOffset + glb.header.byteLength;
}

function parseGLBChunksSync(glb, dataView, byteOffset, options) {
  // Iterate as long as there is space left for another chunk header
  while (byteOffset + 8 <= glb.header.byteLength) {
    const chunkLength = dataView.getUint32(byteOffset + 0, LE); // Byte length of chunk
    const chunkFormat = dataView.getUint32(byteOffset + 4, LE); // Chunk format as uint32
    byteOffset += GLB_CHUNK_HEADER_SIZE;

    // Per spec we must iterate over chunks, ignoring all except JSON and BIN
    switch (chunkFormat) {
      case GLB_CHUNK_TYPE_JSON:
        parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);
        break;
      case GLB_CHUNK_TYPE_BIN:
        parseBINChunk(glb, dataView, byteOffset, chunkLength, options);
        break;

      // Backward compatibility for very old xviz files
      case GLB_CHUNK_TYPE_JSON_XVIZ_DEPRECATED:
        if (!options.glb.strict) {
          parseJSONChunk(glb, dataView, byteOffset, chunkLength, options);
        }
        break;
      case GLB_CHUNK_TYPE_BIX_XVIZ_DEPRECATED:
        if (!options.glb.strict) {
          parseBINChunk(glb, dataView, byteOffset, chunkLength, options);
        }
        break;

      default:
        // Ignore, per spec
        // console.warn(`Unknown GLB chunk type`); // eslint-disable-line
        break;
    }

    byteOffset += Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(chunkLength);
  }

  return byteOffset;
}

// Parse a GLB JSON chunk
function parseJSONChunk(glb, dataView, byteOffset, chunkLength, options) {
  // 1. Create a "view" of the binary encoded JSON data inside the GLB
  const jsonChunk = new Uint8Array(dataView.buffer, byteOffset, chunkLength);

  // 2. Decode the JSON binary array into clear text
  const textDecoder = new TextDecoder('utf8');
  const jsonText = textDecoder.decode(jsonChunk);

  // 3. Parse the JSON text into a JavaScript data structure
  glb.json = JSON.parse(jsonText);

  return Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(chunkLength);
}

// Parse a GLB BIN chunk
function parseBINChunk(glb, dataView, byteOffset, chunkLength, options) {
  // Note: BIN chunk can be optional
  glb.header.hasBinChunk = true;
  glb.binChunks.push({
    byteOffset,
    byteLength: chunkLength,
    arrayBuffer: dataView.buffer
    // TODO - copy, or create typed array view?
  });

  return Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_0__["padTo4Bytes"])(chunkLength);
}


/***/ }),

/***/ "./src/lib/parse-gltf.js":
/*!*******************************!*\
  !*** ./src/lib/parse-gltf.js ***!
  \*******************************/
/*! exports provided: isGLTF, parseGLTF */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isGLTF", function() { return isGLTF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseGLTF", function() { return parseGLTF; });
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/images */ "../images/src/index.js");
/* harmony import */ var _loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/loader-utils */ "../loader-utils/src/index.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _gltf_utils_resolve_url__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gltf-utils/resolve-url */ "./src/lib/gltf-utils/resolve-url.js");
/* harmony import */ var _gltf_utils_get_typed_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gltf-utils/get-typed-array */ "./src/lib/gltf-utils/get-typed-array.js");
/* harmony import */ var _extensions_gltf_extensions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extensions/gltf-extensions */ "./src/lib/extensions/gltf-extensions.js");
/* harmony import */ var _parse_glb__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parse-glb */ "./src/lib/parse-glb.js");
/* harmony import */ var _normalize_gltf_v1__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./normalize-gltf-v1 */ "./src/lib/normalize-gltf-v1.js");
/* harmony import */ var _post_process_gltf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./post-process-gltf */ "./src/lib/post-process-gltf.js");
/* eslint-disable camelcase, max-statements, no-restricted-globals */
/* global TextDecoder */










function isGLTF(arrayBuffer, options = {}) {
  const dataView = new DataView(arrayBuffer);
  const byteOffset = 0;
  return Object(_parse_glb__WEBPACK_IMPORTED_MODULE_6__["isGLB"])(dataView, byteOffset);
}

async function parseGLTF(gltf, arrayBufferOrString, byteOffset = 0, options, context) {
  parseGLTFContainerSync(gltf, arrayBufferOrString, byteOffset, options);

  Object(_normalize_gltf_v1__WEBPACK_IMPORTED_MODULE_7__["default"])(gltf, {normalize: options.gltf.normalize});

  /** @type {Promise[]} */
  const promises = [];

  if (options.gltf.loadImages) {
    const promise = loadImages(gltf, options, context);
    promises.push(promise);
  }

  // Load linked buffers asynchronously and decodes base64 buffers in parallel
  if (options.gltf.loadBuffers) {
    await loadBuffers(gltf, options, context);
  }

  const promise = Object(_extensions_gltf_extensions__WEBPACK_IMPORTED_MODULE_5__["decodeExtensions"])(gltf, options, context);
  promises.push(promise);

  // Parallelize image loading and buffer loading/extension decoding
  await Promise.all(promises);

  // Post processing resolves indices to objects, buffers
  return options.gltf.postProcess ? Object(_post_process_gltf__WEBPACK_IMPORTED_MODULE_8__["default"])(gltf, options) : gltf;
}

// `data` - can be ArrayBuffer (GLB), ArrayBuffer (Binary JSON), String (JSON), or Object (parsed JSON)
function parseGLTFContainerSync(gltf, data, byteOffset, options) {
  // Initialize gltf container
  if (options.uri) {
    gltf.baseUri = options.uri;
  }

  // If data is binary and starting with magic bytes, assume binary JSON text, convert to string
  if (data instanceof ArrayBuffer && !Object(_parse_glb__WEBPACK_IMPORTED_MODULE_6__["isGLB"])(data, byteOffset, options)) {
    const textDecoder = new TextDecoder();
    data = textDecoder.decode(data);
  }

  if (typeof data === 'string') {
    // If string, try to parse as JSON
    gltf.json = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["parseJSON"])(data);
  } else if (data instanceof ArrayBuffer) {
    // If still ArrayBuffer, parse as GLB container
    const glb = {};
    byteOffset = Object(_parse_glb__WEBPACK_IMPORTED_MODULE_6__["default"])(glb, data, byteOffset, options);

    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(glb.type === 'glTF', `Invalid GLB magic string ${glb.type}`);

    gltf._glb = glb;
    gltf.json = glb.json;
  } else {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false, `GLTF: must be ArrayBuffer or string`);
  }

  // Populate buffers
  // Create an external buffers array to hold binary data
  const buffers = gltf.json.buffers || [];
  gltf.buffers = new Array(buffers.length).fill(null);

  // Populates JSON and some bin chunk info
  if (gltf._glb && gltf._glb.header.hasBinChunk) {
    const {binChunks} = gltf._glb;
    gltf.buffers[0] = {
      arrayBuffer: binChunks[0].arrayBuffer,
      byteOffset: binChunks[0].byteOffset,
      byteLength: binChunks[0].byteLength
    };

    // TODO - this modifies JSON and is a post processing thing
    // gltf.json.buffers[0].data = gltf.buffers[0].arrayBuffer;
    // gltf.json.buffers[0].byteOffset = gltf.buffers[0].byteOffset;
  }

  // Populate images
  const images = gltf.json.images || [];
  gltf.images = new Array(images.length).fill({});
}

// Asynchronously fetch and parse buffers, store in buffers array outside of json
async function loadBuffers(gltf, options, context) {
  for (let i = 0; i < gltf.json.buffers.length; ++i) {
    const buffer = gltf.json.buffers[i];
    if (buffer.uri) {
      const {fetch} = context;
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(fetch);

      const uri = Object(_gltf_utils_resolve_url__WEBPACK_IMPORTED_MODULE_3__["resolveUrl"])(buffer.uri, options);
      const response = await fetch(uri);
      const arrayBuffer = await response.arrayBuffer();

      gltf.buffers[i] = {
        arrayBuffer,
        byteOffset: 0,
        byteLength: arrayBuffer.byteLength
      };

      delete buffer.uri;
    }
  }
}

async function loadImages(gltf, options, context) {
  const images = gltf.json.images || [];

  const promises = [];
  for (let i = 0; i < images.length; ++i) {
    promises.push(loadImage(gltf, images[i], i, options, context));
  }

  return await Promise.all(promises);
}

// Asynchronously fetches and parses one image, store in images array outside of json
async function loadImage(gltf, image, i, options, context) {
  const {fetch, parse} = context;

  let arrayBuffer;

  if (image.uri) {
    const uri = Object(_gltf_utils_resolve_url__WEBPACK_IMPORTED_MODULE_3__["resolveUrl"])(image.uri, options);
    const response = await fetch(uri);
    arrayBuffer = await response.arrayBuffer();
  }

  if (Number.isFinite(image.bufferView)) {
    const array = Object(_gltf_utils_get_typed_array__WEBPACK_IMPORTED_MODULE_4__["getTypedArrayForBufferView"])(gltf.json, gltf.buffers, image.bufferView);
    arrayBuffer = Object(_loaders_gl_loader_utils__WEBPACK_IMPORTED_MODULE_1__["getZeroOffsetArrayBuffer"])(array.buffer, array.byteOffset, array.byteLength);
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(arrayBuffer, 'glTF image has no data');

  // Call `parse`
  const parsedImage = await parse(arrayBuffer, _loaders_gl_images__WEBPACK_IMPORTED_MODULE_0__["ImageLoader"], {}, context);
  // TODO making sure ImageLoader is overridable by using array of loaders
  // const parsedImage = await parse(arrayBuffer, [ImageLoader]);

  gltf.images[i] = parsedImage;
}


/***/ }),

/***/ "./src/lib/post-process-gltf.js":
/*!**************************************!*\
  !*** ./src/lib/post-process-gltf.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return postProcessGLTF; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/assert */ "./src/lib/utils/assert.js");
/* harmony import */ var _gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gltf-utils/gltf-utils */ "./src/lib/gltf-utils/gltf-utils.js");



// This is a post processor for loaded glTF files
// The goal is to make the loaded data easier to use in WebGL applications
//
// Functions:
// * Resolve indexed arrays structure of glTF into a linked tree.
// * Translate stringified enum keys and values into WebGL constants.
// * Load images (optional)

// ENUM LOOKUP

const COMPONENTS = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16
};

const BYTES = {
  5120: 1, // BYTE
  5121: 1, // UNSIGNED_BYTE
  5122: 2, // SHORT
  5123: 2, // UNSIGNED_SHORT
  5125: 4, // UNSIGNED_INT
  5126: 4 // FLOAT
};

const GL_SAMPLER = {
  // Sampler parameters
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,

  // Sampler default values
  REPEAT: 0x2901,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_LINEAR: 0x2702
};

const SAMPLER_PARAMETER_GLTF_TO_GL = {
  magFilter: GL_SAMPLER.TEXTURE_MAG_FILTER,
  minFilter: GL_SAMPLER.TEXTURE_MIN_FILTER,
  wrapS: GL_SAMPLER.TEXTURE_WRAP_S,
  wrapT: GL_SAMPLER.TEXTURE_WRAP_T
};

// When undefined, a sampler with repeat wrapping and auto filtering should be used.
// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#texture
const DEFAULT_SAMPLER = {
  [GL_SAMPLER.TEXTURE_MAG_FILTER]: GL_SAMPLER.LINEAR,
  [GL_SAMPLER.TEXTURE_MIN_FILTER]: GL_SAMPLER.NEAREST_MIPMAP_LINEAR,
  [GL_SAMPLER.TEXTURE_WRAP_S]: GL_SAMPLER.REPEAT,
  [GL_SAMPLER.TEXTURE_WRAP_]: GL_SAMPLER.REPEAT
};

function getBytesFromComponentType(componentType) {
  return BYTES[componentType];
}

function getSizeFromAccessorType(type) {
  return COMPONENTS[type];
}

class GLTFPostProcessor {
  postProcess(gltf, options = {}) {
    const {json, buffers = [], images = [], baseUri = ''} = gltf;
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(json);

    this.baseUri = baseUri;
    this.json = json;
    this.buffers = buffers;
    this.images = images;

    this._resolveTree(this.json, options);

    return this.json;
  }

  // Convert indexed glTF structure into tree structure
  // cross-link index resolution, enum lookup, convenience calculations
  // eslint-disable-next-line complexity
  _resolveTree(json, options = {}) {
    if (json.bufferViews) {
      json.bufferViews = json.bufferViews.map((bufView, i) => this._resolveBufferView(bufView, i));
    }
    if (json.images) {
      json.images = json.images.map((image, i) => this._resolveImage(image, i));
    }
    if (json.samplers) {
      json.samplers = json.samplers.map((sampler, i) => this._resolveSampler(sampler, i));
    }
    if (json.textures) {
      json.textures = json.textures.map((texture, i) => this._resolveTexture(texture, i));
    }
    if (json.accessors) {
      json.accessors = json.accessors.map((accessor, i) => this._resolveAccessor(accessor, i));
    }
    if (json.materials) {
      json.materials = json.materials.map((material, i) => this._resolveMaterial(material, i));
    }
    if (json.meshes) {
      json.meshes = json.meshes.map((mesh, i) => this._resolveMesh(mesh, i));
    }
    if (json.nodes) {
      json.nodes = json.nodes.map((node, i) => this._resolveNode(node, i));
    }
    if (json.skins) {
      json.skins = json.skins.map((skin, i) => this._resolveSkin(skin, i));
    }
    if (json.scenes) {
      json.scenes = json.scenes.map((scene, i) => this._resolveScene(scene, i));
    }
    if (json.scene !== undefined) {
      json.scene = json.scenes[this.json.scene];
    }
  }

  getScene(index) {
    return this._get('scenes', index);
  }

  getNode(index) {
    return this._get('nodes', index);
  }

  getSkin(index) {
    return this._get('skins', index);
  }

  getMesh(index) {
    return this._get('meshes', index);
  }

  getMaterial(index) {
    return this._get('materials', index);
  }

  getAccessor(index) {
    return this._get('accessors', index);
  }

  getCamera(index) {
    return null; // TODO: fix this
  }

  getTexture(index) {
    return this._get('textures', index);
  }

  getSampler(index) {
    return this._get('samplers', index);
  }

  getImage(index) {
    return this._get('images', index);
  }

  getBufferView(index) {
    return this._get('bufferViews', index);
  }

  getBuffer(index) {
    return this._get('buffers', index);
  }

  _get(array, index) {
    // check if already resolved
    if (typeof index === 'object') {
      return index;
    }
    const object = this.json[array] && this.json[array][index];
    if (!object) {
      console.warn(`glTF file error: Could not find ${array}[${index}]`); // eslint-disable-line
    }
    return object;
  }

  // PARSING HELPERS

  _resolveScene(scene, index) {
    // scene = {...scene};
    scene.id = scene.id || `scene-${index}`;
    scene.nodes = (scene.nodes || []).map(node => this.getNode(node));
    return scene;
  }

  _resolveNode(node, index) {
    // node = {...node};
    node.id = node.id || `node-${index}`;
    if (node.children) {
      node.children = node.children.map(child => this.getNode(child));
    }
    if (node.mesh !== undefined) {
      node.mesh = this.getMesh(node.mesh);
    }
    if (node.camera !== undefined) {
      node.camera = this.getCamera(node.camera);
    }
    if (node.skin !== undefined) {
      node.skin = this.getSkin(node.skin);
    }
    return node;
  }

  _resolveSkin(skin, index) {
    // skin = {...skin};
    skin.id = skin.id || `skin-${index}`;
    skin.inverseBindMatrices = this.getAccessor(skin.inverseBindMatrices);
    return skin;
  }

  _resolveMesh(mesh, index) {
    // mesh = {...mesh};
    mesh.id = mesh.id || `mesh-${index}`;
    if (mesh.primitives) {
      mesh.primitives = mesh.primitives.map(primitive => {
        primitive = {...primitive};
        const attributes = primitive.attributes;
        primitive.attributes = {};
        for (const attribute in attributes) {
          primitive.attributes[attribute] = this.getAccessor(attributes[attribute]);
        }
        if (primitive.indices !== undefined) {
          primitive.indices = this.getAccessor(primitive.indices);
        }
        if (primitive.material !== undefined) {
          primitive.material = this.getMaterial(primitive.material);
        }
        return primitive;
      });
    }
    return mesh;
  }

  _resolveMaterial(material, index) {
    // material = {...material};
    material.id = material.id || `material-${index}`;
    if (material.normalTexture) {
      material.normalTexture = {...material.normalTexture};
      material.normalTexture.texture = this.getTexture(material.normalTexture.index);
    }
    if (material.occlusionTexture) {
      material.occlustionTexture = {...material.occlustionTexture};
      material.occlusionTexture.texture = this.getTexture(material.occlusionTexture.index);
    }
    if (material.emissiveTexture) {
      material.emmisiveTexture = {...material.emmisiveTexture};
      material.emissiveTexture.texture = this.getTexture(material.emissiveTexture.index);
    }

    if (material.pbrMetallicRoughness) {
      material.pbrMetallicRoughness = {...material.pbrMetallicRoughness};
      const mr = material.pbrMetallicRoughness;
      if (mr.baseColorTexture) {
        mr.baseColorTexture = {...mr.baseColorTexture};
        mr.baseColorTexture.texture = this.getTexture(mr.baseColorTexture.index);
      }
      if (mr.metallicRoughnessTexture) {
        mr.metallicRoughnessTexture = {...mr.metallicRoughnessTexture};
        mr.metallicRoughnessTexture.texture = this.getTexture(mr.metallicRoughnessTexture.index);
      }
    }
    return material;
  }

  _resolveAccessor(accessor, index) {
    // accessor = {...accessor};
    accessor.id = accessor.id || `accessor-${index}`;
    if (accessor.bufferView !== undefined) {
      // Draco encoded meshes don't have bufferView
      accessor.bufferView = this.getBufferView(accessor.bufferView);
    }

    // Look up enums
    accessor.bytesPerComponent = getBytesFromComponentType(accessor.componentType);
    accessor.components = getSizeFromAccessorType(accessor.type);
    accessor.bytesPerElement = accessor.bytesPerComponent * accessor.components;

    // Create TypedArray for the accessor
    // Note: The canonical way to instantiate is to ignore this array and create
    // WebGLBuffer's using the bufferViews.
    if (accessor.bufferView) {
      const buffer = accessor.bufferView.buffer;
      const {ArrayType, length} = Object(_gltf_utils_gltf_utils__WEBPACK_IMPORTED_MODULE_1__["getAccessorArrayTypeAndLength"])(accessor, accessor.bufferView);
      const byteOffset = (accessor.bufferView.byteOffset || 0) + buffer.byteOffset;
      accessor.value = new ArrayType(buffer.arrayBuffer, byteOffset, length);
    }

    return accessor;
  }

  _resolveTexture(texture, index) {
    // texture = {...texture};
    texture.id = texture.id || `texture-${index}`;
    texture.sampler = 'sampler' in texture ? this.getSampler(texture.sampler) : DEFAULT_SAMPLER;
    texture.source = this.getImage(texture.source);
    return texture;
  }

  _resolveSampler(sampler, index) {
    // sampler = {...sampler};
    sampler.id = sampler.id || `sampler-${index}`;
    // Map textual parameters to GL parameter values
    sampler.parameters = {};
    for (const key in sampler) {
      const glEnum = this._enumSamplerParameter(key);
      if (glEnum !== undefined) {
        sampler.parameters[glEnum] = sampler[key];
      }
    }
    return sampler;
  }

  _enumSamplerParameter(key) {
    return SAMPLER_PARAMETER_GLTF_TO_GL[key];
  }

  _resolveImage(image, index) {
    // image = {...image};
    image.id = image.id || `image-${index}`;
    if (image.bufferView !== undefined) {
      image.bufferView = this.getBufferView(image.bufferView);
    }

    // Check if image has been preloaded by the GLTFLoader
    // If so, link it into the JSON and drop the URI
    const preloadedImage = this.images[index];
    if (preloadedImage) {
      image.image = preloadedImage;
    }

    return image;
  }

  _resolveBufferView(bufferView, index) {
    // bufferView = {...bufferView};
    bufferView.id = bufferView.id || `bufferView-${index}`;
    const bufferIndex = bufferView.buffer;
    bufferView.buffer = this.buffers[bufferIndex];

    const arrayBuffer = this.buffers[bufferIndex].arrayBuffer;
    let byteOffset = this.buffers[bufferIndex].byteOffset || 0;

    if ('byteOffset' in bufferView) {
      byteOffset += bufferView.byteOffset;
    }

    bufferView.data = new Uint8Array(arrayBuffer, byteOffset, bufferView.byteLength);
    return bufferView;
  }

  _resolveCamera(camera, index) {
    camera.id = camera.id || `camera-${index}`;
    // TODO - create 4x4 matrices
    if (camera.perspective) {
      // camera.matrix = createPerspectiveMatrix(camera.perspective);
    }
    if (camera.orthographic) {
      // camera.matrix = createOrthographicMatrix(camera.orthographic);
    }
    return camera;
  }
}

function postProcessGLTF(gltf, options) {
  return new GLTFPostProcessor().postProcess(gltf, options);
}


/***/ }),

/***/ "./src/lib/utils/assert.js":
/*!*********************************!*\
  !*** ./src/lib/utils/assert.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Replacement for the external assert method to reduce bundle size
// Note: We don't use the second "message" argument in calling code,
// so no need to support it here
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'assert failed: gltf');
  }
}


/***/ }),

/***/ 0:
/*!********************************************!*\
  !*** ../node/require-utils.node (ignored) ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!*******************************************!*\
  !*** ../node/buffer-utils.node (ignored) ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!*******************************!*\
  !*** child_process (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});