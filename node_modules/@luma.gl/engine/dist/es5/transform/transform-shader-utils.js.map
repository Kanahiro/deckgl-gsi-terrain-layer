{"version":3,"sources":["../../../src/transform/transform-shader-utils.js"],"names":["SAMPLER_UNIFORM_PREFIX","SIZE_UNIFORM_PREFIX","VS_POS_VARIABLE","updateForTextures","vs","sourceTextureMap","targetTextureVarying","targetTexture","texAttributeNames","Object","keys","sourceCount","length","targetTextureType","samplerTextureMap","updatedVs","finalInject","vsLines","split","updateVsLines","slice","forEach","line","index","lines","updated","processAttributeDefinition","updatedLine","inject","assign","getVaryingType","sizeName","uniformDeclaration","posInstructions","join","getSizeUniforms","uniforms","width","height","textureName","getAttributeDefinition","getSamplerDeclerations","samplerName","uniformDeclerations","varying","qualaiferDetails","name","type","textureMap","attributeData","channels","sampleInstruction"],"mappings":"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","sourcesContent":["import {assert} from '@luma.gl/webgl';\nimport {combineInjects, getQualifierDetails, typeToChannelSuffix} from '@luma.gl/shadertools';\n\nconst SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';\nconst SIZE_UNIFORM_PREFIX = 'transform_uSize_';\nconst VS_POS_VARIABLE = 'transform_position';\n\n// Scan provided vertex shader\n// for each texture attribute, inject sampler instructions and build uniforms for sampler\n// for texture target, get varying type and inject position instruction\nexport function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const texAttributeNames = Object.keys(sourceTextureMap);\n  let sourceCount = texAttributeNames.length;\n  let targetTextureType = null;\n  const samplerTextureMap = {};\n  let updatedVs = vs;\n  let finalInject = {};\n\n  if (sourceCount > 0 || targetTextureVarying) {\n    const vsLines = updatedVs.split('\\n');\n    const updateVsLines = vsLines.slice();\n    vsLines.forEach((line, index, lines) => {\n      // TODO add early exit\n      if (sourceCount > 0) {\n        const updated = processAttributeDefinition(line, sourceTextureMap);\n        if (updated) {\n          const {updatedLine, inject} = updated;\n          updateVsLines[index] = updatedLine;\n          // sampleInstructions.push(sampleInstruction);\n          finalInject = combineInjects([finalInject, inject]);\n          Object.assign(samplerTextureMap, updated.samplerTextureMap);\n          sourceCount--;\n        }\n      }\n      if (targetTextureVarying && !targetTextureType) {\n        targetTextureType = getVaryingType(line, targetTextureVarying);\n      }\n    });\n\n    if (targetTextureVarying) {\n      assert(targetTexture);\n      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;\n\n      const uniformDeclaration = `uniform vec2 ${sizeName};\\n`;\n      const posInstructions = `\\\n     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});\n     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\\n`;\n      const inject = {\n        'vs:#decl': uniformDeclaration,\n        'vs:#main-start': posInstructions\n      };\n      finalInject = combineInjects([finalInject, inject]);\n    }\n    updatedVs = updateVsLines.join('\\n');\n  }\n  return {\n    // updated vertex shader (commented texture attribute definition)\n    vs: updatedVs,\n    // type (float, vec2, vec3 of vec4) target texture varying\n    targetTextureType,\n    // required vertex and fragment shader injects\n    inject: finalInject,\n    // map of sampler name to texture name, can be used to set attributes\n    // usefull when swapping textures, as source and destination texture change when swap is called.\n    samplerTextureMap\n  };\n}\n\n// builds and returns an object contaning size uniform for each texture\nexport function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {\n  const uniforms = {};\n  let width;\n  let height;\n  if (targetTextureVarying) {\n    ({width, height} = targetTexture);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];\n  }\n  for (const textureName in sourceTextureMap) {\n    ({width, height} = sourceTextureMap[textureName]);\n    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];\n  }\n  return uniforms;\n}\n\n// Checks if provided line is defining an attribute, if so returns details otherwise null\nfunction getAttributeDefinition(line) {\n  return getQualifierDetails(line, ['attribute', 'in']);\n}\n\nfunction getSamplerDeclerations(textureName) {\n  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;\n  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;\n  const uniformDeclerations = `\\\n  uniform sampler2D ${samplerName};\n  uniform vec2 ${sizeName};`;\n  return {samplerName, sizeName, uniformDeclerations};\n}\n\n// Return size (float, vec2 etc) of a given varying, null if doens't exist.\nexport function getVaryingType(line, varying) {\n  const qualaiferDetails = getQualifierDetails(line, ['varying', 'out']);\n  if (!qualaiferDetails) {\n    return null;\n  }\n  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;\n}\n\n// build required definitions, sample instructions for each texture attribute\nexport function processAttributeDefinition(line, textureMap) {\n  const samplerTextureMap = {};\n  const attributeData = getAttributeDefinition(line);\n  if (!attributeData) {\n    return null;\n  }\n  const {type, name} = attributeData;\n  if (name && textureMap[name]) {\n    // eslint-disable-next-line no-useless-escape\n    const updatedLine = `\\// ${line} => Replaced by Transform with a sampler`;\n    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);\n\n    const channels = typeToChannelSuffix(type);\n    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\\n`;\n\n    samplerTextureMap[samplerName] = name;\n    const inject = {\n      'vs:#decl': uniformDeclerations,\n      'vs:#main-start': sampleInstruction\n    };\n\n    // samplerNameMap\n    return {\n      // update vertex shader line.\n      updatedLine,\n      // inject object with sampler instructions.\n      inject,\n      // sampler name to texture name map\n      samplerTextureMap\n    };\n  }\n  return null;\n}\n"],"file":"transform-shader-utils.js"}