{"version":3,"sources":["../../../src/transform/transform.js"],"names":["getPassthroughFS","BufferTransform","TextureTransform","isWebGL2","assert","isObjectEmpty","getShaderVersion","Model","Transform","gl","props","model","elementCount","bufferTransform","textureTransform","elementIDBuffer","_initialize","Object","seal","opts","clearRenderTarget","updatedOpts","_updateDrawOptions","framebuffer","clear","color","transform","swapped","resourceTransforms","filter","Boolean","resourceTransform","swap","varyingName","getBuffer","data","getData","getFramebuffer","setVertexCount","update","_buildResourceTransforms","_updateModelProps","assign","fs","version","vs","id","drawMode","vertexCount","setupResources","updatedProps","updateModelProps","canCreateBufferTransform","canCreateTextureTransform","getDrawOptions","feedbackBuffers","feedbackMap","varyings","length","_sourceTextures","_targetTexture","_targetTextureVarying"],"mappings":";;AACA,SAAQA,gBAAR,QAA+B,sBAA/B;AACA,OAAOC,eAAP,MAA4B,oBAA5B;AACA,OAAOC,gBAAP,MAA6B,qBAA7B;AAEA,SAAQC,QAAR,QAAuB,kBAAvB;AACA,SAAQC,MAAR,EAAgBC,aAAhB,EAA+BC,gBAA/B,QAAsD,gBAAtD;AACA,OAAOC,KAAP,MAAkB,cAAlB;;IAGqBC,S;;;gCACAC,E,EAAI;AAErB,aAAON,QAAQ,CAACM,EAAD,CAAf;AACD;;;AAED,qBAAYA,EAAZ,EAA4B;AAAA,QAAZC,KAAY,uEAAJ,EAAI;;AAAA;;AAC1B,SAAKD,EAAL,GAAUA,EAAV;AACA,SAAKE,KAAL,GAAa,IAAb;AACA,SAAKC,YAAL,GAAoB,CAApB;AACA,SAAKC,eAAL,GAAuB,IAAvB;AACA,SAAKC,gBAAL,GAAwB,IAAxB;AACA,SAAKC,eAAL,GAAuB,IAAvB;;AACA,SAAKC,WAAL,CAAiBN,KAAjB;;AACAO,IAAAA,MAAM,CAACC,IAAP,CAAY,IAAZ;AACD;;;;8BAGQ;AAAA,UACAP,KADA,GAC4C,IAD5C,CACAA,KADA;AAAA,UACOE,eADP,GAC4C,IAD5C,CACOA,eADP;AAAA,UACwBC,gBADxB,GAC4C,IAD5C,CACwBA,gBADxB;;AAEP,UAAIH,KAAJ,EAAW;AACTA,QAAAA,KAAK,UAAL;AACD;;AACD,UAAIE,eAAJ,EAAqB;AACnBA,QAAAA,eAAe,UAAf;AACD;;AACD,UAAIC,gBAAJ,EAAsB;AACpBA,QAAAA,gBAAgB,UAAhB;AACD;AACF;;;0BAGc;AAAA,UAAXK,IAAW,uEAAJ,EAAI;AAAA,kCACsBA,IADtB,CACNC,iBADM;AAAA,UACNA,iBADM,sCACc,IADd;;AAGb,UAAMC,WAAW,GAAG,KAAKC,kBAAL,CAAwBH,IAAxB,CAApB;;AAEA,UAAIC,iBAAiB,IAAIC,WAAW,CAACE,WAArC,EAAkD;AAChDF,QAAAA,WAAW,CAACE,WAAZ,CAAwBC,KAAxB,CAA8B;AAACC,UAAAA,KAAK,EAAE;AAAR,SAA9B;AACD;;AAED,WAAKd,KAAL,CAAWe,SAAX,CAAqBL,WAArB;AACD;;;2BAGM;AACL,UAAIM,OAAO,GAAG,KAAd;AACA,UAAMC,kBAAkB,GAAG,CAAC,KAAKf,eAAN,EAAuB,KAAKC,gBAA5B,EAA8Ce,MAA9C,CAAqDC,OAArD,CAA3B;AAFK;AAAA;AAAA;;AAAA;AAGL,6BAAgCF,kBAAhC,8HAAoD;AAAA,cAAzCG,iBAAyC;AAClDJ,UAAAA,OAAO,GAAGA,OAAO,IAAII,iBAAiB,CAACC,IAAlB,EAArB;AACD;AALI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAML5B,MAAAA,MAAM,CAACuB,OAAD,EAAU,iBAAV,CAAN;AACD;;;gCAG6B;AAAA,UAApBM,WAAoB,uEAAN,IAAM;AAC5B,aAAO,KAAKpB,eAAL,IAAwB,KAAKA,eAAL,CAAqBqB,SAArB,CAA+BD,WAA/B,CAA/B;AACD;;;8BAGkB;AAAA,UAAXd,IAAW,uEAAJ,EAAI;AACjB,UAAMS,kBAAkB,GAAG,CAAC,KAAKf,eAAN,EAAuB,KAAKC,gBAA5B,EAA8Ce,MAA9C,CAAqDC,OAArD,CAA3B;AADiB;AAAA;AAAA;;AAAA;AAEjB,8BAAgCF,kBAAhC,mIAAoD;AAAA,cAAzCG,iBAAyC;AAClD,cAAMI,IAAI,GAAGJ,iBAAiB,CAACK,OAAlB,CAA0BjB,IAA1B,CAAb;;AACA,cAAIgB,IAAJ,EAAU;AACR,mBAAOA,IAAP;AACD;AACF;AAPgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQjB,aAAO,IAAP;AACD;;;qCAGgB;AACf,aAAO,KAAKrB,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBuB,cAAtB,EAAhC;AACD;;;6BAGiB;AAAA,UAAXlB,IAAW,uEAAJ,EAAI;;AAChB,UAAI,kBAAkBA,IAAtB,EAA4B;AAC1B,aAAKR,KAAL,CAAW2B,cAAX,CAA0BnB,IAAI,CAACP,YAA/B;AACD;;AACD,UAAMgB,kBAAkB,GAAG,CAAC,KAAKf,eAAN,EAAuB,KAAKC,gBAA5B,EAA8Ce,MAA9C,CAAqDC,OAArD,CAA3B;AAJgB;AAAA;AAAA;;AAAA;AAKhB,8BAAgCF,kBAAhC,mIAAoD;AAAA,cAAzCG,iBAAyC;AAClDA,UAAAA,iBAAiB,CAACQ,MAAlB,CAAyBpB,IAAzB;AACD;AAPe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQjB;;;kCAIuB;AAAA,UAAZT,KAAY,uEAAJ,EAAI;AAAA,UACfD,EADe,GACT,IADS,CACfA,EADe;;AAEtB,WAAK+B,wBAAL,CAA8B/B,EAA9B,EAAkCC,KAAlC;;AAEAA,MAAAA,KAAK,GAAG,KAAK+B,iBAAL,CAAuB/B,KAAvB,CAAR;AACA,WAAKC,KAAL,GAAa,IAAIJ,KAAJ,CACXE,EADW,EAEXQ,MAAM,CAACyB,MAAP,CAAc,EAAd,EAAkBhC,KAAlB,EAAyB;AACvBiC,QAAAA,EAAE,EAAEjC,KAAK,CAACiC,EAAN,IAAY3C,gBAAgB,CAAC;AAAC4C,UAAAA,OAAO,EAAEtC,gBAAgB,CAACI,KAAK,CAACmC,EAAP;AAA1B,SAAD,CADT;AAEvBC,QAAAA,EAAE,EAAEpC,KAAK,CAACoC,EAAN,IAAY,iBAFO;AAGvBC,QAAAA,QAAQ,EAAErC,KAAK,CAACqC,QAAN,KAHa;AAIvBC,QAAAA,WAAW,EAAEtC,KAAK,CAACE;AAJI,OAAzB,CAFW,CAAb;AAWA,WAAKC,eAAL,IAAwB,KAAKA,eAAL,CAAqBoC,cAArB,CAAoC;AAACtC,QAAAA,KAAK,EAAE,KAAKA;AAAb,OAApC,CAAxB;AAED;;;sCAEiBD,K,EAAO;AACvB,UAAIwC,YAAY,GAAGjC,MAAM,CAACyB,MAAP,CAAc,EAAd,EAAkBhC,KAAlB,CAAnB;AACA,UAAMkB,kBAAkB,GAAG,CAAC,KAAKf,eAAN,EAAuB,KAAKC,gBAA5B,EAA8Ce,MAA9C,CAAqDC,OAArD,CAA3B;AAFuB;AAAA;AAAA;;AAAA;AAGvB,8BAAgCF,kBAAhC,mIAAoD;AAAA,cAAzCG,iBAAyC;AAClDmB,UAAAA,YAAY,GAAGnB,iBAAiB,CAACoB,gBAAlB,CAAmCD,YAAnC,CAAf;AACD;AALsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMvB,aAAOA,YAAP;AACD;;;6CAEwBzC,E,EAAIC,K,EAAO;AAClC,UAAI0C,wBAAwB,CAAC1C,KAAD,CAA5B,EAAqC;AACnC,aAAKG,eAAL,GAAuB,IAAIZ,eAAJ,CAAoBQ,EAApB,EAAwBC,KAAxB,CAAvB;AACD;;AACD,UAAI2C,yBAAyB,CAAC3C,KAAD,CAA7B,EAAsC;AACpC,aAAKI,gBAAL,GAAwB,IAAIZ,gBAAJ,CAAqBO,EAArB,EAAyBC,KAAzB,CAAxB;AACD;;AACDN,MAAAA,MAAM,CACJ,KAAKS,eAAL,IAAwB,KAAKC,gBADzB,EAEJ,gEAFI,CAAN;AAID;;;uCAEkBK,I,EAAM;AACvB,UAAIE,WAAW,GAAGJ,MAAM,CAACyB,MAAP,CAAc,EAAd,EAAkBvB,IAAlB,CAAlB;AACA,UAAMS,kBAAkB,GAAG,CAAC,KAAKf,eAAN,EAAuB,KAAKC,gBAA5B,EAA8Ce,MAA9C,CAAqDC,OAArD,CAA3B;AAFuB;AAAA;AAAA;;AAAA;AAGvB,8BAAgCF,kBAAhC,mIAAoD;AAAA,cAAzCG,iBAAyC;AAClDV,UAAAA,WAAW,GAAGJ,MAAM,CAACyB,MAAP,CAAcrB,WAAd,EAA2BU,iBAAiB,CAACuB,cAAlB,CAAiCjC,WAAjC,CAA3B,CAAd;AACD;AALsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMvB,aAAOA,WAAP;AACD;;;;;;SA1IkBb,S;;AA+IrB,SAAS4C,wBAAT,CAAkC1C,KAAlC,EAAyC;AACvC,MACE,CAACL,aAAa,CAACK,KAAK,CAAC6C,eAAP,CAAd,IACA,CAAClD,aAAa,CAACK,KAAK,CAAC8C,WAAP,CADd,IAEC9C,KAAK,CAAC+C,QAAN,IAAkB/C,KAAK,CAAC+C,QAAN,CAAeC,MAAf,GAAwB,CAH7C,EAIE;AACA,WAAO,IAAP;AACD;;AACD,SAAO,KAAP;AACD;;AAED,SAASL,yBAAT,CAAmC3C,KAAnC,EAA0C;AACxC,MACE,CAACL,aAAa,CAACK,KAAK,CAACiD,eAAP,CAAd,IACAjD,KAAK,CAACkD,cADN,IAEAlD,KAAK,CAACmD,qBAHR,EAIE;AACA,WAAO,IAAP;AACD;;AAED,SAAO,KAAP;AACD","sourcesContent":["import GL from '@luma.gl/constants';\nimport {getPassthroughFS} from '@luma.gl/shadertools';\nimport BufferTransform from './buffer-transform';\nimport TextureTransform from './texture-transform';\n\nimport {isWebGL2} from '@luma.gl/gltools';\nimport {assert, isObjectEmpty, getShaderVersion} from '@luma.gl/webgl';\nimport Model from '../lib/model';\n\n// takes source and target buffers/textures and setsup the pipeline\nexport default class Transform {\n  static isSupported(gl) {\n    // TODO : differentiate writting to buffer vs not\n    return isWebGL2(gl);\n  }\n\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.model = null;\n    this.elementCount = 0;\n    this.bufferTransform = null;\n    this.textureTransform = null;\n    this.elementIDBuffer = null;\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  // Delete owned resources.\n  delete() {\n    const {model, bufferTransform, textureTransform} = this;\n    if (model) {\n      model.delete();\n    }\n    if (bufferTransform) {\n      bufferTransform.delete();\n    }\n    if (textureTransform) {\n      textureTransform.delete();\n    }\n  }\n\n  // Run one transform loop.\n  run(opts = {}) {\n    const {clearRenderTarget = true} = opts;\n\n    const updatedOpts = this._updateDrawOptions(opts);\n\n    if (clearRenderTarget && updatedOpts.framebuffer) {\n      updatedOpts.framebuffer.clear({color: true});\n    }\n\n    this.model.transform(updatedOpts);\n  }\n\n  // swap resources if a map is provided\n  swap() {\n    let swapped = false;\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      swapped = swapped || resourceTransform.swap();\n    }\n    assert(swapped, 'Nothing to swap');\n  }\n\n  // Return Buffer object for given varying name.\n  getBuffer(varyingName = null) {\n    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);\n  }\n\n  // Return data either from Buffer or from Texture\n  getData(opts = {}) {\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      const data = resourceTransform.getData(opts);\n      if (data) {\n        return data;\n      }\n    }\n    return null;\n  }\n\n  // Return framebuffer object if rendering to textures\n  getFramebuffer() {\n    return this.textureTransform && this.textureTransform.getFramebuffer();\n  }\n\n  // Update some or all buffer/texture bindings.\n  update(opts = {}) {\n    if ('elementCount' in opts) {\n      this.model.setVertexCount(opts.elementCount);\n    }\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      resourceTransform.update(opts);\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {gl} = this;\n    this._buildResourceTransforms(gl, props);\n\n    props = this._updateModelProps(props);\n    this.model = new Model(\n      gl,\n      Object.assign({}, props, {\n        fs: props.fs || getPassthroughFS({version: getShaderVersion(props.vs)}),\n        id: props.id || 'transform-model',\n        drawMode: props.drawMode || GL.POINTS,\n        vertexCount: props.elementCount\n      })\n    );\n\n    /* eslint-disable no-unused-expressions */\n    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});\n    /* eslint-enable no-unused-expressions */\n  }\n\n  _updateModelProps(props) {\n    let updatedProps = Object.assign({}, props);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedProps = resourceTransform.updateModelProps(updatedProps);\n    }\n    return updatedProps;\n  }\n\n  _buildResourceTransforms(gl, props) {\n    if (canCreateBufferTransform(props)) {\n      this.bufferTransform = new BufferTransform(gl, props);\n    }\n    if (canCreateTextureTransform(props)) {\n      this.textureTransform = new TextureTransform(gl, props);\n    }\n    assert(\n      this.bufferTransform || this.textureTransform,\n      'must provide source/feedback buffers or source/target textures'\n    );\n  }\n\n  _updateDrawOptions(opts) {\n    let updatedOpts = Object.assign({}, opts);\n    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);\n    for (const resourceTransform of resourceTransforms) {\n      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));\n    }\n    return updatedOpts;\n  }\n}\n\n// Helper Methods\n\nfunction canCreateBufferTransform(props) {\n  if (\n    !isObjectEmpty(props.feedbackBuffers) ||\n    !isObjectEmpty(props.feedbackMap) ||\n    (props.varyings && props.varyings.length > 0)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nfunction canCreateTextureTransform(props) {\n  if (\n    !isObjectEmpty(props._sourceTextures) ||\n    props._targetTexture ||\n    props._targetTextureVarying\n  ) {\n    return true;\n  }\n\n  return false;\n}\n"],"file":"transform.js"}