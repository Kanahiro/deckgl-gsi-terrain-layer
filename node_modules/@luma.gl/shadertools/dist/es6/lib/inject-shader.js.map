{"version":3,"sources":["../../../src/lib/inject-shader.js"],"names":["MODULE_INJECTORS_VS","MODULE_INJECTORS_FS","VERTEX_SHADER","FRAGMENT_SHADER","assert","MODULE_INJECTORS","DECLARATION_INJECT_MARKER","REGEX_START_OF_MAIN","REGEX_END_OF_MAIN","fragments","injectShader","source","type","inject","injectStandardStubs","isVertex","key","fragmentData","sort","a","b","order","length","i","len","injection","fragmentString","join","replace","match","combineInjects","injects","result","Array","isArray","forEach"],"mappings":"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","sourcesContent":["import {MODULE_INJECTORS_VS, MODULE_INJECTORS_FS} from '../modules/module-injectors';\nimport {VERTEX_SHADER, FRAGMENT_SHADER} from './constants';\nimport {assert} from '../utils';\n\n// TODO - experimental\nconst MODULE_INJECTORS = {\n  [VERTEX_SHADER]: MODULE_INJECTORS_VS,\n  [FRAGMENT_SHADER]: MODULE_INJECTORS_FS\n};\n\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations\n\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\n\n// A minimal shader injection/templating system.\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n/* eslint-disable complexity */\nexport default function injectShader(source, type, inject, injectStandardStubs) {\n  const isVertex = type === VERTEX_SHADER;\n\n  for (const key in inject) {\n    const fragmentData = inject[key];\n    fragmentData.sort((a, b) => a.order - b.order);\n    fragments.length = fragmentData.length;\n    for (let i = 0, len = fragmentData.length; i < len; ++i) {\n      fragments[i] = fragmentData[i].injection;\n    }\n    const fragmentString = `${fragments.join('\\n')}\\n`;\n    switch (key) {\n      // declarations are injected before the main function\n      case 'vs:#decl':\n        if (isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      // main code is injected at the end of main function\n      case 'vs:#main-start':\n        if (isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'vs:#main-end':\n        if (isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n      case 'fs:#decl':\n        if (!isVertex) {\n          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n        }\n        break;\n      case 'fs:#main-start':\n        if (!isVertex) {\n          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);\n        }\n        break;\n      case 'fs:#main-end':\n        if (!isVertex) {\n          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);\n        }\n        break;\n\n      default:\n        // TODO(Tarek): I think this usage should be deprecated.\n\n        // inject code after key, leaving key in place\n        source = source.replace(key, match => match + fragmentString);\n    }\n  }\n\n  // Remove if it hasn't already been replaced\n  source = source.replace(DECLARATION_INJECT_MARKER, '');\n\n  // Finally, if requested, insert an automatic module injector chunk\n  if (injectStandardStubs) {\n    source = source.replace(/\\}\\s*$/, match => match + MODULE_INJECTORS[type]);\n  }\n\n  return source;\n}\n\n/* eslint-enable complexity */\n\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n  const result = {};\n  assert(Array.isArray(injects) && injects.length > 1);\n  injects.forEach(inject => {\n    for (const key in inject) {\n      result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n    }\n  });\n  return result;\n}\n"],"file":"inject-shader.js"}