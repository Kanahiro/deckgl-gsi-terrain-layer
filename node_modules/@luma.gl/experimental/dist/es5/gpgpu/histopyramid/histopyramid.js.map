{"version":3,"sources":["../../../../src/gpgpu/histopyramid/histopyramid.js"],"names":["nextPowerOfTwo","x","p","Math","ceil","log2","pow","channelToIndexMap","r","g","y","b","z","a","w","buildHistopyramidBaseLevel","gl","opts","texture","channel","_readData","width","height","size","baseTexture","transform","Transform","_sourceTextures","inTexture","_targetTexture","_targetTextureVarying","vs","HISTOPYRAMID_BUILD_VS_UTILS","HISTOPYRAMID_BASE_BUILD_VS","elementCount","run","uniforms","padingPixelValue","textureData","getData","packed","flatPyramidSize","flatPyramidTexture","parameters","framebuffer","getFramebuffer","targetX","getHistoPyramid","levelCount","pyramidTextures","topLevelData","i","push","HISTOPYRAMID_BUILD_VS","flatOffset","outSize","update","histoPyramidGenerateIndices","keyIndexCount","keyIndex","Buffer","Float32Array","map","_","index","locationAndIndex","sourceBuffers","feedbackBuffers","varyings","HISTOPYRAMID_TRAVERSAL_UTILS","HISTOPYRAMID_TRAVERSAL_VS","numLevels","locationAndIndexBuffer"],"mappings":"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","sourcesContent":["import {Buffer, copyToTexture, cloneTextureFrom} from '@luma.gl/webgl';\nimport {Transform} from '@luma.gl/engine';\nimport GL from '@luma.gl/constants';\nimport {\n  HISTOPYRAMID_BUILD_VS_UTILS,\n  HISTOPYRAMID_TRAVERSAL_UTILS,\n  HISTOPYRAMID_BASE_BUILD_VS,\n  HISTOPYRAMID_BUILD_VS,\n  HISTOPYRAMID_TRAVERSAL_VS\n} from './histopyramid-shaders';\n\n// Following methods implement Histopyramid operations as described in 'High‐speed marching cubes using histopyramids' by Dyken C, Ziegler G, Theobalt C and Seidel H\n// Link to the paper: http://olmozavala.com/Custom/OpenGL/Tutorials/OpenGL4_Examples/MarchingCubes_Dyken/Dyken_et_al-2008-Computer_Graphics_Forum.pdf\n\n// TODO: enable to assert on texture dimension\n// function isPowerOfTwo(x) {\n//     return ((x !== 0) && !(x & (x - 1)));\n// }\n\nfunction nextPowerOfTwo(x) {\n  const p = Math.ceil(Math.log2(x));\n  return Math.pow(2, p);\n}\n\nconst channelToIndexMap = {\n  r: 0,\n  x: 0,\n  g: 1,\n  y: 1,\n  b: 2,\n  z: 2,\n  a: 3,\n  w: 3\n};\n\n// returns a base level texture that packs given weight into a texture\n// each 2X2 region is mapped into RGBA channels of single pixel\n// returned texture is a squred power of two sized texture\n// R -> lower left, G -> lower right B -> upper left A -> upper right\nexport function buildHistopyramidBaseLevel(gl, opts) {\n  const {texture, channel = 'r', _readData = false} = opts;\n  let {width, height} = texture;\n  width = nextPowerOfTwo(width);\n  height = nextPowerOfTwo(height);\n  // Use sqaured next power of two size, then use half of it since we are packing 2X2 group into a single RGBA pixel\n  const size = (width > height ? width : height) / 2;\n  const baseTexture = cloneTextureFrom(texture, {\n    width: size,\n    height: size\n  });\n\n  // build individual pyramid textures\n  const transform = new Transform(gl, {\n    _sourceTextures: {\n      inTexture: texture\n    },\n    _targetTexture: baseTexture,\n    _targetTextureVarying: 'outTexture',\n    vs: `${HISTOPYRAMID_BUILD_VS_UTILS}${HISTOPYRAMID_BASE_BUILD_VS}`,\n    elementCount: baseTexture.width * baseTexture.height\n  });\n  transform.run({\n    uniforms: {\n      channel: channelToIndexMap[channel] || 0,\n      padingPixelValue: [0, 0, 0, 0]\n    }\n  });\n  // _readData is debug only option\n  let textureData;\n  // when base textuer size is 1X1, there are no more level to be generated\n  // so read the texture data to be provided as base level data.\n  if (_readData || size === 1) {\n    textureData = transform.getData({packed: true});\n  }\n  const flatPyramidSize = size * 2;\n  const flatPyramidTexture = cloneTextureFrom(texture, {\n    width: flatPyramidSize,\n    height: flatPyramidSize,\n    parameters: {\n      [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n      [GL.TEXTURE_MIN_FILTER]: GL.NEAREST\n    }\n  });\n  const framebuffer = transform.getFramebuffer();\n  copyToTexture(framebuffer, flatPyramidTexture, {\n    targetX: 0,\n    width: size,\n    height: size\n  });\n\n  return {textureData, baseTexture, flatPyramidTexture};\n}\n\n// builds histopyramid for a given texture and returns individual levels and flatended pyramid texture\n// Returns object\n// * pyramidTextures: Array with all individual mip levels\n// * flatPyramidTexture: Texture with all mip levels laid out horizontally\nexport function getHistoPyramid(gl, opts) {\n  const {textureData, baseTexture, flatPyramidTexture} = buildHistopyramidBaseLevel(gl, opts);\n  const {width} = baseTexture;\n  // assert(width === height && isPowerOfTwo(width));\n  const levelCount = Math.log2(width) + 1;\n  const pyramidTextures = [baseTexture];\n\n  let topLevelData = textureData;\n  if (levelCount > 1) {\n    // build empty textures for rest of the pyramid\n    for (let i = 1; i < levelCount; i++) {\n      const size = width / Math.pow(2, i);\n      pyramidTextures.push(\n        cloneTextureFrom(baseTexture, {\n          width: size,\n          height: size\n        })\n      );\n    }\n\n    // build individual pyramid textures\n    const transform = new Transform(gl, {\n      _sourceTextures: {\n        inTexture: pyramidTextures[0]\n      },\n      _targetTexture: pyramidTextures[1],\n      _targetTextureVarying: 'outTexture',\n      vs: `${HISTOPYRAMID_BUILD_VS_UTILS}${HISTOPYRAMID_BUILD_VS}`,\n      elementCount: pyramidTextures[1].width * pyramidTextures[1].height\n    });\n\n    let flatOffset = width;\n    for (let i = 1; i < levelCount; i++) {\n      const outSize = [pyramidTextures[i].width, pyramidTextures[i].height];\n      transform.update({\n        _sourceTextures: {inTexture: pyramidTextures[i - 1]},\n        _targetTexture: pyramidTextures[i],\n        elementCount: pyramidTextures[i].width * pyramidTextures[i].height\n      });\n      transform.run();\n\n      // copy the result to the flaten pyramid texture\n      const framebuffer = transform.getFramebuffer();\n      copyToTexture(framebuffer, flatPyramidTexture, {\n        targetX: flatOffset,\n        width: outSize[0],\n        height: outSize[1]\n      });\n\n      flatOffset += outSize[0];\n    }\n    topLevelData = transform.getData();\n  }\n\n  return {pyramidTextures, flatPyramidTexture, levelCount, topLevelData};\n}\n\n// builds and traverses a histopyramid for a given texture and returns pixel locations and local-key index for each non zero weight in input texture\n// Returns object\n// *locationAndIndexBuffer : Buffer contains one vec4 for each non zero weight. XY represent loation, Z represents local-key index and W represent key-index\nexport function histoPyramidGenerateIndices(gl, opts) {\n  const {flatPyramidTexture, levelCount, topLevelData} = getHistoPyramid(gl, opts);\n\n  const keyIndexCount = topLevelData[0] + topLevelData[1] + topLevelData[2] + topLevelData[3];\n  const keyIndex = new Buffer(gl, new Float32Array(keyIndexCount).map((_, index) => index));\n  const locationAndIndex = new Buffer(gl, keyIndexCount * 4 * 4); // 4 floats for each key index\n\n  const transform = new Transform(gl, {\n    sourceBuffers: {\n      keyIndex\n    },\n    _sourceTextures: {\n      flatPyramidTexture\n    },\n    feedbackBuffers: {\n      locationAndIndex\n    },\n    varyings: ['locationAndIndex'],\n    vs: `${HISTOPYRAMID_TRAVERSAL_UTILS}${HISTOPYRAMID_TRAVERSAL_VS}`,\n    elementCount: keyIndexCount\n  });\n  transform.run({\n    uniforms: {\n      numLevels: levelCount\n    }\n  });\n\n  return {locationAndIndexBuffer: locationAndIndex};\n}\n"],"file":"histopyramid.js"}