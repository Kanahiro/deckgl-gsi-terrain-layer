{"version":3,"sources":["../../../src/classes/shader.js"],"names":["ERR_SOURCE","Shader","shaderType","gl","props","source","id","getTypeName","initialize","shaderName","_compile","pname","getShaderParameter","handle","getShaderSource","extension","getExtension","getTranslatedShaderSource","startsWith","shaderSource","compileShader","compileStatus","getParameter","infoLog","getShaderInfoLog","errors","warnings","log","error","warn","Error","deleteShader","type","getSource","Resource","VertexShader","Object","assign","createShader","FragmentShader"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {log} from '@luma.gl/gltools';\nimport {parseGLSLCompilerError, getShaderName} from '../glsl-utils';\nimport {assertWebGLContext} from '../webgl-utils';\nimport {uid, assert} from '../utils';\nimport Resource from './resource';\n\nconst ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';\n\n// For now this is an internal class\nexport class Shader extends Resource {\n  static getTypeName(shaderType) {\n    switch (shaderType) {\n      case GL.VERTEX_SHADER:\n        return 'vertex-shader';\n      case GL.FRAGMENT_SHADER:\n        return 'fragment-shader';\n      default:\n        assert(false);\n        return 'unknown';\n    }\n  }\n\n  /* eslint-disable max-statements */\n  constructor(gl, props) {\n    assertWebGLContext(gl);\n\n    // Validate arguments\n    assert(typeof props.source === 'string', ERR_SOURCE);\n\n    // Deduce an id, from shader source, or supplied id, or shader type\n    const id =\n      getShaderName(props.source, null) ||\n      props.id ||\n      uid(`unnamed ${Shader.getTypeName(props.shaderType)}`);\n\n    super(gl, {id});\n\n    this.shaderType = props.shaderType;\n    this.source = props.source;\n\n    this.initialize(props);\n  }\n\n  initialize({source}) {\n    const shaderName = getShaderName(source, null);\n    if (shaderName) {\n      this.id = uid(shaderName);\n    }\n    this._compile(source);\n  }\n\n  // Accessors\n\n  getParameter(pname) {\n    return this.gl.getShaderParameter(this.handle, pname);\n  }\n\n  toString() {\n    return `${Shader.getTypeName(this.shaderType)}:${this.id}`;\n  }\n\n  getName() {\n    return getShaderName(this.source) || 'unnamed-shader';\n  }\n\n  getSource() {\n    return this.gl.getShaderSource(this.handle);\n  }\n\n  // Debug method - Returns translated source if available\n  getTranslatedSource() {\n    const extension = this.gl.getExtension('WEBGL.debug_shaders');\n    return extension\n      ? extension.getTranslatedShaderSource(this.handle)\n      : 'No translated source available. WEBGL.debug_shaders not implemented';\n  }\n\n  // PRIVATE METHODS\n  _compile(source = this.source) {\n    if (!source.startsWith('#version ')) {\n      source = `#version 100\\n${source}`;\n    }\n    this.source = source;\n    this.gl.shaderSource(this.handle, this.source);\n    this.gl.compileShader(this.handle);\n\n    // TODO - For performance reasons, avoid checking shader compilation errors on production?\n    // TODO - Load log even when no error reported, to catch warnings?\n    // https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n    const compileStatus = this.getParameter(GL.COMPILE_STATUS);\n    if (!compileStatus) {\n      const infoLog = this.gl.getShaderInfoLog(this.handle);\n      const {shaderName, errors, warnings} = parseGLSLCompilerError(\n        infoLog,\n        this.source,\n        this.shaderType,\n        this.id\n      );\n      log.error(`GLSL compilation errors in ${shaderName}\\n${errors}`)();\n      log.warn(`GLSL compilation warnings in ${shaderName}\\n${warnings}`)();\n      throw new Error(`GLSL compilation errors in ${shaderName}`);\n    }\n  }\n\n  _deleteHandle() {\n    this.gl.deleteShader(this.handle);\n  }\n\n  _getOptsFromHandle() {\n    return {\n      type: this.getParameter(GL.SHADER_TYPE),\n      source: this.getSource()\n    };\n  }\n}\n\nexport class VertexShader extends Shader {\n  constructor(gl, props) {\n    // Signature: new VertexShader(gl, source)\n    if (typeof props === 'string') {\n      props = {source: props};\n    }\n    super(gl, Object.assign({}, props, {shaderType: GL.VERTEX_SHADER}));\n  }\n\n  // PRIVATE METHODS\n  _createHandle() {\n    return this.gl.createShader(GL.VERTEX_SHADER);\n  }\n}\n\nexport class FragmentShader extends Shader {\n  constructor(gl, props) {\n    // Signature: new FragmentShader(gl, source)\n    if (typeof props === 'string') {\n      props = {source: props};\n    }\n\n    super(gl, Object.assign({}, props, {shaderType: GL.FRAGMENT_SHADER}));\n  }\n\n  // PRIVATE METHODS\n  _createHandle() {\n    return this.gl.createShader(GL.FRAGMENT_SHADER);\n  }\n}\n"],"file":"shader.js"}