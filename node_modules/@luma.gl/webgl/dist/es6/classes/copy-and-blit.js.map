{"version":3,"sources":["../../../src/classes/copy-and-blit.js"],"names":["Buffer","Framebuffer","Texture","withParameters","log","assertWebGL2Context","flipRows","scalePixels","getTypedArrayFromGLType","getGLTypeFromTypedArray","glFormatToComponents","glTypeToBytes","toFramebuffer","assert","readPixelsToArray","source","sourceX","sourceY","sourceFormat","sourceAttachment","target","sourceWidth","sourceHeight","sourceType","framebuffer","deleteFramebuffer","getFramebuffer","gl","handle","attachments","width","height","type","getPixelArray","prevHandle","bindFramebuffer","readPixels","delete","readPixelsToBuffer","targetByteOffset","components","byteCount","byteLength","accessor","size","bind","unbind","copyToDataUrl","targetMaxHeight","Number","MAX_SAFE_INTEGER","data","canvas","document","createElement","context","getContext","imageData","createImageData","set","putImageData","toDataURL","copyToImage","targetImage","dataUrl","Image","src","copyToTexture","targetX","targetY","targetZ","targetMipmaplevel","targetInternalFormat","isSubCopy","texture","isFinite","copyTexImage2D","copyTexSubImage2D","copyTexSubImage3D","blit","sourceX0","sourceY0","sourceX1","sourceY1","targetX0","targetY0","targetX1","targetY1","color","depth","stencil","mask","filter","srcFramebuffer","deleteSrcFramebuffer","dstFramebuffer","deleteDstFramebuffer","readBuffer","warn","undefined","prevDrawHandle","prevReadHandle","blitFramebuffer","pixelArray","format","ArrayType","clamped"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport Buffer from './buffer';\nimport Framebuffer from './framebuffer';\nimport Texture from './texture';\nimport {withParameters, log} from '@luma.gl/gltools';\nimport {assertWebGL2Context, flipRows, scalePixels} from '../webgl-utils';\nimport {getTypedArrayFromGLType, getGLTypeFromTypedArray} from '../webgl-utils/typed-array-utils';\nimport {glFormatToComponents, glTypeToBytes} from '../webgl-utils/format-utils';\nimport {toFramebuffer} from '../webgl-utils/texture-utils';\nimport {assert} from '../utils';\n\n// NOTE: Slow requires roundtrip to GPU\n// Copies data from a Framebuffer or a Texture object into ArrayBuffer object.\n// App can provide targetPixelArray or have it auto allocated by this method\n// @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,\n//  newly allocated by this method unless provided by app.\nexport function readPixelsToArray(\n  source,\n  {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = GL.RGBA,\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    target = null,\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  } = {}\n) {\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle, attachments} = framebuffer;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // TODO - Set and unset gl.readBuffer\n  if (sourceAttachment === GL.COLOR_ATTACHMENT0 && handle === null) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  assert(attachments[sourceAttachment]);\n\n  // Deduce the type from color attachment if not provided.\n  sourceType = sourceType || attachments[sourceAttachment].type;\n\n  // Deduce type and allocated pixelArray if needed\n  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);\n\n  // Pixel array available, if necessary, deduce type from it.\n  sourceType = sourceType || getGLTypeFromTypedArray(target);\n\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return target;\n}\n\n// NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.\n// Copies data from a Framebuffer or a Texture object into a Buffer object.\nexport function readPixelsToBuffer(\n  source,\n  {\n    sourceX = 0,\n    sourceY = 0,\n    sourceFormat = GL.RGBA,\n    target = null, // A new Buffer object is created when not provided.\n    targetByteOffset = 0, // byte offset in buffer object\n    // following parameters are auto deduced if not provided\n    sourceWidth,\n    sourceHeight,\n    sourceType\n  }\n) {\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl} = framebuffer;\n  sourceWidth = sourceWidth || framebuffer.width;\n  sourceHeight = sourceHeight || framebuffer.height;\n\n  // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature\n  assertWebGL2Context(gl);\n\n  // deduce type if not available.\n  sourceType = sourceType || (target ? target.type : GL.UNSIGNED_BYTE);\n\n  if (!target) {\n    // Create new buffer with enough size\n    const components = glFormatToComponents(sourceFormat);\n    const byteCount = glTypeToBytes(sourceType);\n    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;\n    target = new Buffer(gl, {byteLength, accessor: {type: sourceType, size: components}});\n  }\n\n  target.bind({target: GL.PIXEL_PACK_BUFFER});\n  withParameters(gl, {framebuffer}, () => {\n    gl.readPixels(\n      sourceX,\n      sourceY,\n      sourceWidth,\n      sourceHeight,\n      sourceFormat,\n      sourceType,\n      targetByteOffset\n    );\n  });\n  target.unbind({target: GL.PIXEL_PACK_BUFFER});\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n\n  return target;\n}\n\n// Reads pixels from a Framebuffer or Texture object to a dataUrl\nexport function copyToDataUrl(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetMaxHeight = Number.MAX_SAFE_INTEGER\n  } = {}\n) {\n  let data = readPixelsToArray(source, {sourceAttachment});\n\n  // Scale down\n  let {width, height} = source;\n  while (height > targetMaxHeight) {\n    ({data, width, height} = scalePixels({data, width, height}));\n  }\n\n  // Flip to top down coordinate system\n  flipRows({data, width, height});\n\n  /* global document */\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d');\n\n  // Copy the pixels to a 2D canvas\n  const imageData = context.createImageData(width, height);\n  imageData.data.set(data);\n  context.putImageData(imageData, 0, 0);\n\n  return canvas.toDataURL();\n}\n\n// Reads pixels from a Framebuffer or Texture object into an HTML Image\nexport function copyToImage(\n  source,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n    targetImage = null\n  } = {}\n) {\n  /* global Image */\n  const dataUrl = copyToDataUrl(source, {sourceAttachment});\n  targetImage = targetImage || new Image();\n  targetImage.src = dataUrl;\n  return targetImage;\n}\n\n// Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)\n// eslint-disable-next-line complexity, max-statements\nexport function copyToTexture(\n  source,\n  target,\n  {\n    sourceX = 0,\n    sourceY = 0,\n    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer\n\n    targetX,\n    targetY,\n    targetZ,\n    targetMipmaplevel = 0,\n    targetInternalFormat = GL.RGBA,\n\n    width, // defaults to target width\n    height // defaults to target height\n  } = {}\n) {\n  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);\n  assert(framebuffer);\n  const {gl, handle} = framebuffer;\n  const isSubCopy =\n    typeof targetX !== 'undefined' ||\n    typeof targetY !== 'undefined' ||\n    typeof targetZ !== 'undefined';\n  targetX = targetX || 0;\n  targetY = targetY || 0;\n  targetZ = targetZ || 0;\n  const prevHandle = gl.bindFramebuffer(GL.FRAMEBUFFER, handle);\n  // TODO - support gl.readBuffer (WebGL2 only)\n  // const prevBuffer = gl.readBuffer(attachment);\n  assert(target);\n  let texture = null;\n  if (target instanceof Texture) {\n    texture = target;\n    width = Number.isFinite(width) ? width : texture.width;\n    height = Number.isFinite(height) ? height : texture.height;\n    texture.bind(0);\n    target = texture.target;\n  }\n\n  if (!isSubCopy) {\n    gl.copyTexImage2D(\n      target,\n      targetMipmaplevel,\n      targetInternalFormat,\n      sourceX,\n      sourceY,\n      width,\n      height,\n      0 /* border must be 0 */\n    );\n  } else {\n    switch (target) {\n      case GL.TEXTURE_2D:\n      case GL.TEXTURE_CUBE_MAP:\n        gl.copyTexSubImage2D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      case GL.TEXTURE_2D_ARRAY:\n      case GL.TEXTURE_3D:\n        gl.copyTexSubImage3D(\n          target,\n          targetMipmaplevel,\n          targetX,\n          targetY,\n          targetZ,\n          sourceX,\n          sourceY,\n          width,\n          height\n        );\n        break;\n      default:\n    }\n  }\n  if (texture) {\n    texture.unbind();\n  }\n  gl.bindFramebuffer(GL.FRAMEBUFFER, prevHandle || null);\n  if (deleteFramebuffer) {\n    framebuffer.delete();\n  }\n  return texture;\n}\n\n// NOTE: WEBLG2 only\n// Copies a rectangle of pixels between Framebuffer or Texture objects\n// eslint-disable-next-line max-statements, complexity\nexport function blit(\n  source,\n  target,\n  {\n    sourceAttachment = GL.COLOR_ATTACHMENT0,\n    sourceX0 = 0,\n    sourceY0 = 0,\n    sourceX1,\n    sourceY1,\n    targetX0 = 0,\n    targetY0 = 0,\n    targetX1,\n    targetY1,\n    color = true,\n    depth = false,\n    stencil = false,\n    mask = 0,\n    filter = GL.NEAREST\n  } = {}\n) {\n  const {framebuffer: srcFramebuffer, deleteFramebuffer: deleteSrcFramebuffer} = getFramebuffer(\n    source\n  );\n  const {framebuffer: dstFramebuffer, deleteFramebuffer: deleteDstFramebuffer} = getFramebuffer(\n    target\n  );\n\n  assert(srcFramebuffer);\n  assert(dstFramebuffer);\n  const {gl, handle, width, height, readBuffer} = dstFramebuffer;\n  assertWebGL2Context(gl);\n\n  if (!srcFramebuffer.handle && sourceAttachment === GL.COLOR_ATTACHMENT0) {\n    sourceAttachment = GL.FRONT;\n  }\n\n  if (color) {\n    mask |= GL.COLOR_BUFFER_BIT;\n  }\n  if (depth) {\n    mask |= GL.DEPTH_BUFFER_BIT;\n  }\n  if (stencil) {\n    mask |= GL.STENCIL_BUFFER_BIT;\n  }\n\n  if (deleteSrcFramebuffer || deleteDstFramebuffer) {\n    // Either source or destiantion was a texture object, which is wrapped in a Framebuffer objecgt as color attachment.\n    // Overwrite the mask to `COLOR_BUFFER_BIT`\n    if (mask & (GL.DEPTH_BUFFER_BIT | GL.STENCIL_BUFFER_BIT)) {\n      mask = GL.COLOR_BUFFER_BIT;\n      log.warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();\n    }\n  }\n  assert(mask);\n\n  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;\n  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;\n  targetX1 = targetX1 === undefined ? width : targetX1;\n  targetY1 = targetY1 === undefined ? height : targetY1;\n\n  const prevDrawHandle = gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, handle);\n  const prevReadHandle = gl.bindFramebuffer(GL.READ_FRAMEBUFFER, srcFramebuffer.handle);\n  gl.readBuffer(sourceAttachment);\n  gl.blitFramebuffer(\n    sourceX0,\n    sourceY0,\n    sourceX1,\n    sourceY1,\n    targetX0,\n    targetY0,\n    targetX1,\n    targetY1,\n    mask,\n    filter\n  );\n  gl.readBuffer(readBuffer);\n  gl.bindFramebuffer(GL.READ_FRAMEBUFFER, prevReadHandle || null);\n  gl.bindFramebuffer(GL.DRAW_FRAMEBUFFER, prevDrawHandle || null);\n  if (deleteSrcFramebuffer) {\n    srcFramebuffer.delete();\n  }\n  if (deleteDstFramebuffer) {\n    dstFramebuffer.delete();\n  }\n\n  return dstFramebuffer;\n}\n\n// Helper methods\n\nfunction getFramebuffer(source) {\n  if (!(source instanceof Framebuffer)) {\n    return {framebuffer: toFramebuffer(source), deleteFramebuffer: true};\n  }\n  return {framebuffer: source, deleteFramebuffer: false};\n}\n\nfunction getPixelArray(pixelArray, type, format, width, height) {\n  if (pixelArray) {\n    return pixelArray;\n  }\n  // Allocate pixel array if not already available, using supplied type\n  type = type || GL.UNSIGNED_BYTE;\n  const ArrayType = getTypedArrayFromGLType(type, {clamped: false});\n  const components = glFormatToComponents(format);\n  // TODO - check for composite type (components = 1).\n  return new ArrayType(width * height * components);\n}\n"],"file":"copy-and-blit.js"}