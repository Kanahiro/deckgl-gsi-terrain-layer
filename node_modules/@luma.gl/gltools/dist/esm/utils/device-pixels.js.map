{"version":3,"sources":["../../../src/utils/device-pixels.js"],"names":["cssToDeviceRatio","gl","canvas","luma","clientWidth","canvasSizeInfo","drawingBufferWidth","cssToDevicePixels","cssPixel","yInvert","ratio","width","height","drawingBufferHeight","scalePixels","getDevicePixelRatio","useDevicePixels","windowRatio","window","devicePixelRatio","Number","isFinite","pixel","x","scaleX","y","scaleY","t","xHigh","yHigh","Math","max","r","min","round"],"mappings":"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","sourcesContent":["/* global window */\n\n// multiplier need to convert CSS size to Device size\nexport function cssToDeviceRatio(gl) {\n  if (gl.canvas && gl.luma) {\n    // For headless gl we might have used custom width and height\n    // hence use cached clientWidth\n    const {clientWidth} = gl.luma.canvasSizeInfo;\n    return clientWidth ? gl.drawingBufferWidth / clientWidth : 1;\n  }\n  // use default device pixel ratio\n  return 1;\n}\n\n// Maps CSS pixel position to device pixel position\nexport function cssToDevicePixels(gl, cssPixel, yInvert = true) {\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\n\n// HELPER METHODS\n\n/**\n * Calulates device pixel ratio, used during context creation\n *\n * @param {boolean or Number} useDevicePixels - boolean or a Number\n * @return {Number} - device pixel ratio\n */\nexport function getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n  if (Number.isFinite(useDevicePixels)) {\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n  return useDevicePixels ? windowRatio : 1;\n}\n\n// PRIVATE\n\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locaitons\n\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x, ratio, width) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y, ratio, height, yInvert) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n"],"file":"device-pixels.js"}