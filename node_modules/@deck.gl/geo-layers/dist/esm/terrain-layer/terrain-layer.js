import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import _inherits from "@babel/runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "@babel/runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "@babel/runtime/helpers/esm/getPrototypeOf";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import { CompositeLayer } from '@deck.gl/core';
import { SimpleMeshLayer } from '@deck.gl/mesh-layers';
import { WebMercatorViewport, COORDINATE_SYSTEM } from '@deck.gl/core';
import { load } from '@loaders.gl/core';
import { TerrainLoader } from '@loaders.gl/terrain';
import TileLayer from '../tile-layer/tile-layer';
import { urlType, getURLFromTemplate } from '../tile-layer/utils';
var DUMMY_DATA = [1];

var defaultProps = _objectSpread(_objectSpread({}, TileLayer.defaultProps), {}, {
  elevationData: urlType,
  texture: urlType,
  meshMaxError: {
    type: 'number',
    value: 4.0
  },
  bounds: {
    type: 'array',
    value: null,
    optional: true,
    compare: true
  },
  color: {
    type: 'color',
    value: [255, 255, 255]
  },
  elevationDecoder: {
    type: 'object',
    value: {
      rScaler: 1,
      gScaler: 0,
      bScaler: 0,
      offset: 0
    }
  },
  workerUrl: {
    type: 'string',
    value: null
  },
  wireframe: false,
  material: true
});

function urlTemplateToUpdateTrigger(template) {
  if (Array.isArray(template)) {
    return template.join(';');
  }

  return template;
}

var TerrainLayer = function (_CompositeLayer) {
  _inherits(TerrainLayer, _CompositeLayer);

  var _super = _createSuper(TerrainLayer);

  function TerrainLayer() {
    _classCallCheck(this, TerrainLayer);

    return _super.apply(this, arguments);
  }

  _createClass(TerrainLayer, [{
    key: "updateState",
    value: function updateState(_ref) {
      var props = _ref.props,
          oldProps = _ref.oldProps;
      var elevationDataChanged = props.elevationData !== oldProps.elevationData;

      if (elevationDataChanged) {
        var elevationData = props.elevationData;
        var isTiled = elevationData && (Array.isArray(elevationData) || elevationData.includes('{x}') && elevationData.includes('{y}'));
        this.setState({
          isTiled: isTiled
        });
      }

      var shouldReload = elevationDataChanged || props.meshMaxError !== oldProps.meshMaxError || props.elevationDecoder !== oldProps.elevationDecoder || props.bounds !== oldProps.bounds;

      if (!this.state.isTiled && shouldReload) {
        var terrain = this.loadTerrain(props);
        this.setState({
          terrain: terrain
        });
      }
    }
  }, {
    key: "loadTerrain",
    value: function loadTerrain(_ref2) {
      var elevationData = _ref2.elevationData,
          bounds = _ref2.bounds,
          elevationDecoder = _ref2.elevationDecoder,
          meshMaxError = _ref2.meshMaxError,
          workerUrl = _ref2.workerUrl;

      if (!elevationData) {
        return null;
      }

      var options = {
        terrain: {
          bounds: bounds,
          meshMaxError: meshMaxError,
          elevationDecoder: elevationDecoder
        }
      };

      if (workerUrl !== null) {
        options.terrain.workerUrl = workerUrl;
      }

      return load(elevationData, TerrainLoader, options);
    }
  }, {
    key: "getTiledTerrainData",
    value: function getTiledTerrainData(tile) {
      var _this$props = this.props,
          elevationData = _this$props.elevationData,
          texture = _this$props.texture,
          elevationDecoder = _this$props.elevationDecoder,
          meshMaxError = _this$props.meshMaxError,
          workerUrl = _this$props.workerUrl;
      var dataUrl = getURLFromTemplate(elevationData, tile);
      var textureUrl = getURLFromTemplate(texture, tile);
      var bbox = tile.bbox,
          z = tile.z;
      var viewport = new WebMercatorViewport({
        longitude: (bbox.west + bbox.east) / 2,
        latitude: (bbox.north + bbox.south) / 2,
        zoom: z
      });
      var bottomLeft = viewport.projectFlat([bbox.west, bbox.south]);
      var topRight = viewport.projectFlat([bbox.east, bbox.north]);
      var bounds = [bottomLeft[0], bottomLeft[1], topRight[0], topRight[1]];
      var terrain = this.loadTerrain({
        elevationData: dataUrl,
        bounds: bounds,
        elevationDecoder: elevationDecoder,
        meshMaxError: meshMaxError,
        workerUrl: workerUrl
      });
      var surface = textureUrl ? load(textureUrl)["catch"](function (_) {
        return null;
      }) : Promise.resolve(null);
      return Promise.all([terrain, surface]);
    }
  }, {
    key: "renderSubLayers",
    value: function renderSubLayers(props) {
      var SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);
      var data = props.data,
          color = props.color;

      if (!data) {
        return null;
      }

      var _data = _slicedToArray(data, 2),
          mesh = _data[0],
          texture = _data[1];

      return new SubLayerClass(props, {
        data: DUMMY_DATA,
        mesh: mesh,
        texture: texture,
        coordinateSystem: COORDINATE_SYSTEM.CARTESIAN,
        getPosition: function getPosition(d) {
          return [0, 0, 0];
        },
        getColor: color
      });
    }
  }, {
    key: "onViewportLoad",
    value: function onViewportLoad(data) {
      if (!data || data.length === 0 || data.every(function (x) {
        return !x;
      })) {
        return;
      }

      var zRange = this.state.zRange;
      var ranges = data.filter(Boolean).map(function (arr) {
        var bounds = arr[0].header.boundingBox;
        return bounds.map(function (bound) {
          return bound[2];
        });
      });
      var minZ = Math.min.apply(Math, _toConsumableArray(ranges.map(function (x) {
        return x[0];
      })));
      var maxZ = Math.max.apply(Math, _toConsumableArray(ranges.map(function (x) {
        return x[1];
      })));

      if (!zRange || minZ < zRange[0] || maxZ > zRange[1]) {
        this.setState({
          zRange: [minZ, maxZ]
        });
      }
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var _this$props2 = this.props,
          color = _this$props2.color,
          material = _this$props2.material,
          elevationData = _this$props2.elevationData,
          texture = _this$props2.texture,
          wireframe = _this$props2.wireframe,
          meshMaxError = _this$props2.meshMaxError,
          elevationDecoder = _this$props2.elevationDecoder,
          tileSize = _this$props2.tileSize,
          maxZoom = _this$props2.maxZoom,
          minZoom = _this$props2.minZoom,
          extent = _this$props2.extent,
          maxRequests = _this$props2.maxRequests;

      if (this.state.isTiled) {
        return new TileLayer(this.getSubLayerProps({
          id: 'tiles'
        }), {
          wireframe: wireframe,
          color: color,
          material: material,
          getTileData: this.getTiledTerrainData.bind(this),
          renderSubLayers: this.renderSubLayers.bind(this),
          updateTriggers: {
            getTileData: {
              elevationData: urlTemplateToUpdateTrigger(elevationData),
              texture: urlTemplateToUpdateTrigger(texture),
              meshMaxError: meshMaxError,
              elevationDecoder: elevationDecoder
            }
          },
          onViewportLoad: this.onViewportLoad.bind(this),
          zRange: this.state.zRange || null,
          tileSize: tileSize,
          maxZoom: maxZoom,
          minZoom: minZoom,
          extent: extent,
          maxRequests: maxRequests
        });
      }

      var SubLayerClass = this.getSubLayerClass('mesh', SimpleMeshLayer);
      return new SubLayerClass(this.getSubLayerProps({
        id: 'mesh'
      }), {
        data: DUMMY_DATA,
        mesh: this.state.terrain,
        texture: texture,
        _instanced: false,
        getPosition: function getPosition(d) {
          return [0, 0, 0];
        },
        getColor: color,
        material: material,
        wireframe: wireframe
      });
    }
  }]);

  return TerrainLayer;
}(CompositeLayer);

export { TerrainLayer as default };
TerrainLayer.layerName = 'TerrainLayer';
TerrainLayer.defaultProps = defaultProps;
//# sourceMappingURL=terrain-layer.js.map