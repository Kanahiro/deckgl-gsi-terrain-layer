"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _core = require("@deck.gl/core");

var _layers = require("@deck.gl/layers");

var _core2 = require("@loaders.gl/core");

var _tileset2d = _interopRequireWildcard(require("./tileset-2d"));

var _utils = require("./utils");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2["default"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2["default"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2["default"])(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var defaultProps = {
  data: [],
  dataComparator: _utils.urlType.equals,
  renderSubLayers: {
    type: 'function',
    value: function value(props) {
      return new _layers.GeoJsonLayer(props);
    },
    compare: false
  },
  getTileData: {
    type: 'function',
    optional: true,
    value: null,
    compare: false
  },
  onViewportLoad: {
    type: 'function',
    optional: true,
    value: null,
    compare: false
  },
  onTileLoad: {
    type: 'function',
    value: function value(tile) {},
    compare: false
  },
  onTileUnload: {
    type: 'function',
    value: function value(tile) {},
    compare: false
  },
  onTileError: {
    type: 'function',
    value: function value(err) {
      return console.error(err);
    },
    compare: false
  },
  extent: {
    type: 'array',
    optional: true,
    value: null,
    compare: true
  },
  tileSize: 512,
  maxZoom: null,
  minZoom: 0,
  maxCacheSize: null,
  maxCacheByteSize: null,
  refinementStrategy: _tileset2d.STRATEGY_DEFAULT,
  zRange: null,
  fetch: {
    type: 'function',
    value: function value(url, _ref) {
      var layer = _ref.layer,
          signal = _ref.signal;

      var loadOptions = _objectSpread({
        signal: signal
      }, layer.getLoadOptions() || {});

      return (0, _core2.load)(url, loadOptions);
    },
    compare: false
  },
  maxRequests: 6
};

var TileLayer = function (_CompositeLayer) {
  (0, _inherits2["default"])(TileLayer, _CompositeLayer);

  var _super = _createSuper(TileLayer);

  function TileLayer() {
    (0, _classCallCheck2["default"])(this, TileLayer);
    return _super.apply(this, arguments);
  }

  (0, _createClass2["default"])(TileLayer, [{
    key: "initializeState",
    value: function initializeState() {
      this.state = {
        tiles: [],
        isLoaded: false
      };
    }
  }, {
    key: "shouldUpdateState",
    value: function shouldUpdateState(_ref2) {
      var changeFlags = _ref2.changeFlags;
      return changeFlags.somethingChanged;
    }
  }, {
    key: "updateState",
    value: function updateState(_ref3) {
      var props = _ref3.props,
          oldProps = _ref3.oldProps,
          context = _ref3.context,
          changeFlags = _ref3.changeFlags;
      var tileset = this.state.tileset;
      var createTileCache = !tileset || changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getTileData);

      if (createTileCache) {
        var maxZoom = props.maxZoom,
            minZoom = props.minZoom,
            tileSize = props.tileSize,
            maxCacheSize = props.maxCacheSize,
            maxCacheByteSize = props.maxCacheByteSize,
            refinementStrategy = props.refinementStrategy,
            extent = props.extent,
            maxRequests = props.maxRequests;
        tileset = new _tileset2d["default"]({
          getTileData: this.getTileData.bind(this),
          maxCacheSize: maxCacheSize,
          maxCacheByteSize: maxCacheByteSize,
          maxZoom: maxZoom,
          minZoom: minZoom,
          tileSize: tileSize,
          refinementStrategy: refinementStrategy,
          extent: extent,
          onTileLoad: this._onTileLoad.bind(this),
          onTileError: this._onTileError.bind(this),
          onTileUnload: this._onTileUnload.bind(this),
          maxRequests: maxRequests
        });
        this.setState({
          tileset: tileset
        });
      } else if (changeFlags.propsChanged || changeFlags.updateTriggersChanged) {
        tileset.setOptions(props);
        this.state.tileset.tiles.forEach(function (tile) {
          tile.layers = null;
        });
      }

      this._updateTileset();
    }
  }, {
    key: "_updateTileset",
    value: function _updateTileset() {
      var tileset = this.state.tileset;
      var _this$props = this.props,
          onViewportLoad = _this$props.onViewportLoad,
          zRange = _this$props.zRange;
      var frameNumber = tileset.update(this.context.viewport, {
        zRange: zRange
      });
      var isLoaded = tileset.isLoaded;
      var loadingStateChanged = this.state.isLoaded !== isLoaded;
      var tilesetChanged = this.state.frameNumber !== frameNumber;

      if (isLoaded && onViewportLoad && (loadingStateChanged || tilesetChanged)) {
        onViewportLoad(tileset.selectedTiles.map(function (tile) {
          return tile.data;
        }));
      }

      if (tilesetChanged) {
        this.setState({
          frameNumber: frameNumber
        });
      }

      this.state.isLoaded = isLoaded;
    }
  }, {
    key: "_onTileLoad",
    value: function _onTileLoad(tile) {
      var layer = this.getCurrentLayer();
      layer.props.onTileLoad(tile);

      if (tile.isVisible) {
        this.setNeedsUpdate();
      }
    }
  }, {
    key: "_onTileError",
    value: function _onTileError(error, tile) {
      var layer = this.getCurrentLayer();
      layer.props.onTileError(error);

      layer._updateTileset();

      if (tile.isVisible) {
        this.setNeedsUpdate();
      }
    }
  }, {
    key: "_onTileUnload",
    value: function _onTileUnload(tile) {
      var layer = this.getCurrentLayer();
      layer.props.onTileUnload(tile);
    }
  }, {
    key: "getTileData",
    value: function getTileData(tile) {
      var data = this.props.data;
      var _this$getCurrentLayer = this.getCurrentLayer().props,
          getTileData = _this$getCurrentLayer.getTileData,
          fetch = _this$getCurrentLayer.fetch;
      var signal = tile.signal;
      tile.url = (0, _utils.getURLFromTemplate)(data, tile);

      if (getTileData) {
        return getTileData(tile);
      }

      if (tile.url) {
        return fetch(tile.url, {
          layer: this,
          signal: signal
        });
      }

      return null;
    }
  }, {
    key: "renderSubLayers",
    value: function renderSubLayers(props) {
      return this.props.renderSubLayers(props);
    }
  }, {
    key: "getHighlightedObjectIndex",
    value: function getHighlightedObjectIndex() {
      return -1;
    }
  }, {
    key: "getPickingInfo",
    value: function getPickingInfo(_ref4) {
      var info = _ref4.info,
          sourceLayer = _ref4.sourceLayer;
      info.sourceLayer = sourceLayer;
      info.tile = sourceLayer.props.tile;
      return info;
    }
  }, {
    key: "renderLayers",
    value: function renderLayers() {
      var _this = this;

      var visible = this.props.visible;
      return this.state.tileset.tiles.map(function (tile) {
        var isVisible = visible && tile.isVisible;

        var highlightedObjectIndex = _this.getHighlightedObjectIndex(tile);

        if (!tile.isLoaded) {} else if (!tile.layers) {
          var layers = _this.renderSubLayers(Object.assign({}, _this.props, {
            id: "".concat(_this.id, "-").concat(tile.x, "-").concat(tile.y, "-").concat(tile.z),
            data: tile.data,
            visible: isVisible,
            _offset: 0,
            tile: tile,
            highlightedObjectIndex: highlightedObjectIndex
          }));

          tile.layers = (0, _core._flatten)(layers, Boolean);
        } else if (tile.layers[0] && (tile.layers[0].props.visible !== isVisible || tile.layers[0].props.highlightedObjectIndex !== highlightedObjectIndex)) {
          tile.layers = tile.layers.map(function (layer) {
            return layer.clone({
              visible: isVisible,
              highlightedObjectIndex: highlightedObjectIndex
            });
          });
        }

        return tile.layers;
      });
    }
  }, {
    key: "isLoaded",
    get: function get() {
      var tileset = this.state.tileset;
      return tileset.selectedTiles.every(function (tile) {
        return tile.layers && tile.layers.every(function (layer) {
          return layer.isLoaded;
        });
      });
    }
  }]);
  return TileLayer;
}(_core.CompositeLayer);

exports["default"] = TileLayer;
TileLayer.layerName = 'TileLayer';
TileLayer.defaultProps = defaultProps;
//# sourceMappingURL=tile-layer.js.map