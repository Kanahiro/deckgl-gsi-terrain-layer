{"version":3,"sources":["../../../../src/text-layer/multi-icon-layer/multi-icon-layer.js"],"names":["IconLayer","fs","DEFAULT_GAMMA","DEFAULT_BUFFER","EMPTY_ARRAY","defaultProps","backgroundColor","type","value","optional","getIconOffsets","x","offsets","alphaCutoff","MultiIconLayer","getShaders","Object","assign","inject","initializeState","attributeManager","getAttributeManager","addInstanced","instanceOffsets","size","accessor","instancePickingColors","object","index","target","encodePickingColor","updateState","updateParams","oldProps","props","Array","isArray","map","c","slice","setState","draw","uniforms","sdf","state","shouldDrawBackground","buffer","gamma","Boolean","getInstanceOffset","icons","from","icon","getInstanceColorMode","getInstanceIconFrame","layerName"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport GL from '@luma.gl/constants';\nimport IconLayer from '../../icon-layer/icon-layer';\n\nimport fs from './multi-icon-layer-fragment.glsl';\n\n// TODO expose as layer properties\nconst DEFAULT_GAMMA = 0.2;\nconst DEFAULT_BUFFER = 192.0 / 256;\nconst EMPTY_ARRAY = [];\n\nconst defaultProps = {\n  backgroundColor: {type: 'color', value: null, optional: true},\n  getIconOffsets: {type: 'accessor', value: x => x.offsets},\n  alphaCutoff: 0\n};\n\nexport default class MultiIconLayer extends IconLayer {\n  getShaders() {\n    return Object.assign({}, super.getShaders(), {\n      inject: {\n        'vs:#decl': `\n  uniform float gamma;\n  varying float vGamma;\n`,\n        'vs:#main-end': `\n  vGamma = gamma / (sizeScale * iconSize.y);\n`\n      },\n      fs\n    });\n  }\n\n  initializeState() {\n    super.initializeState();\n\n    const attributeManager = this.getAttributeManager();\n    attributeManager.addInstanced({\n      instanceOffsets: {\n        size: 2,\n        accessor: 'getIconOffsets'\n      },\n      instancePickingColors: {\n        type: GL.UNSIGNED_BYTE,\n        size: 3,\n        accessor: (object, {index, target: value}) => this.encodePickingColor(index, value)\n      }\n    });\n  }\n\n  updateState(updateParams) {\n    super.updateState(updateParams);\n    const {oldProps, props} = updateParams;\n\n    if (props.backgroundColor !== oldProps.backgroundColor) {\n      const backgroundColor = Array.isArray(props.backgroundColor)\n        ? props.backgroundColor.map(c => c / 255.0).slice(0, 3)\n        : null;\n      this.setState({backgroundColor});\n    }\n  }\n\n  draw({uniforms}) {\n    const {sdf} = this.props;\n    const {backgroundColor} = this.state;\n    const shouldDrawBackground = Array.isArray(backgroundColor);\n\n    super.draw({\n      uniforms: Object.assign({}, uniforms, {\n        // Refer the following doc about gamma and buffer\n        // https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817\n        buffer: DEFAULT_BUFFER,\n        gamma: DEFAULT_GAMMA,\n        sdf: Boolean(sdf),\n        backgroundColor: backgroundColor || [0, 0, 0],\n        shouldDrawBackground\n      })\n    });\n  }\n\n  getInstanceOffset(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceOffset(icon)) : EMPTY_ARRAY;\n  }\n\n  getInstanceColorMode(icons) {\n    return 1; // mask\n  }\n\n  getInstanceIconFrame(icons) {\n    return icons ? Array.from(icons).map(icon => super.getInstanceIconFrame(icon)) : EMPTY_ARRAY;\n  }\n}\n\nMultiIconLayer.layerName = 'MultiIconLayer';\nMultiIconLayer.defaultProps = defaultProps;\n"],"file":"multi-icon-layer.js"}