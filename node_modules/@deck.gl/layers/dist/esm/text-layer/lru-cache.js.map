{"version":3,"sources":["../../../src/text-layer/lru-cache.js"],"names":["LRUCache","limit","clear","_cache","_order","key","value","_deleteOrder","_appendOrder","Object","keys","length","_deleteCache","index","findIndex","o","splice","push"],"mappings":";;;IAOqBA,Q;AACnB,sBAAuB;AAAA,QAAXC,KAAW,uEAAH,CAAG;;AAAA;;AACrB,SAAKA,KAAL,GAAaA,KAAb;AAEA,SAAKC,KAAL;AACD;;;;4BAEO;AACN,WAAKC,MAAL,GAAc,EAAd;AAEA,WAAKC,MAAL,GAAc,EAAd;AACD;;;wBAEGC,G,EAAK;AACP,UAAMC,KAAK,GAAG,KAAKH,MAAL,CAAYE,GAAZ,CAAd;;AACA,UAAIC,KAAJ,EAAW;AAET,aAAKC,YAAL,CAAkBF,GAAlB;;AACA,aAAKG,YAAL,CAAkBH,GAAlB;AACD;;AACD,aAAOC,KAAP;AACD;;;wBAEGD,G,EAAKC,K,EAAO;AACd,UAAI,CAAC,KAAKH,MAAL,CAAYE,GAAZ,CAAL,EAAuB;AAErB,YAAII,MAAM,CAACC,IAAP,CAAY,KAAKP,MAAjB,EAAyBQ,MAAzB,KAAoC,KAAKV,KAA7C,EAAoD;AAClD,yBAAY,KAAKG,MAAL,CAAY,CAAZ,CAAZ;AACD;;AAED,aAAKD,MAAL,CAAYE,GAAZ,IAAmBC,KAAnB;;AACA,aAAKE,YAAL,CAAkBH,GAAlB;AACD,OARD,MAQO;AAEL,uBAAYA,GAAZ;AAEA,aAAKF,MAAL,CAAYE,GAAZ,IAAmBC,KAAnB;;AACA,aAAKE,YAAL,CAAkBH,GAAlB;AACD;AACF;;;4BAEMA,G,EAAK;AACV,UAAMC,KAAK,GAAG,KAAKH,MAAL,CAAYE,GAAZ,CAAd;;AACA,UAAIC,KAAJ,EAAW;AACT,aAAKM,YAAL,CAAkBP,GAAlB;;AACA,aAAKE,YAAL,CAAkBF,GAAlB;AACD;AACF;;;iCAEYA,G,EAAK;AAChB,aAAO,KAAKF,MAAL,CAAYE,GAAZ,CAAP;AACD;;;iCAEYA,G,EAAK;AAChB,UAAMQ,KAAK,GAAG,KAAKT,MAAL,CAAYU,SAAZ,CAAsB,UAAAC,CAAC;AAAA,eAAIA,CAAC,KAAKV,GAAV;AAAA,OAAvB,CAAd;;AACA,UAAIQ,KAAK,IAAI,CAAb,EAAgB;AACd,aAAKT,MAAL,CAAYY,MAAZ,CAAmBH,KAAnB,EAA0B,CAA1B;AACD;AACF;;;iCAEYR,G,EAAK;AAChB,WAAKD,MAAL,CAAYa,IAAZ,CAAiBZ,GAAjB;AACD;;;;;;SA9DkBL,Q","sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\n\nexport default class LRUCache {\n  constructor(limit = 5) {\n    this.limit = limit;\n\n    this.clear();\n  }\n\n  clear() {\n    this._cache = {};\n    // access/update order, first item is oldest, last item is newest\n    this._order = [];\n  }\n\n  get(key) {\n    const value = this._cache[key];\n    if (value) {\n      // update order\n      this._deleteOrder(key);\n      this._appendOrder(key);\n    }\n    return value;\n  }\n\n  set(key, value) {\n    if (!this._cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this._cache).length === this.limit) {\n        this.delete(this._order[0]);\n      }\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this._cache[key] = value;\n      this._appendOrder(key);\n    }\n  }\n\n  delete(key) {\n    const value = this._cache[key];\n    if (value) {\n      this._deleteCache(key);\n      this._deleteOrder(key);\n    }\n  }\n\n  _deleteCache(key) {\n    delete this._cache[key];\n  }\n\n  _deleteOrder(key) {\n    const index = this._order.findIndex(o => o === key);\n    if (index >= 0) {\n      this._order.splice(index, 1);\n    }\n  }\n\n  _appendOrder(key) {\n    this._order.push(key);\n  }\n}\n"],"file":"lru-cache.js"}