{"version":3,"sources":["../../../src/geojson-layer/geojson.js"],"names":["log","getGeojsonFeatures","geojson","Array","isArray","assert","type","features","geometry","separateGeojsonFeatures","wrapFeature","dataRange","separated","pointFeatures","lineFeatures","polygonFeatures","polygonOutlineFeatures","startRow","endRow","length","featureIndex","feature","geometries","i","subGeometry","separateGeometry","sourceFeature","sourceFeatureIndex","coordinates","validateGeometry","warn","push","forEach","point","path","polygon","COORDINATE_NEST_LEVEL","Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon","nestLevel","Number","isFinite"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {log} from '@deck.gl/core';\n\n/**\n * \"Normalizes\" complete or partial GeoJSON data into iterable list of features\n * Can accept GeoJSON geometry or \"Feature\", \"FeatureCollection\" in addition\n * to plain arrays and iterables.\n * Works by extracting the feature array or wrapping single objects in an array,\n * so that subsequent code can simply iterate over features.\n *\n * @param {object} geojson - geojson data\n * @param {Object|Array} data - geojson object (FeatureCollection, Feature or\n *  Geometry) or array of features\n * @return {Array|\"iteratable\"} - iterable list of features\n */\nexport function getGeojsonFeatures(geojson) {\n  // If array, assume this is a list of features\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  log.assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      // Wrap the feature in a 'Features' array\n      return [geojson];\n    case 'FeatureCollection':\n      // Just return the 'Features' array from the collection\n      log.assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n    default:\n      // Assume it's a geometry, we'll check type in separateGeojsonFeatures\n      // Wrap the geometry object in a 'Feature' object and wrap in an array\n      return [{geometry: geojson}];\n  }\n}\n\n// Linearize\nexport function separateGeojsonFeatures(features, wrapFeature, dataRange = {}) {\n  const separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n  const {startRow = 0, endRow = features.length} = dataRange;\n\n  for (let featureIndex = startRow; featureIndex < endRow; featureIndex++) {\n    const feature = features[featureIndex];\n\n    log.assert(feature && feature.geometry, 'GeoJSON does not have geometry');\n\n    const {geometry} = feature;\n\n    if (geometry.type === 'GeometryCollection') {\n      log.assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      const {geometries} = geometry;\n      for (let i = 0; i < geometries.length; i++) {\n        const subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, wrapFeature, feature, featureIndex);\n      }\n    } else {\n      separateGeometry(geometry, separated, wrapFeature, feature, featureIndex);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(geometry, separated, wrapFeature, sourceFeature, sourceFeatureIndex) {\n  const {type, coordinates} = geometry;\n  const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = separated;\n\n  if (!validateGeometry(type, coordinates)) {\n    // Avoid hard failure if some features are malformed\n    log.warn(`${type} coordinates are malformed`)();\n    return;\n  }\n\n  // Split each feature, but keep track of the source feature and index (for Multi* geometries)\n  switch (type) {\n    case 'Point':\n      pointFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiPoint':\n      coordinates.forEach(point => {\n        pointFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Point', coordinates: point}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'LineString':\n      lineFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      break;\n    case 'MultiLineString':\n      // Break multilinestrings into multiple lines\n      coordinates.forEach(path => {\n        lineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'Polygon':\n      polygonFeatures.push(\n        wrapFeature(\n          {\n            geometry\n          },\n          sourceFeature,\n          sourceFeatureIndex\n        )\n      );\n      // Break polygon into multiple lines\n      coordinates.forEach(path => {\n        polygonOutlineFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'LineString', coordinates: path}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n      });\n      break;\n    case 'MultiPolygon':\n      // Break multipolygons into multiple polygons\n      coordinates.forEach(polygon => {\n        polygonFeatures.push(\n          wrapFeature(\n            {\n              geometry: {type: 'Polygon', coordinates: polygon}\n            },\n            sourceFeature,\n            sourceFeatureIndex\n          )\n        );\n        // Break polygon into multiple lines\n        polygon.forEach(path => {\n          polygonOutlineFeatures.push(\n            wrapFeature(\n              {\n                geometry: {type: 'LineString', coordinates: path}\n              },\n              sourceFeature,\n              sourceFeatureIndex\n            )\n          );\n        });\n      });\n      break;\n    default:\n  }\n}\n\n/**\n * Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,\n * only the following:\n   - geometry.type is supported\n   - geometry.coordinate has correct nesting level\n */\nconst COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\n\nexport function validateGeometry(type, coordinates) {\n  let nestLevel = COORDINATE_NEST_LEVEL[type];\n\n  log.assert(nestLevel, `Unknown GeoJSON type ${type}`);\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n\n  return coordinates && Number.isFinite(coordinates[0]);\n}\n"],"file":"geojson.js"}