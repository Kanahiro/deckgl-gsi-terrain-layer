{"version":3,"sources":["../../../src/solid-polygon-layer/polygon-tesselator.js"],"names":["PolygonTesselator","opts","fp64","IndexType","Uint32Array","attributes","positions","size","type","Float64Array","Float32Array","vertexValid","Uint8ClampedArray","indices","attributeName","subarray","vertexCount","externalIndices","buffers","value","length","polygon","normalize","Polygon","positionSize","resolution","holeIndices","gridResolution","edgeTypes","wrapLongitude","maxLatitude","Array","isArray","Number","isFinite","subPolygon","getGeometrySize","buffer","context","geometrySize","updateGeometryAttributes","vertexStart","indexStart","indexStarts","geometryIndex","_updateIndices","_updatePositions","_updateVertexValid","offset","typedArrayManager","target","i","getSurfaceIndices","preproject","allocate","copy","j","polygonPositions","x","y","z","set","fill","Tesselator"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Handles tesselation of polygons with holes\n// - 2D surfaces\n// - 2D outlines\n// - 3D surfaces (top and sides only)\n// - 3D wireframes (not yet)\nimport * as Polygon from './polygon';\nimport {Tesselator} from '@deck.gl/core';\nimport {cutPolygonByGrid, cutPolygonByMercatorBounds} from '@math.gl/polygon';\n\n// This class is set up to allow querying one attribute at a time\n// the way the AttributeManager expects it\nexport default class PolygonTesselator extends Tesselator {\n  constructor(opts) {\n    const {fp64, IndexType = Uint32Array} = opts;\n    super({\n      ...opts,\n      attributes: {\n        positions: {size: 3, type: fp64 ? Float64Array : Float32Array},\n        vertexValid: {type: Uint8ClampedArray, size: 1},\n        indices: {type: IndexType, size: 1}\n      }\n    });\n  }\n\n  /* Getters */\n  get(attributeName) {\n    const {attributes} = this;\n    if (attributeName === 'indices') {\n      return attributes.indices && attributes.indices.subarray(0, this.vertexCount);\n    }\n\n    return attributes[attributeName];\n  }\n\n  /* Implement base Tesselator interface */\n  updateGeometry(opts) {\n    super.updateGeometry(opts);\n\n    const externalIndices = this.buffers.indices;\n    if (externalIndices) {\n      this.vertexCount = (externalIndices.value || externalIndices).length;\n    }\n  }\n\n  normalizeGeometry(polygon) {\n    if (this.normalize) {\n      polygon = Polygon.normalize(polygon, this.positionSize);\n      if (this.opts.resolution) {\n        return cutPolygonByGrid(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          gridResolution: this.opts.resolution,\n          edgeTypes: true\n        });\n      }\n      if (this.opts.wrapLongitude) {\n        return cutPolygonByMercatorBounds(polygon.positions || polygon, polygon.holeIndices, {\n          size: this.positionSize,\n          maxLatitude: 86,\n          edgeTypes: true\n        });\n      }\n    }\n    return polygon;\n  }\n\n  getGeometrySize(polygon) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      let size = 0;\n      for (const subPolygon of polygon) {\n        size += this.getGeometrySize(subPolygon);\n      }\n      return size;\n    }\n    return (polygon.positions || polygon).length / this.positionSize;\n  }\n\n  getGeometryFromBuffer(buffer) {\n    if (this.normalize || !this.buffers.indices) {\n      return super.getGeometryFromBuffer(buffer);\n    }\n    // we don't need to read the positions if no normalization/tesselation\n    return () => null;\n  }\n\n  updateGeometryAttributes(polygon, context) {\n    if (Array.isArray(polygon) && !Number.isFinite(polygon[0])) {\n      for (const subPolygon of polygon) {\n        const geometrySize = this.getGeometrySize(subPolygon);\n        context.geometrySize = geometrySize;\n        this.updateGeometryAttributes(subPolygon, context);\n        context.vertexStart += geometrySize;\n        context.indexStart = this.indexStarts[context.geometryIndex + 1];\n      }\n    } else {\n      this._updateIndices(polygon, context);\n      this._updatePositions(polygon, context);\n      this._updateVertexValid(polygon, context);\n    }\n  }\n\n  // Flatten the indices array\n  _updateIndices(polygon, {geometryIndex, vertexStart: offset, indexStart}) {\n    const {attributes, indexStarts, typedArrayManager} = this;\n\n    let target = attributes.indices;\n    if (!target) {\n      return;\n    }\n    let i = indexStart;\n\n    // 1. get triangulated indices for the internal areas\n    const indices = Polygon.getSurfaceIndices(polygon, this.positionSize, this.opts.preproject);\n\n    // make sure the buffer is large enough\n    target = typedArrayManager.allocate(target, indexStart + indices.length, {\n      copy: true\n    });\n\n    // 2. offset each index by the number of indices in previous polygons\n    for (let j = 0; j < indices.length; j++) {\n      target[i++] = indices[j] + offset;\n    }\n\n    indexStarts[geometryIndex + 1] = indexStart + indices.length;\n    attributes.indices = target;\n  }\n\n  // Flatten out all the vertices of all the sub subPolygons\n  _updatePositions(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {positions},\n      positionSize\n    } = this;\n    if (!positions) {\n      return;\n    }\n    const polygonPositions = polygon.positions || polygon;\n\n    for (let i = vertexStart, j = 0; j < geometrySize; i++, j++) {\n      const x = polygonPositions[j * positionSize];\n      const y = polygonPositions[j * positionSize + 1];\n      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n\n      positions[i * 3] = x;\n      positions[i * 3 + 1] = y;\n      positions[i * 3 + 2] = z;\n    }\n  }\n\n  _updateVertexValid(polygon, {vertexStart, geometrySize}) {\n    const {\n      attributes: {vertexValid},\n      positionSize\n    } = this;\n    const holeIndices = polygon && polygon.holeIndices;\n    /* We are reusing the some buffer for `nextPositions` by offseting one vertex\n     * to the left. As a result,\n     * the last vertex of each ring overlaps with the first vertex of the next ring.\n     * `vertexValid` is used to mark the end of each ring so we don't draw these\n     * segments:\n      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...\n      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...\n      vertexValid    1  1  1  1  0  1  1  0  1 ...\n     */\n    if (polygon && polygon.edgeTypes) {\n      vertexValid.set(polygon.edgeTypes, vertexStart);\n    } else {\n      vertexValid.fill(1, vertexStart, vertexStart + geometrySize);\n    }\n    if (holeIndices) {\n      for (let j = 0; j < holeIndices.length; j++) {\n        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;\n      }\n    }\n    vertexValid[vertexStart + geometrySize - 1] = 0;\n  }\n}\n"],"file":"polygon-tesselator.js"}