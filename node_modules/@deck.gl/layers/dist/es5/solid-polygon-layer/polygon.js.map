{"version":3,"sources":["../../../src/solid-polygon-layer/polygon.js"],"names":["validate","polygon","positions","Array","isArray","ArrayBuffer","isView","Error","isSimple","length","Number","isFinite","isNestedRingClosed","simplePolygon","p0","p1","isFlatRingClosed","size","startIndex","endIndex","i","copyNestedRing","target","targetStartIndex","targetIndex","len","j","copyFlatRing","srcStartIndex","srcEndIndex","srcLength","normalize","positionSize","holeIndices","srcPositions","srcHoleIndices","push","pop","getSurfaceIndices","normalizedPolygon","preproject","map","positionIndex","n","slice","p","xy"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n/* eslint-disable max-params */\nimport earcut from 'earcut';\n\n// 4 data formats are supported:\n// Simple Polygon: an array of points\n// Complex Polygon: an array of array of points (array of rings)\n//   with the first ring representing the outer hull and other rings representing holes\n// Simple Flat: an array of numbers (flattened \"simple polygon\")\n// Complex Flat: {position: array<number>, holeIndices: array<number>}\n//   (flattened \"complex polygon\")\n\n/**\n * Ensure a polygon is valid format\n * @param {Array|Object} polygon\n */\nfunction validate(polygon) {\n  polygon = (polygon && polygon.positions) || polygon;\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\n/**\n * Check if a polygon is simple or complex\n * @param {Array} polygon - either a complex or simple polygon\n * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)\n */\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\n/**\n * Check if a simple polygon is a closed ring\n * @param {Array} simplePolygon - array of points\n * @return {Boolean} - true if the simple polygon is a closed ring\n */\nfunction isNestedRingClosed(simplePolygon) {\n  // check if first and last vertex are the same\n  const p0 = simplePolygon[0];\n  const p1 = simplePolygon[simplePolygon.length - 1];\n\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\n/**\n * Check if a simple flat array is a closed ring\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} startIndex - start index of the path in the positions array\n * @param {Number} endIndex - end index of the path in the positions array\n * @return {Boolean} - true if the simple flat array is a closed ring\n */\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (let i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Copy a simple polygon coordinates into a flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} simplePolygon - array of points\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  let targetIndex = targetStartIndex;\n  const len = simplePolygon.length;\n  for (let i = 0; i < len; i++) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (let j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[0][j] || 0;\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Copy a simple flat array into another flat array, closes the ring if needed.\n * @param {Float64Array} target - destination\n * @param {Number} targetStartIndex - index in the destination to start copying into\n * @param {Array} positions - array of numbers\n * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [srcStartIndex] - start index of the path in the positions array\n * @param {Number} [srcEndIndex] - end index of the path in the positions array\n * @returns {Number} - the index of the write head in the destination\n */\nfunction copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex) {\n  srcEndIndex = srcEndIndex || positions.length;\n  const srcLength = srcEndIndex - srcStartIndex;\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n  let targetIndex = targetStartIndex;\n\n  for (let i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (let i = 0; i < size; i++) {\n      target[targetIndex++] = positions[srcStartIndex + i];\n    }\n  }\n  return targetIndex;\n}\n\n/**\n * Normalize any polygon representation into the \"complex flat\" format\n * @param {Array|Object} polygon\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @param {Number} [vertexCount] - pre-computed vertex count in the polygon.\n *   If provided, will skip counting.\n * @return {Object} - {positions: <Float64Array>, holeIndices: <Array|null>}\n */\n/* eslint-disable max-statements */\nexport function normalize(polygon, positionSize) {\n  validate(polygon);\n\n  const positions = [];\n  const holeIndices = [];\n\n  if (polygon.positions) {\n    // complex flat\n    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;\n\n    if (srcHoleIndices) {\n      let targetIndex = 0;\n      // split the positions array into `holeIndices.length + 1` rings\n      // holeIndices[-1] falls back to 0\n      // holeIndices[holeIndices.length] falls back to positions.length\n      for (let i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(\n          positions,\n          targetIndex,\n          srcPositions,\n          positionSize,\n          srcHoleIndices[i - 1],\n          srcHoleIndices[i]\n        );\n        holeIndices.push(targetIndex);\n      }\n      // The last one is not a starting index of a hole, remove\n      holeIndices.pop();\n\n      return {positions, holeIndices};\n    }\n    polygon = srcPositions;\n  }\n  if (Number.isFinite(polygon[0])) {\n    // simple flat\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return positions;\n  }\n  if (!isSimple(polygon)) {\n    // complex polygon\n    let targetIndex = 0;\n\n    for (const simplePolygon of polygon) {\n      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize);\n      holeIndices.push(targetIndex);\n    }\n    // The last one is not a starting index of a hole, remove\n    holeIndices.pop();\n    // last index points to the end of the array, remove it\n    return {positions, holeIndices};\n  }\n  // simple polygon\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return positions;\n}\n/* eslint-enable max-statements */\n\n/*\n * Get vertex indices for drawing polygon mesh\n * @param {Object} normalizedPolygon - {positions, holeIndices}\n * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)\n * @returns {Array} array of indices\n */\nexport function getSurfaceIndices(normalizedPolygon, positionSize, preproject) {\n  let holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);\n  }\n  let positions = normalizedPolygon.positions || normalizedPolygon;\n\n  if (preproject) {\n    // When tesselating lnglat coordinates, project them to the common space for accuracy\n    const n = positions.length;\n    // Clone the array\n    positions = positions.slice();\n    const p = [];\n    for (let i = 0; i < n; i += positionSize) {\n      p[0] = positions[i];\n      p[1] = positions[i + 1];\n      const xy = preproject(p);\n      positions[i] = xy[0];\n      positions[i + 1] = xy[1];\n    }\n  }\n\n  // Let earcut triangulate the polygon\n  return earcut(positions, holeIndices, positionSize);\n}\n"],"file":"polygon.js"}