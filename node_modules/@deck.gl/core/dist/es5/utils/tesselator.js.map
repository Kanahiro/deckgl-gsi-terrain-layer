{"version":3,"sources":["../../../src/utils/tesselator.js"],"names":["Tesselator","opts","attributes","typedArrayManager","defaultTypedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","Object","seal","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","startRow","endRow","geometry","startIndex","Error","value","ArrayBuffer","isView","offset","stride","copy","name","release","def","allocate","visitor","iterable","objectInfo","object","index","Infinity","normalizedData","_forEachGeometry","dataIndex","normalizeGeometry","getGeometrySize","length","buffer","Buffer","byteStride","byteLength","bufferValue","elementStride","BYTES_PER_ELEMENT","_allocate","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex","updateGeometryAttributes"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices, 'binary data missing startIndices');\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value), 'cannot read geometries');\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          geometry = this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"file":"tesselator.js"}