{"version":3,"sources":["../../../../src/lib/attribute/attribute-transition-manager.js"],"names":["TRANSITION_TYPES","interpolation","GPUInterpolationTransition","spring","GPUSpringTransition","AttributeTransitionManager","gl","id","timeline","transitions","needsRedraw","numInstances","Transform","isSupported","log","warn","attributeName","_removeTransition","attributes","attribute","settings","getTransitionSetting","_updateAttribute","transition","inProgress","animatedAttributes","attributeInTransition","updated","update","cancel","isNew","type","TransitionType","error","start"],"mappings":"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","sourcesContent":["import {Transform} from '@luma.gl/core';\nimport GPUInterpolationTransition from '../../transitions/gpu-interpolation-transition';\nimport GPUSpringTransition from '../../transitions/gpu-spring-transition';\nimport log from '../../utils/log';\n\nconst TRANSITION_TYPES = {\n  interpolation: GPUInterpolationTransition,\n  spring: GPUSpringTransition\n};\n\nexport default class AttributeTransitionManager {\n  constructor(gl, {id, timeline}) {\n    this.id = id;\n    this.gl = gl;\n    this.timeline = timeline;\n\n    this.transitions = {};\n    this.needsRedraw = false;\n    this.numInstances = 1;\n\n    if (Transform.isSupported(gl)) {\n      this.isSupported = true;\n    } else if (gl) {\n      // This class may be instantiated without a WebGL context (e.g. web worker)\n      log.warn('WebGL2 not supported by this browser. Transition animation is disabled.')();\n    }\n  }\n\n  finalize() {\n    for (const attributeName in this.transitions) {\n      this._removeTransition(attributeName);\n    }\n  }\n\n  /* Public methods */\n\n  // Called when attribute manager updates\n  // Check the latest attributes for updates.\n  update({attributes, transitions = {}, numInstances}) {\n    // Transform class will crash if elementCount is 0\n    this.numInstances = numInstances || 1;\n\n    if (!this.isSupported) {\n      return;\n    }\n\n    for (const attributeName in attributes) {\n      const attribute = attributes[attributeName];\n      const settings = attribute.getTransitionSetting(transitions);\n\n      // this attribute might not support transitions?\n      if (!settings) continue; // eslint-disable-line no-continue\n      this._updateAttribute(attributeName, attribute, settings);\n    }\n\n    for (const attributeName in this.transitions) {\n      const attribute = attributes[attributeName];\n      if (!attribute || !attribute.getTransitionSetting(transitions)) {\n        // Animated attribute has been removed\n        this._removeTransition(attributeName);\n      }\n    }\n  }\n\n  // Returns `true` if attribute is transition-enabled\n  hasAttribute(attributeName) {\n    const transition = this.transitions[attributeName];\n    return transition && transition.inProgress;\n  }\n\n  // Get all the animated attributes\n  getAttributes() {\n    const animatedAttributes = {};\n\n    for (const attributeName in this.transitions) {\n      const transition = this.transitions[attributeName];\n      if (transition.inProgress) {\n        animatedAttributes[attributeName] = transition.attributeInTransition;\n      }\n    }\n\n    return animatedAttributes;\n  }\n\n  /* eslint-disable max-statements */\n  // Called every render cycle, run transform feedback\n  // Returns `true` if anything changes\n  run() {\n    if (!this.isSupported || this.numInstances === 0) {\n      return false;\n    }\n\n    for (const attributeName in this.transitions) {\n      const updated = this.transitions[attributeName].update();\n      if (updated) {\n        this.needsRedraw = true;\n      }\n    }\n\n    const needsRedraw = this.needsRedraw;\n    this.needsRedraw = false;\n    return needsRedraw;\n  }\n  /* eslint-enable max-statements */\n\n  /* Private methods */\n  _removeTransition(attributeName) {\n    this.transitions[attributeName].cancel();\n    delete this.transitions[attributeName];\n  }\n\n  // Check an attributes for updates\n  // Returns a transition object if a new transition is triggered.\n  _updateAttribute(attributeName, attribute, settings) {\n    const transition = this.transitions[attributeName];\n    // an attribute can change transition type when it updates\n    // let's remove the transition when that happens so we can create the new transition type\n    // TODO: when switching transition types, make sure to carry over the attribute's\n    // previous buffers, currentLength, startIndices, etc, to be used as the starting point\n    // for the next transition\n    let isNew = !transition || transition.type !== settings.type;\n    if (isNew) {\n      if (transition) {\n        this._removeTransition(attributeName);\n      }\n\n      const TransitionType = TRANSITION_TYPES[settings.type];\n      if (TransitionType) {\n        this.transitions[attributeName] = new TransitionType({\n          attribute,\n          timeline: this.timeline,\n          gl: this.gl\n        });\n      } else {\n        log.error(`unsupported transition type '${settings.type}'`)();\n        isNew = false;\n      }\n    }\n\n    if (isNew || attribute.needsRedraw()) {\n      this.needsRedraw = true;\n      this.transitions[attributeName].start(settings, this.numInstances);\n    }\n  }\n}\n"],"file":"attribute-transition-manager.js"}