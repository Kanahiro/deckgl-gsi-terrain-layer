{"version":3,"sources":["../../../../src/lib/attribute/attribute.js"],"names":["Attribute","gl","opts","transition","noAlloc","update","accessor","transform","startIndices","Object","assign","settings","_autoUpdater","state","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","range","FULL","seal","_validateAttributeUpdaters","clearChangedFlags","id","concat","Boolean","layerSettings","supportsTransition","userSettings","Array","isArray","find","a","reason","dataRange","setNeedsRedraw","startRow","endRow","Infinity","add","EMPTY","setData","numInstances","Number","isFinite","copy","data","props","context","updated","call","value","constant","buffer","byteLength","byteOffset","startOffset","getVertexOffset","endOffset","length","size","_checkAttributeArray","clearNeedsUpdate","undefined","hasChanged","ArrayBuffer","isView","needsNormalize","stride","offset","nested","row","vertexIndex","shaderAttributeDefs","shaderAttributes","shaderAttributeName","attribute","accessorFunc","i","iterable","objectInfo","object","index","objectValue","numVertices","startIndex","item","_normalizeValue","set","target","source","start","count","hasUpdater","Error","limit","Math","min","valid","layout","DataColumn"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;AACA;;AACA;;AACA;;AACA;;AACA;;AACA;;;;;;;;;;;;IAEqBA,S;;;;;AACnB,qBAAYC,EAAZ,EAA2B;AAAA;;AAAA,QAAXC,IAAW,uEAAJ,EAAI;AAAA;AACzB,8BAAMD,EAAN,EAAUC,IAAV;AADyB,2BAWrBA,IAXqB,CAKvBC,UALuB;AAAA,QAKvBA,UALuB,iCAKV,KALU;AAAA,wBAWrBD,IAXqB,CAMvBE,OANuB;AAAA,QAMvBA,OANuB,8BAMb,KANa;AAAA,uBAWrBF,IAXqB,CAOvBG,MAPuB;AAAA,QAOvBA,MAPuB,6BAOd,IAPc;AAAA,yBAWrBH,IAXqB,CAQvBI,QARuB;AAAA,QAQvBA,QARuB,+BAQZ,IARY;AAAA,0BAWrBJ,IAXqB,CASvBK,SATuB;AAAA,QASvBA,SATuB,gCASX,IATW;AAAA,6BAWrBL,IAXqB,CAUvBM,YAVuB;AAAA,QAUvBA,YAVuB,mCAUR,IAVQ;AAazBC,IAAAA,MAAM,CAACC,MAAP,CAAc,MAAKC,QAAnB,EAA6B;AAC3BR,MAAAA,UAAU,EAAVA,UAD2B;AAE3BC,MAAAA,OAAO,EAAPA,OAF2B;AAG3BC,MAAAA,MAAM,EAAEA,MAAM,IAAKC,QAAQ,IAAI,MAAKM,YAHT;AAI3BN,MAAAA,QAAQ,EAARA,QAJ2B;AAK3BC,MAAAA,SAAS,EAATA;AAL2B,KAA7B;AAQAE,IAAAA,MAAM,CAACC,MAAP,CAAc,MAAKG,KAAnB,EAA0B;AACxBC,MAAAA,kBAAkB,EAAE,IADI;AAExBC,MAAAA,WAAW,EAAE,IAFW;AAGxBC,MAAAA,cAAc,EAAE,IAHQ;AAIxBC,MAAAA,WAAW,EAAE,IAJW;AAKxBC,MAAAA,WAAW,EAAE,KALW;AAMxBC,MAAAA,YAAY,EAAEC,KAAK,CAACC,IANI;AAOxBb,MAAAA,YAAY,EAAZA;AAPwB,KAA1B;AAUAC,IAAAA,MAAM,CAACa,IAAP,CAAY,MAAKX,QAAjB;AACAF,IAAAA,MAAM,CAACa,IAAP,CAAY,MAAKT,KAAjB;;AAGA,UAAKU,0BAAL;;AAnCyB;AAoC1B;;;;kCAUa;AACZ,aAAO,KAAKV,KAAL,CAAWI,WAAlB;AACD;;;kCAE6C;AAAA,qFAAJ,EAAI;AAAA,uCAAjCO,iBAAiC;AAAA,UAAjCA,iBAAiC,sCAAb,KAAa;;AAC5C,UAAMN,WAAW,GAAG,KAAKL,KAAL,CAAWK,WAA/B;AACA,WAAKL,KAAL,CAAWK,WAAX,GAAyBA,WAAW,IAAI,CAACM,iBAAzC;AACA,aAAON,WAAP;AACD;;;wCAEmB;AAAA,UACXZ,QADW,GACC,KAAKK,QADN,CACXL,QADW;AAIlB,aAAO,CAAC,KAAKmB,EAAN,EAAUC,MAAV,CAAkB,OAAOpB,QAAP,KAAoB,UAApB,IAAkCA,QAAnC,IAAgD,EAAjE,CAAP;AACD;;;yCAEoB;AACnB,aAAOqB,OAAO,CAAC,KAAKhB,QAAL,CAAcR,UAAf,CAAd;AACD;;;yCAGoBD,I,EAAM;AAAA,UAClBI,QADkB,GACN,KAAKK,QADC,CAClBL,QADkB;AAGzB,UAAMsB,aAAa,GAAG,KAAKjB,QAAL,CAAcR,UAApC;;AACA,UAAI,CAAC,KAAK0B,kBAAL,EAAL,EAAgC;AAC9B,eAAO,IAAP;AACD;;AAED,UAAMC,YAAY,GAAGC,KAAK,CAACC,OAAN,CAAc1B,QAAd,IACjBJ,IAAI,CAACI,QAAQ,CAAC2B,IAAT,CAAc,UAAAC,CAAC;AAAA,eAAIhC,IAAI,CAACgC,CAAD,CAAR;AAAA,OAAf,CAAD,CADa,GAEjBhC,IAAI,CAACI,QAAD,CAFR;AAKA,aAAO,2DAA4BwB,YAA5B,EAA0CF,aAA1C,CAAP;AACD;;;qCAE2C;AAAA,UAA7BO,MAA6B,uEAApB,KAAKV,EAAe;AAAA,UAAXW,SAAW;AAC1C,WAAKvB,KAAL,CAAWI,WAAX,GAAyB,KAAKJ,KAAL,CAAWI,WAAX,IAA0BkB,MAAnD;AACA,WAAKE,cAAL,CAAoBF,MAApB;;AACA,UAAIC,SAAJ,EAAe;AAAA,kCAC6BA,SAD7B,CACNE,QADM;AAAA,YACNA,QADM,oCACK,CADL;AAAA,gCAC6BF,SAD7B,CACQG,MADR;AAAA,YACQA,MADR,kCACiBC,QADjB;AAEb,aAAK3B,KAAL,CAAWM,YAAX,GAA0BC,KAAK,CAACqB,GAAN,CAAU,KAAK5B,KAAL,CAAWM,YAArB,EAAmC,CAACmB,QAAD,EAAWC,MAAX,CAAnC,CAA1B;AACD,OAHD,MAGO;AACL,aAAK1B,KAAL,CAAWM,YAAX,GAA0BC,KAAK,CAACC,IAAhC;AACD;AACF;;;uCAEkB;AACjB,WAAKR,KAAL,CAAWI,WAAX,GAAyB,KAAzB;AACA,WAAKJ,KAAL,CAAWM,YAAX,GAA0BC,KAAK,CAACsB,KAAhC;AACD;;;qCAEgC;AAAA,UAAlBP,MAAkB,uEAAT,KAAKV,EAAI;AAC/B,WAAKZ,KAAL,CAAWK,WAAX,GAAyB,KAAKL,KAAL,CAAWK,WAAX,IAA0BiB,MAAnD;AACD;;;2BAEMjC,I,EAAM;AAEX,WAAKyC,OAAL,CAAazC,IAAb;AACD;;;6BAEQ0C,Y,EAAc;AAAA,UACd/B,KADc,GACK,IADL,CACdA,KADc;AAAA,UACPF,QADO,GACK,IADL,CACPA,QADO;;AAGrB,UAAIA,QAAQ,CAACP,OAAb,EAAsB;AAEpB,eAAO,KAAP;AACD;;AAED,UAAIO,QAAQ,CAACN,MAAb,EAAqB;AACnB,gCAAOwC,MAAM,CAACC,QAAP,CAAgBF,YAAhB,CAAP;AACA,kHAAe;AACbA,UAAAA,YAAY,EAAZA,YADa;AAEbG,UAAAA,IAAI,EAAElC,KAAK,CAACM,YAAN,KAAuBC,KAAK,CAACC;AAFtB,SAAf;AAIA,eAAO,IAAP;AACD;;AAED,aAAO,KAAP;AACD;;;wCAEkD;AAAA,UAArCuB,YAAqC,SAArCA,YAAqC;AAAA,UAAvBI,IAAuB,SAAvBA,IAAuB;AAAA,UAAjBC,KAAiB,SAAjBA,KAAiB;AAAA,UAAVC,OAAU,SAAVA,OAAU;;AACjD,UAAI,CAAC,KAAKjC,WAAL,EAAL,EAAyB;AACvB,eAAO,KAAP;AACD;;AAHgD,UAMvCE,YANuC,GAQ7C,IAR6C,CAM/CN,KAN+C,CAMvCM,YANuC;AAAA,2BAQ7C,IAR6C,CAO/CR,QAP+C;AAAA,UAOpCN,MAPoC,kBAOpCA,MAPoC;AAAA,UAO5BD,OAP4B,kBAO5BA,OAP4B;AAUjD,UAAI+C,OAAO,GAAG,IAAd;;AACA,UAAI9C,MAAJ,EAAY;AAAA,mDAEuBc,YAFvB;AAAA;;AAAA;AAEV,8DAA+C;AAAA;AAAA,gBAAnCmB,SAAmC;AAAA,gBAAzBC,OAAyB;;AAC7ClC,YAAAA,MAAM,CAAC+C,IAAP,CAAYF,OAAZ,EAAqB,IAArB,EAA2B;AAACF,cAAAA,IAAI,EAAJA,IAAD;AAAOV,cAAAA,QAAQ,EAARA,SAAP;AAAiBC,cAAAA,MAAM,EAANA,OAAjB;AAAyBU,cAAAA,KAAK,EAALA,KAAzB;AAAgCL,cAAAA,YAAY,EAAZA;AAAhC,aAA3B;AACD;AAJS;AAAA;AAAA;AAAA;AAAA;;AAKV,YAAI,CAAC,KAAKS,KAAV,EAAiB,CAEhB,CAFD,MAEO,IACL,KAAKC,QAAL,IACA,KAAKC,MAAL,CAAYC,UAAZ,GAAyB,KAAKH,KAAL,CAAWG,UAAX,GAAwB,KAAKC,UAFjD,EAGL;AACA,eAAKd,OAAL,CAAa;AACXU,YAAAA,KAAK,EAAE,KAAKA,KADD;AAEXC,YAAAA,QAAQ,EAAE,KAAKA;AAFJ,WAAb;AAID,SARM,MAQA;AAAA,sDAC4BnC,YAD5B;AAAA;;AAAA;AACL,mEAA+C;AAAA;AAAA,kBAAnCmB,QAAmC;AAAA,kBAAzBC,MAAyB;;AAC7C,kBAAMmB,WAAW,GAAGb,MAAM,CAACC,QAAP,CAAgBR,QAAhB,IAA4B,KAAKqB,eAAL,CAAqBrB,QAArB,CAA5B,GAA6D,CAAjF;AACA,kBAAMsB,SAAS,GAAGf,MAAM,CAACC,QAAP,CAAgBP,MAAhB,IACd,KAAKoB,eAAL,CAAqBpB,MAArB,CADc,GAEdnC,OAAO,IAAI,CAACyC,MAAM,CAACC,QAAP,CAAgBF,YAAhB,CAAZ,GACE,KAAKS,KAAL,CAAWQ,MADb,GAEEjB,YAAY,GAAG,KAAKkB,IAJ1B;AAMA,+HAAsB;AAACJ,gBAAAA,WAAW,EAAXA,WAAD;AAAcE,gBAAAA,SAAS,EAATA;AAAd,eAAtB;AACD;AAVI;AAAA;AAAA;AAAA;AAAA;AAWN;;AACD,aAAKG,oBAAL;AACD,OA5BD,MA4BO;AACLZ,QAAAA,OAAO,GAAG,KAAV;AACD;;AAED,WAAKa,gBAAL;AACA,WAAK3B,cAAL;AAEA,aAAOc,OAAP;AACD;;;qCAIgBE,K,EAAO;AACtB,UAAIA,KAAK,KAAKY,SAAV,IAAuB,OAAOZ,KAAP,KAAiB,UAA5C,EAAwD;AACtD,eAAO,KAAP;AACD;;AAED,UAAMa,UAAU,GAAG,KAAKvB,OAAL,CAAa;AAACW,QAAAA,QAAQ,EAAE,IAAX;AAAiBD,QAAAA,KAAK,EAALA;AAAjB,OAAb,CAAnB;;AAEA,UAAIa,UAAJ,EAAgB;AACd,aAAK7B,cAAL;AACD;;AACD,WAAK2B,gBAAL;AACA,aAAO,IAAP;AACD;;;sCAKiBT,M,EAAQ;AAAA,UACjB1C,KADiB,GACR,IADQ,CACjBA,KADiB;;AAGxB,UAAI,CAAC0C,MAAL,EAAa;AACX1C,QAAAA,KAAK,CAACC,kBAAN,GAA2B,IAA3B;AACA,eAAO,KAAP;AACD;;AAED,WAAKkD,gBAAL;;AAEA,UAAInD,KAAK,CAACC,kBAAN,KAA6ByC,MAAjC,EAAyC;AACvC,eAAO,IAAP;AACD;;AACD1C,MAAAA,KAAK,CAACC,kBAAN,GAA2ByC,MAA3B;AACA,WAAKlB,cAAL;AACA,WAAKM,OAAL,CAAaY,MAAb;AACA,aAAO,IAAP;AACD;;;mCAKcA,M,EAA6B;AAAA,UAArB/C,YAAqB,uEAAN,IAAM;AAAA,UACnCK,KADmC,GAChB,IADgB,CACnCA,KADmC;AAAA,UAC5BF,QAD4B,GAChB,IADgB,CAC5BA,QAD4B;;AAG1C,UAAI,CAAC4C,MAAL,EAAa;AACX1C,QAAAA,KAAK,CAACE,WAAN,GAAoB,IAApB;AACAF,QAAAA,KAAK,CAACG,cAAN,GAAuB,IAAvB;AACA,eAAO,KAAP;AACD;;AAED,UAAIL,QAAQ,CAACP,OAAb,EAAsB;AAEpB,eAAO,KAAP;AACD;;AAED,UAAIS,KAAK,CAACE,WAAN,KAAsBwC,MAA1B,EAAkC;AAChC,aAAKS,gBAAL;AACA,eAAO,IAAP;AACD;;AACDnD,MAAAA,KAAK,CAACE,WAAN,GAAoBwC,MAApB;AACA,WAAKlB,cAAL;;AAEA,UAAI8B,WAAW,CAACC,MAAZ,CAAmBb,MAAnB,CAAJ,EAAgC;AAC9BA,QAAAA,MAAM,GAAG;AAACF,UAAAA,KAAK,EAAEE;AAAR,SAAT;AACD;;AACD,UAAMtC,WAAW,GAAGN,QAAQ,CAACJ,SAAT,IAAsBC,YAAY,KAAK,KAAKA,YAAhE;;AAEA,UAAIS,WAAJ,EAAiB;AACf,gCAAOkD,WAAW,CAACC,MAAZ,CAAmBb,MAAM,CAACF,KAA1B,CAAP,oBAAoD1C,QAAQ,CAACL,QAA7D;AACA,YAAM+D,cAAc,GAAGd,MAAM,CAACO,IAAP,IAAeP,MAAM,CAACO,IAAP,KAAgB,KAAKA,IAA3D;AAEAjD,QAAAA,KAAK,CAACG,cAAN,GAAuB,0CAAsBuC,MAAM,CAACF,KAA7B,EAAoC;AACzDS,UAAAA,IAAI,EAAEP,MAAM,CAACO,IAAP,IAAe,KAAKA,IAD+B;AAEzDQ,UAAAA,MAAM,EAAEf,MAAM,CAACe,MAF0C;AAGzDC,UAAAA,MAAM,EAAEhB,MAAM,CAACgB,MAH0C;AAIzD/D,UAAAA,YAAY,EAAZA,YAJyD;AAKzDgE,UAAAA,MAAM,EAAEH;AALiD,SAApC,CAAvB;AAQA,eAAO,KAAP;AACD;;AAED,WAAKL,gBAAL;AACA,WAAKrB,OAAL,CAAaY,MAAb;AACA,aAAO,IAAP;AACD;;;oCAEekB,G,EAAK;AAAA,UACZjE,YADY,GACI,IADJ,CACZA,YADY;AAEnB,UAAMkE,WAAW,GAAGlE,YAAY,GAAGA,YAAY,CAACiE,GAAD,CAAf,GAAuBA,GAAvD;AACA,aAAOC,WAAW,GAAG,KAAKZ,IAA1B;AACD;;;0CAEqB;AACpB,UAAMa,mBAAmB,GAAG,KAAKhE,QAAL,CAAciE,gBAAd,yCAAoC,KAAKnD,EAAzC,EAA8C,IAA9C,CAA5B;AACA,UAAMmD,gBAAgB,GAAG,EAAzB;;AAEA,WAAK,IAAMC,mBAAX,IAAkCF,mBAAlC,EAAuD;AACrDlE,QAAAA,MAAM,CAACC,MAAP,CACEkE,gBADF,uHAE4BC,mBAF5B,EAEiDF,mBAAmB,CAACE,mBAAD,CAFpE;AAID;;AAED,aAAOD,gBAAP;AACD;;;iCAGYE,S,SAA0D;AAAA,UAA9C9B,IAA8C,SAA9CA,IAA8C;AAAA,UAAxCV,QAAwC,SAAxCA,QAAwC;AAAA,UAA9BC,MAA8B,SAA9BA,MAA8B;AAAA,UAAtBU,KAAsB,SAAtBA,KAAsB;AAAA,UAAfL,YAAe,SAAfA,YAAe;;AACrE,UAAIkC,SAAS,CAACxB,QAAd,EAAwB;AACtB;AACD;;AAHoE,UAI9D3C,QAJ8D,GAIhBmE,SAJgB,CAI9DnE,QAJ8D;AAAA,UAIpDE,KAJoD,GAIhBiE,SAJgB,CAIpDjE,KAJoD;AAAA,UAI7CwC,KAJ6C,GAIhByB,SAJgB,CAI7CzB,KAJ6C;AAAA,UAItCS,IAJsC,GAIhBgB,SAJgB,CAItChB,IAJsC;AAAA,UAIhCtD,YAJgC,GAIhBsE,SAJgB,CAIhCtE,YAJgC;AAAA,UAM9DF,QAN8D,GAMvCK,QANuC,CAM9DL,QAN8D;AAAA,UAMpDC,SANoD,GAMvCI,QANuC,CAMpDJ,SANoD;AAOrE,UAAMwE,YAAY,GAChBlE,KAAK,CAACG,cAAN,KAAyB,OAAOV,QAAP,KAAoB,UAApB,GAAiCA,QAAjC,GAA4C2C,KAAK,CAAC3C,QAAD,CAA1E,CADF;AAGA,8BAAO,OAAOyE,YAAP,KAAwB,UAA/B,uBAAwDzE,QAAxD;AAEA,UAAI0E,CAAC,GAAGF,SAAS,CAACnB,eAAV,CAA0BrB,QAA1B,CAAR;;AAZqE,4BAatC,mCAAeU,IAAf,EAAqBV,QAArB,EAA+BC,MAA/B,CAbsC;AAAA,UAa9D0C,QAb8D,mBAa9DA,QAb8D;AAAA,UAapDC,UAboD,mBAapDA,UAboD;;AAAA,kDAchDD,QAdgD;AAAA;;AAAA;AAcrE,+DAA+B;AAAA,cAApBE,MAAoB;AAC7BD,UAAAA,UAAU,CAACE,KAAX;AAEA,cAAIC,WAAW,GAAGN,YAAY,CAACI,MAAD,EAASD,UAAT,CAA9B;;AACA,cAAI3E,SAAJ,EAAe;AAGb8E,YAAAA,WAAW,GAAG9E,SAAS,CAAC6C,IAAV,CAAe,IAAf,EAAqBiC,WAArB,CAAd;AACD;;AAED,cAAI7E,YAAJ,EAAkB;AAChB,gBAAM8E,WAAW,GACf,CAACJ,UAAU,CAACE,KAAX,GAAmB5E,YAAY,CAACqD,MAAb,GAAsB,CAAzC,GACGrD,YAAY,CAAC0E,UAAU,CAACE,KAAX,GAAmB,CAApB,CADf,GAEGxC,YAFJ,IAEoBpC,YAAY,CAAC0E,UAAU,CAACE,KAAZ,CAHlC;;AAIA,gBAAIC,WAAW,IAAItD,KAAK,CAACC,OAAN,CAAcqD,WAAW,CAAC,CAAD,CAAzB,CAAnB,EAAkD;AAChD,kBAAIE,UAAU,GAAGP,CAAjB;;AADgD,0DAE7BK,WAF6B;AAAA;;AAAA;AAEhD,uEAAgC;AAAA,sBAArBG,IAAqB;;AAC9BV,kBAAAA,SAAS,CAACW,eAAV,CAA0BD,IAA1B,EAAgCnC,KAAhC,EAAuCkC,UAAvC;;AACAA,kBAAAA,UAAU,IAAIzB,IAAd;AACD;AAL+C;AAAA;AAAA;AAAA;AAAA;AAMjD,aAND,MAMO,IAAIuB,WAAW,IAAIA,WAAW,CAACxB,MAAZ,GAAqBC,IAAxC,EAA8C;AACnDT,cAAAA,KAAK,CAACqC,GAAN,CAAUL,WAAV,EAAuBL,CAAvB;AACD,aAFM,MAEA;AACLF,cAAAA,SAAS,CAACW,eAAV,CAA0BJ,WAA1B,EAAuCH,UAAU,CAACS,MAAlD,EAA0D,CAA1D;;AACA,sCAAU;AACRA,gBAAAA,MAAM,EAAEtC,KADA;AAERuC,gBAAAA,MAAM,EAAEV,UAAU,CAACS,MAFX;AAGRE,gBAAAA,KAAK,EAAEb,CAHC;AAIRc,gBAAAA,KAAK,EAAER;AAJC,eAAV;AAMD;;AACDN,YAAAA,CAAC,IAAIM,WAAW,GAAGxB,IAAnB;AACD,WAvBD,MAuBO;AACLgB,YAAAA,SAAS,CAACW,eAAV,CAA0BJ,WAA1B,EAAuChC,KAAvC,EAA8C2B,CAA9C;;AACAA,YAAAA,CAAC,IAAIlB,IAAL;AACD;AACF;AAnDoE;AAAA;AAAA;AAAA;AAAA;AAoDtE;;;iDAI4B;AAAA,UACpBnD,QADoB,GACR,IADQ,CACpBA,QADoB;AAI3B,UAAMoF,UAAU,GAAGpF,QAAQ,CAACP,OAAT,IAAoB,OAAOO,QAAQ,CAACN,MAAhB,KAA2B,UAAlE;;AACA,UAAI,CAAC0F,UAAL,EAAiB;AACf,cAAM,IAAIC,KAAJ,qBAAuB,KAAKvE,EAA5B,iCAAN;AACD;AACF;;;2CAIsB;AAAA,UACd4B,KADc,GACL,IADK,CACdA,KADc;AAErB,UAAM4C,KAAK,GAAGC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAY,KAAKrC,IAAjB,CAAd;;AACA,UAAIT,KAAK,IAAIA,KAAK,CAACQ,MAAN,IAAgBoC,KAA7B,EAAoC;AAClC,YAAIG,KAAK,GAAG,IAAZ;;AACA,gBAAQH,KAAR;AACE,eAAK,CAAL;AACEG,YAAAA,KAAK,GAAGA,KAAK,IAAIvD,MAAM,CAACC,QAAP,CAAgBO,KAAK,CAAC,CAAD,CAArB,CAAjB;;AACF,eAAK,CAAL;AACE+C,YAAAA,KAAK,GAAGA,KAAK,IAAIvD,MAAM,CAACC,QAAP,CAAgBO,KAAK,CAAC,CAAD,CAArB,CAAjB;;AACF,eAAK,CAAL;AACE+C,YAAAA,KAAK,GAAGA,KAAK,IAAIvD,MAAM,CAACC,QAAP,CAAgBO,KAAK,CAAC,CAAD,CAArB,CAAjB;;AACF,eAAK,CAAL;AACE+C,YAAAA,KAAK,GAAGA,KAAK,IAAIvD,MAAM,CAACC,QAAP,CAAgBO,KAAK,CAAC,CAAD,CAArB,CAAjB;AACA;;AACF;AACE+C,YAAAA,KAAK,GAAG,KAAR;AAXJ;;AAcA,YAAI,CAACA,KAAL,EAAY;AACV,gBAAM,IAAIJ,KAAJ,2CAA6C,KAAKvE,EAAlD,EAAN;AACD;AACF;AACF;;;wBAnVkB;AACjB,aAAO,KAAKZ,KAAL,CAAWL,YAAlB;AACD,K;sBAEgB6F,M,EAAQ;AACvB,WAAKxF,KAAL,CAAWL,YAAX,GAA0B6F,MAA1B;AACD;;;EA7CoCC,sB","sourcesContent":["/* eslint-disable complexity */\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings} from './attribute-transition-utils';\n\nexport default class Attribute extends DataColumn {\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    const {\n      // deck.gl fields\n      transition = false,\n      noAlloc = false,\n      update = null,\n      accessor = null,\n      transform = null,\n      startIndices = null\n    } = opts;\n\n    Object.assign(this.settings, {\n      transition,\n      noAlloc,\n      update: update || (accessor && this._autoUpdater),\n      accessor,\n      transform\n    });\n\n    Object.assign(this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices\n    });\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices() {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false} = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers() {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts) {\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    if (!this.supportsTransition()) {\n      return null;\n    }\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? opts[accessor.find(a => opts[a])]\n      : opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  update(opts) {\n    // backward compatibility\n    this.setData(opts);\n  }\n\n  allocate(numInstances) {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      assert(Number.isFinite(numInstances));\n      super.allocate({\n        numInstances,\n        copy: state.updateRanges !== range.FULL\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({numInstances, data, props, context}) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < this.value.byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n              ? this.value.length\n              : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value) {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer) {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(buffer, startIndices = null) {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    if (ArrayBuffer.isView(buffer)) {\n      buffer = {value: buffer};\n    }\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      assert(ArrayBuffer.isView(buffer.value), `invalid ${settings.accessor}`);\n      const needsNormalize = buffer.size && buffer.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n        size: buffer.size || this.size,\n        stride: buffer.stride,\n        offset: buffer.offset,\n        startIndices,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row) {\n    const {startIndices} = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  _autoUpdater(attribute, {data, startRow, endRow, props, numInstances}) {\n    if (attribute.constant) {\n      return;\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc =\n      state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"],"file":"attribute.js"}