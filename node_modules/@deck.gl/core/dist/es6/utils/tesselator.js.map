{"version":3,"sources":["../../../src/utils/tesselator.js"],"names":["createIterable","getAccessorFromBuffer","defaultTypedArrayManager","assert","Buffer","Tesselator","constructor","opts","attributes","typedArrayManager","indexStarts","vertexStarts","vertexCount","instanceCount","_attributeDefs","updateGeometry","Object","seal","assign","data","buffers","getGeometry","geometryBuffer","positionFormat","dataChanged","normalize","positionSize","size","startIndices","getGeometryFromBuffer","positions","Array","isArray","dataRange","_rebuildGeometry","updatePartialGeometry","startRow","endRow","normalizeGeometry","geometry","updateGeometryAttributes","startIndex","Error","getGeometrySize","value","ArrayBuffer","isView","offset","stride","_allocate","copy","name","release","def","allocate","_forEachGeometry","visitor","iterable","objectInfo","object","index","Infinity","normalizedData","dataIndex","length","buffer","byteStride","byteLength","bufferValue","elementStride","BYTES_PER_ELEMENT","Boolean","context","vertexStart","indexStart","vertexEnd","geometrySize","geometryIndex"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\nimport {createIterable, getAccessorFromBuffer} from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\nimport assert from './assert';\n\nimport {Buffer} from '@luma.gl/core';\n\nexport default class Tesselator {\n  constructor(opts = {}) {\n    const {attributes = {}} = opts;\n\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexStarts = null;\n    this.vertexStarts = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.opts = opts;\n\n    this.updateGeometry(opts);\n\n    Object.seal(this);\n  }\n\n  /* Public methods */\n  updateGeometry(opts) {\n    Object.assign(this.opts, opts);\n    const {\n      data,\n      buffers = {},\n      getGeometry,\n      geometryBuffer,\n      positionFormat,\n      dataChanged,\n      normalize = true\n    } = this.opts;\n    this.data = data;\n    this.getGeometry = getGeometry;\n    this.positionSize =\n      (geometryBuffer && geometryBuffer.size) || (positionFormat === 'XY' ? 2 : 3);\n    this.buffers = buffers;\n    this.normalize = normalize;\n\n    // Handle external logical value\n    if (geometryBuffer) {\n      assert(data.startIndices, 'binary data missing startIndices');\n      this.getGeometry = this.getGeometryFromBuffer(geometryBuffer);\n\n      if (!normalize) {\n        // skip packing and set attribute value directly\n        // TODO - avoid mutating user-provided object\n        buffers.positions = geometryBuffer;\n      }\n    }\n    this.geometryBuffer = buffers.positions;\n\n    if (Array.isArray(dataChanged)) {\n      // is partial update\n      for (const dataRange of dataChanged) {\n        this._rebuildGeometry(dataRange);\n      }\n    } else {\n      this._rebuildGeometry();\n    }\n  }\n\n  updatePartialGeometry({startRow, endRow}) {\n    this._rebuildGeometry({startRow, endRow});\n  }\n\n  /* Subclass interface */\n  normalizeGeometry(geometry) {\n    return geometry;\n  }\n\n  // Update the positions of a single geometry\n  updateGeometryAttributes(geometry, startIndex, size) {\n    throw new Error('Not implemented');\n  }\n\n  // Returns the number of vertices in a geometry\n  getGeometrySize(geometry) {\n    throw new Error('Not implemented');\n  }\n\n  getGeometryFromBuffer(geometryBuffer) {\n    const value = geometryBuffer.value || geometryBuffer;\n    assert(ArrayBuffer.isView(value), 'cannot read geometries');\n\n    return getAccessorFromBuffer(value, {\n      size: this.positionSize,\n      offset: geometryBuffer.offset,\n      stride: geometryBuffer.stride,\n      startIndices: this.data.startIndices\n    });\n  }\n\n  /* Private utility methods */\n  _allocate(instanceCount, copy) {\n    // allocate attributes\n    const {attributes, buffers, _attributeDefs, typedArrayManager} = this;\n    for (const name in _attributeDefs) {\n      if (name in buffers) {\n        // Use external buffer\n        typedArrayManager.release(attributes[name]);\n        attributes[name] = null;\n      } else {\n        const def = _attributeDefs[name];\n        // If dataRange is supplied, this is a partial update.\n        // In case we need to reallocate the typed array, it will need the old values copied\n        // before performing partial update.\n        def.copy = copy;\n\n        attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n      }\n    }\n  }\n\n  /**\n   * Visit all objects\n   * `data` is expected to be an iterable consistent with the base Layer expectation\n   */\n  _forEachGeometry(visitor, startRow, endRow) {\n    const {data, getGeometry} = this;\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n      const geometry = getGeometry(object, objectInfo);\n      visitor(geometry, objectInfo.index);\n    }\n  }\n\n  /* eslint-disable complexity,max-statements */\n  _rebuildGeometry(dataRange) {\n    if (!this.data || !this.getGeometry) {\n      return;\n    }\n\n    let {indexStarts, vertexStarts, instanceCount} = this;\n    const {data, geometryBuffer} = this;\n    const {startRow = 0, endRow = Infinity} = dataRange || {};\n\n    const normalizedData = {};\n\n    if (!dataRange) {\n      // Full update - regenerate buffer layout from scratch\n      indexStarts = [0];\n      vertexStarts = [0];\n    }\n    if (this.normalize || !geometryBuffer) {\n      this._forEachGeometry(\n        (geometry, dataIndex) => {\n          geometry = this.normalizeGeometry(geometry);\n          normalizedData[dataIndex] = geometry;\n          vertexStarts[dataIndex + 1] = vertexStarts[dataIndex] + this.getGeometrySize(geometry);\n        },\n        startRow,\n        endRow\n      );\n      // count instances\n      instanceCount = vertexStarts[vertexStarts.length - 1];\n    } else if (geometryBuffer.buffer instanceof Buffer) {\n      const byteStride = geometryBuffer.stride || this.positionSize * 4;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || geometryBuffer.buffer.byteLength / byteStride;\n    } else {\n      const bufferValue = geometryBuffer.value || geometryBuffer;\n      const elementStride =\n        geometryBuffer.stride / bufferValue.BYTES_PER_ELEMENT || this.positionSize;\n      // assume user provided data is already normalized\n      vertexStarts = data.startIndices;\n      instanceCount = vertexStarts[data.length] || bufferValue.length / elementStride;\n    }\n\n    // allocate attributes\n    this._allocate(instanceCount, Boolean(dataRange));\n\n    this.indexStarts = indexStarts;\n    this.vertexStarts = vertexStarts;\n    this.instanceCount = instanceCount;\n\n    const context = {};\n\n    this._forEachGeometry(\n      (geometry, dataIndex) => {\n        geometry = normalizedData[dataIndex] || geometry;\n        context.vertexStart = vertexStarts[dataIndex];\n        context.indexStart = indexStarts[dataIndex];\n        const vertexEnd =\n          dataIndex < vertexStarts.length - 1 ? vertexStarts[dataIndex + 1] : instanceCount;\n        context.geometrySize = vertexEnd - vertexStarts[dataIndex];\n        context.geometryIndex = dataIndex;\n        this.updateGeometryAttributes(geometry, context);\n      },\n      startRow,\n      endRow\n    );\n\n    this.vertexCount = indexStarts[indexStarts.length - 1];\n  }\n}\n"],"file":"tesselator.js"}