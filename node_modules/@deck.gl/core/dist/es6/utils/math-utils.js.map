{"version":3,"sources":["../../../src/utils/math-utils.js"],"names":["typedArrayManager","Vector3","createMat4","mod","value","divisor","modulus","extractCameraVectors","viewMatrix","viewMatrixInverse","eye","direction","up","right","cameraPosition","cameraDirection","cameraUp","cameraRight","nearCenter","farCenter","a","getFrustumPlanes","aspect","near","far","fovyRadians","position","copy","nearFarScale","len","normalize","widthScale","nearHeight","Math","tan","nearWidth","scale","add","normal","clone","negate","distance","dot","planes","subtract","cross","left","top","bottom","fp64LowPart","x","fround","scratchArray","toDoublePrecisionArray","typedArray","size","startIndex","endIndex","Number","isFinite","length","count","allocate","type","Float32Array","sourceIndex","targetIndex","j","subarray"],"mappings":"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","sourcesContent":["// Extensions to math.gl library. Intended to be folded back.\nimport typedArrayManager from './typed-array-manager';\nimport {Vector3} from 'math.gl';\n\n// Helper, avoids low-precision 32 bit matrices from gl-matrix mat4.create()\nexport function createMat4() {\n  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n}\n\nexport function mod(value, divisor) {\n  const modulus = value % divisor;\n  return modulus < 0 ? divisor + modulus : modulus;\n}\n\n// Extract camera vectors (move to math library?)\nexport function extractCameraVectors({viewMatrix, viewMatrixInverse}) {\n  // Read the translation from the inverse view matrix\n  return {\n    eye: [viewMatrixInverse[12], viewMatrixInverse[13], viewMatrixInverse[14]],\n    direction: [-viewMatrix[2], -viewMatrix[6], -viewMatrix[10]],\n    up: [viewMatrix[1], viewMatrix[5], viewMatrix[9]],\n    right: [viewMatrix[0], viewMatrix[4], viewMatrix[8]]\n  };\n}\n\nconst cameraPosition = new Vector3();\nconst cameraDirection = new Vector3();\nconst cameraUp = new Vector3();\nconst cameraRight = new Vector3();\nconst nearCenter = new Vector3();\nconst farCenter = new Vector3();\nconst a = new Vector3();\n\n/* eslint-disable max-statements */\n\n// Extract frustum planes in common space.\n// Note that common space is left-handed\n// (with y pointing down)\nexport function getFrustumPlanes({aspect, near, far, fovyRadians, position, direction, up, right}) {\n  cameraDirection.copy(direction);\n\n  // Account for any scaling of the z axis (e.g. in\n  // mercator view matrix)\n  const nearFarScale = 1 / cameraDirection.len();\n  cameraDirection.normalize();\n\n  cameraPosition.copy(position);\n\n  cameraUp.copy(up);\n  // Account for scaling of the xy axis\n  const widthScale = 1 / cameraUp.len();\n  cameraUp.normalize();\n  cameraRight.copy(right).normalize();\n\n  const nearHeight = 2 * Math.tan(fovyRadians / 2) * near * widthScale;\n  const nearWidth = nearHeight * aspect;\n\n  nearCenter\n    .copy(cameraDirection)\n    .scale(near * nearFarScale)\n    .add(cameraPosition);\n  farCenter\n    .copy(cameraDirection)\n    .scale(far * nearFarScale)\n    .add(cameraPosition);\n\n  let normal = cameraDirection.clone().negate();\n  let distance = normal.dot(nearCenter);\n\n  const planes = {\n    near: {\n      distance,\n      normal\n    },\n    far: {\n      distance: cameraDirection.dot(farCenter),\n      normal: cameraDirection.clone()\n    }\n  };\n\n  a.copy(cameraRight)\n    .scale(nearWidth * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(a).cross(cameraUp);\n  distance = cameraPosition.dot(normal);\n  planes.right = {normal, distance};\n\n  a.copy(cameraRight)\n    .scale(-nearWidth * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(cameraUp).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.left = {normal, distance};\n\n  a.copy(cameraUp)\n    .scale(nearHeight * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(cameraRight).cross(a);\n  distance = cameraPosition.dot(normal);\n  planes.top = {normal, distance};\n\n  a.copy(cameraUp)\n    .scale(-nearHeight * 0.5)\n    .add(nearCenter)\n    .subtract(cameraPosition)\n    .normalize();\n  normal = new Vector3(a).cross(cameraRight);\n  distance = cameraPosition.dot(normal);\n  planes.bottom = {normal, distance};\n\n  return planes;\n}\n\n/**\n * Calculate the low part of a WebGL 64 bit float\n * @param x {number} - the input float number\n * @returns {number} - the lower 32 bit of the number\n */\nexport function fp64LowPart(x) {\n  return x - Math.fround(x);\n}\n\nlet scratchArray;\n\n/**\n * Split a Float64Array into a double-length Float32Array\n * @param typedArray {Float64Array}\n * @param size {Number} - per attribute size\n * @param [startIndex] {Number} - start index in the source array\n * @param [endIndex] {Number} - end index in the source array\n * @returns {Float32Array} - high part, low part for each attribute:\n    [1xHi, 1yHi, 1zHi, 1xLow, 1yLow, 1zLow, 2xHi, ...]\n */\nexport function toDoublePrecisionArray(typedArray, {size = 1, startIndex = 0, endIndex}) {\n  if (!Number.isFinite(endIndex)) {\n    endIndex = typedArray.length;\n  }\n  const count = (endIndex - startIndex) / size;\n  scratchArray = typedArrayManager.allocate(scratchArray, count, {\n    type: Float32Array,\n    size: size * 2\n  });\n\n  let sourceIndex = startIndex;\n  let targetIndex = 0;\n  while (sourceIndex < endIndex) {\n    for (let j = 0; j < size; j++) {\n      const value = typedArray[sourceIndex++];\n      scratchArray[targetIndex + j] = value;\n      scratchArray[targetIndex + j + size] = fp64LowPart(value);\n    }\n    targetIndex += size * 2;\n  }\n\n  return scratchArray.subarray(0, count * size * 2);\n}\n"],"file":"math-utils.js"}