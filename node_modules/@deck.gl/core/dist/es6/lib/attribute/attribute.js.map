{"version":3,"sources":["../../../../src/lib/attribute/attribute.js"],"names":["DataColumn","assert","createIterable","getAccessorFromBuffer","fillArray","range","normalizeTransitionSettings","Attribute","constructor","gl","opts","transition","noAlloc","update","accessor","transform","startIndices","Object","assign","settings","_autoUpdater","state","lastExternalBuffer","binaryValue","binaryAccessor","needsUpdate","needsRedraw","updateRanges","FULL","seal","_validateAttributeUpdaters","layout","clearChangedFlags","getUpdateTriggers","id","concat","supportsTransition","Boolean","getTransitionSetting","layerSettings","userSettings","Array","isArray","find","a","setNeedsUpdate","reason","dataRange","setNeedsRedraw","startRow","endRow","Infinity","add","clearNeedsUpdate","EMPTY","setData","allocate","numInstances","Number","isFinite","copy","updateBuffer","data","props","context","updated","call","value","constant","buffer","byteLength","byteOffset","startOffset","getVertexOffset","endOffset","length","size","updateSubBuffer","_checkAttributeArray","setConstantValue","undefined","hasChanged","setExternalBuffer","setBinaryValue","ArrayBuffer","isView","needsNormalize","stride","offset","nested","row","vertexIndex","getShaderAttributes","shaderAttributeDefs","shaderAttributes","shaderAttributeName","attribute","accessorFunc","i","iterable","objectInfo","object","index","objectValue","numVertices","startIndex","item","_normalizeValue","set","target","source","start","count","hasUpdater","Error","limit","Math","min","valid"],"mappings":"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","sourcesContent":["/* eslint-disable complexity */\nimport DataColumn from './data-column';\nimport assert from '../../utils/assert';\nimport {createIterable, getAccessorFromBuffer} from '../../utils/iterable-utils';\nimport {fillArray} from '../../utils/flatten';\nimport * as range from '../../utils/range';\nimport {normalizeTransitionSettings} from './attribute-transition-utils';\n\nexport default class Attribute extends DataColumn {\n  constructor(gl, opts = {}) {\n    super(gl, opts);\n\n    const {\n      // deck.gl fields\n      transition = false,\n      noAlloc = false,\n      update = null,\n      accessor = null,\n      transform = null,\n      startIndices = null\n    } = opts;\n\n    Object.assign(this.settings, {\n      transition,\n      noAlloc,\n      update: update || (accessor && this._autoUpdater),\n      accessor,\n      transform\n    });\n\n    Object.assign(this.state, {\n      lastExternalBuffer: null,\n      binaryValue: null,\n      binaryAccessor: null,\n      needsUpdate: true,\n      needsRedraw: false,\n      updateRanges: range.FULL,\n      startIndices\n    });\n\n    Object.seal(this.settings);\n    Object.seal(this.state);\n\n    // Check all fields and generate helpful error messages\n    this._validateAttributeUpdaters();\n  }\n\n  get startIndices() {\n    return this.state.startIndices;\n  }\n\n  set startIndices(layout) {\n    this.state.startIndices = layout;\n  }\n\n  needsUpdate() {\n    return this.state.needsUpdate;\n  }\n\n  needsRedraw({clearChangedFlags = false} = {}) {\n    const needsRedraw = this.state.needsRedraw;\n    this.state.needsRedraw = needsRedraw && !clearChangedFlags;\n    return needsRedraw;\n  }\n\n  getUpdateTriggers() {\n    const {accessor} = this.settings;\n\n    // Backards compatibility: allow attribute name to be used as update trigger key\n    return [this.id].concat((typeof accessor !== 'function' && accessor) || []);\n  }\n\n  supportsTransition() {\n    return Boolean(this.settings.transition);\n  }\n\n  // Resolve transition settings object if transition is enabled, otherwise `null`\n  getTransitionSetting(opts) {\n    const {accessor} = this.settings;\n    // TODO: have the layer resolve these transition settings itself?\n    const layerSettings = this.settings.transition;\n    if (!this.supportsTransition()) {\n      return null;\n    }\n    // these are the transition settings passed in by the user\n    const userSettings = Array.isArray(accessor)\n      ? opts[accessor.find(a => opts[a])]\n      : opts[accessor];\n\n    // Shorthand: use duration instead of parameter object\n    return normalizeTransitionSettings(userSettings, layerSettings);\n  }\n\n  setNeedsUpdate(reason = this.id, dataRange) {\n    this.state.needsUpdate = this.state.needsUpdate || reason;\n    this.setNeedsRedraw(reason);\n    if (dataRange) {\n      const {startRow = 0, endRow = Infinity} = dataRange;\n      this.state.updateRanges = range.add(this.state.updateRanges, [startRow, endRow]);\n    } else {\n      this.state.updateRanges = range.FULL;\n    }\n  }\n\n  clearNeedsUpdate() {\n    this.state.needsUpdate = false;\n    this.state.updateRanges = range.EMPTY;\n  }\n\n  setNeedsRedraw(reason = this.id) {\n    this.state.needsRedraw = this.state.needsRedraw || reason;\n  }\n\n  update(opts) {\n    // backward compatibility\n    this.setData(opts);\n  }\n\n  allocate(numInstances) {\n    const {state, settings} = this;\n\n    if (settings.noAlloc) {\n      // Data is provided through a Buffer object.\n      return false;\n    }\n\n    if (settings.update) {\n      assert(Number.isFinite(numInstances));\n      super.allocate({\n        numInstances,\n        copy: state.updateRanges !== range.FULL\n      });\n      return true;\n    }\n\n    return false;\n  }\n\n  updateBuffer({numInstances, data, props, context}) {\n    if (!this.needsUpdate()) {\n      return false;\n    }\n\n    const {\n      state: {updateRanges},\n      settings: {update, noAlloc}\n    } = this;\n\n    let updated = true;\n    if (update) {\n      // Custom updater - typically for non-instanced layers\n      for (const [startRow, endRow] of updateRanges) {\n        update.call(context, this, {data, startRow, endRow, props, numInstances});\n      }\n      if (!this.value) {\n        // no value was assigned during update\n      } else if (\n        this.constant ||\n        this.buffer.byteLength < this.value.byteLength + this.byteOffset\n      ) {\n        this.setData({\n          value: this.value,\n          constant: this.constant\n        });\n      } else {\n        for (const [startRow, endRow] of updateRanges) {\n          const startOffset = Number.isFinite(startRow) ? this.getVertexOffset(startRow) : 0;\n          const endOffset = Number.isFinite(endRow)\n            ? this.getVertexOffset(endRow)\n            : noAlloc || !Number.isFinite(numInstances)\n              ? this.value.length\n              : numInstances * this.size;\n\n          super.updateSubBuffer({startOffset, endOffset});\n        }\n      }\n      this._checkAttributeArray();\n    } else {\n      updated = false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setNeedsRedraw();\n\n    return updated;\n  }\n\n  // Use generic value\n  // Returns true if successful\n  setConstantValue(value) {\n    if (value === undefined || typeof value === 'function') {\n      return false;\n    }\n\n    const hasChanged = this.setData({constant: true, value});\n\n    if (hasChanged) {\n      this.setNeedsRedraw();\n    }\n    this.clearNeedsUpdate();\n    return true;\n  }\n\n  // Use external buffer\n  // Returns true if successful\n  // eslint-disable-next-line max-statements\n  setExternalBuffer(buffer) {\n    const {state} = this;\n\n    if (!buffer) {\n      state.lastExternalBuffer = null;\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n\n    if (state.lastExternalBuffer === buffer) {\n      return true;\n    }\n    state.lastExternalBuffer = buffer;\n    this.setNeedsRedraw();\n    this.setData(buffer);\n    return true;\n  }\n\n  // Binary value is a typed array packed from mapping the source data with the accessor\n  // If the returned value from the accessor is the same as the attribute value, set it directly\n  // Otherwise use the auto updater for transform/normalization\n  setBinaryValue(buffer, startIndices = null) {\n    const {state, settings} = this;\n\n    if (!buffer) {\n      state.binaryValue = null;\n      state.binaryAccessor = null;\n      return false;\n    }\n\n    if (settings.noAlloc) {\n      // Let the layer handle this\n      return false;\n    }\n\n    if (state.binaryValue === buffer) {\n      this.clearNeedsUpdate();\n      return true;\n    }\n    state.binaryValue = buffer;\n    this.setNeedsRedraw();\n\n    if (ArrayBuffer.isView(buffer)) {\n      buffer = {value: buffer};\n    }\n    const needsUpdate = settings.transform || startIndices !== this.startIndices;\n\n    if (needsUpdate) {\n      assert(ArrayBuffer.isView(buffer.value), `invalid ${settings.accessor}`);\n      const needsNormalize = buffer.size && buffer.size !== this.size;\n\n      state.binaryAccessor = getAccessorFromBuffer(buffer.value, {\n        size: buffer.size || this.size,\n        stride: buffer.stride,\n        offset: buffer.offset,\n        startIndices,\n        nested: needsNormalize\n      });\n      // Fall through to auto updater\n      return false;\n    }\n\n    this.clearNeedsUpdate();\n    this.setData(buffer);\n    return true;\n  }\n\n  getVertexOffset(row) {\n    const {startIndices} = this;\n    const vertexIndex = startIndices ? startIndices[row] : row;\n    return vertexIndex * this.size;\n  }\n\n  getShaderAttributes() {\n    const shaderAttributeDefs = this.settings.shaderAttributes || {[this.id]: null};\n    const shaderAttributes = {};\n\n    for (const shaderAttributeName in shaderAttributeDefs) {\n      Object.assign(\n        shaderAttributes,\n        super.getShaderAttributes(shaderAttributeName, shaderAttributeDefs[shaderAttributeName])\n      );\n    }\n\n    return shaderAttributes;\n  }\n\n  /* eslint-disable max-depth, max-statements */\n  _autoUpdater(attribute, {data, startRow, endRow, props, numInstances}) {\n    if (attribute.constant) {\n      return;\n    }\n    const {settings, state, value, size, startIndices} = attribute;\n\n    const {accessor, transform} = settings;\n    const accessorFunc =\n      state.binaryAccessor || (typeof accessor === 'function' ? accessor : props[accessor]);\n\n    assert(typeof accessorFunc === 'function', `accessor \"${accessor}\" is not a function`);\n\n    let i = attribute.getVertexOffset(startRow);\n    const {iterable, objectInfo} = createIterable(data, startRow, endRow);\n    for (const object of iterable) {\n      objectInfo.index++;\n\n      let objectValue = accessorFunc(object, objectInfo);\n      if (transform) {\n        // transform callbacks could be bound to a particular layer instance.\n        // always point `this` to the current layer.\n        objectValue = transform.call(this, objectValue);\n      }\n\n      if (startIndices) {\n        const numVertices =\n          (objectInfo.index < startIndices.length - 1\n            ? startIndices[objectInfo.index + 1]\n            : numInstances) - startIndices[objectInfo.index];\n        if (objectValue && Array.isArray(objectValue[0])) {\n          let startIndex = i;\n          for (const item of objectValue) {\n            attribute._normalizeValue(item, value, startIndex);\n            startIndex += size;\n          }\n        } else if (objectValue && objectValue.length > size) {\n          value.set(objectValue, i);\n        } else {\n          attribute._normalizeValue(objectValue, objectInfo.target, 0);\n          fillArray({\n            target: value,\n            source: objectInfo.target,\n            start: i,\n            count: numVertices\n          });\n        }\n        i += numVertices * size;\n      } else {\n        attribute._normalizeValue(objectValue, value, i);\n        i += size;\n      }\n    }\n  }\n  /* eslint-enable max-depth, max-statements */\n\n  // Validate deck.gl level fields\n  _validateAttributeUpdaters() {\n    const {settings} = this;\n\n    // Check that 'update' is a valid function\n    const hasUpdater = settings.noAlloc || typeof settings.update === 'function';\n    if (!hasUpdater) {\n      throw new Error(`Attribute ${this.id} missing update or accessor`);\n    }\n  }\n\n  // check that the first few elements of the attribute are reasonable\n  /* eslint-disable no-fallthrough */\n  _checkAttributeArray() {\n    const {value} = this;\n    const limit = Math.min(4, this.size);\n    if (value && value.length >= limit) {\n      let valid = true;\n      switch (limit) {\n        case 4:\n          valid = valid && Number.isFinite(value[3]);\n        case 3:\n          valid = valid && Number.isFinite(value[2]);\n        case 2:\n          valid = valid && Number.isFinite(value[1]);\n        case 1:\n          valid = valid && Number.isFinite(value[0]);\n          break;\n        default:\n          valid = false;\n      }\n\n      if (!valid) {\n        throw new Error(`Illegal attribute generated for ${this.id}`);\n      }\n    }\n  }\n  /* eslint-enable no-fallthrough */\n}\n"],"file":"attribute.js"}