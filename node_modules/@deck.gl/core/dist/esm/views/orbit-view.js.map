{"version":3,"sources":["../../../src/views/orbit-view.js"],"names":["View","Viewport","Matrix4","OrbitController","DEGREES_TO_RADIANS","Math","PI","getViewMatrix","height","fovy","orbitAxis","rotationX","rotationOrbit","zoom","distance","tan","up","eye","viewMatrix","lookAt","rotateX","rotateZ","rotateY","projectionScale","pow","scale","OrbitViewport","props","id","x","y","width","near","far","target","position","OrbitView","Object","assign","type","_getControllerProps","displayName"],"mappings":"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","sourcesContent":["import View from './view';\nimport Viewport from '../viewports/viewport';\n\nimport {Matrix4} from 'math.gl';\nimport OrbitController from '../controllers/orbit-controller';\n\nconst DEGREES_TO_RADIANS = Math.PI / 180;\n\nfunction getViewMatrix({height, fovy, orbitAxis, rotationX, rotationOrbit, zoom}) {\n  // We position the camera so that one common space unit (world space unit scaled by zoom)\n  // at the target maps to one screen pixel.\n  // This is a similar technique to that used in web mercator projection\n  // By doing so we are able to convert between common space and screen space sizes efficiently\n  // in the vertex shader.\n  const distance = 0.5 / Math.tan((fovy * DEGREES_TO_RADIANS) / 2);\n  const up = orbitAxis === 'Z' ? [0, 0, 1] : [0, 1, 0];\n  const eye = orbitAxis === 'Z' ? [0, -distance, 0] : [0, 0, distance];\n\n  const viewMatrix = new Matrix4().lookAt({eye, up});\n\n  viewMatrix.rotateX(rotationX * DEGREES_TO_RADIANS);\n  if (orbitAxis === 'Z') {\n    viewMatrix.rotateZ(rotationOrbit * DEGREES_TO_RADIANS);\n  } else {\n    viewMatrix.rotateY(rotationOrbit * DEGREES_TO_RADIANS);\n  }\n\n  // When height increases, we need to increase the distance from the camera to the target to\n  // keep the 1:1 mapping. However, this also changes the projected depth of each position by\n  // moving them further away between the near/far plane.\n  // Without modifying the default near/far planes, we instead scale down the common space to\n  // remove the distortion to the depth field.\n  const projectionScale = Math.pow(2, zoom) / (height || 1);\n  viewMatrix.scale(projectionScale);\n\n  return viewMatrix;\n}\n\nclass OrbitViewport extends Viewport {\n  constructor(props) {\n    const {\n      id,\n      x,\n      y,\n      width,\n      height,\n\n      fovy = 50, // From eye position to lookAt\n      near,\n      far,\n      orbitAxis = 'Z', // Orbit axis with 360 degrees rotating freedom, can only be 'Y' or 'Z'\n      target = [0, 0, 0], // Which point is camera looking at, default origin\n\n      rotationX = 0, // Rotating angle around X axis\n      rotationOrbit = 0, // Rotating angle around orbit axis\n\n      zoom = 0\n    } = props;\n\n    super({\n      id,\n      viewMatrix: getViewMatrix({\n        height,\n        fovy,\n        orbitAxis,\n        rotationX,\n        rotationOrbit,\n        zoom\n      }),\n      fovy,\n      near,\n      far,\n      x,\n      y,\n      position: target,\n      width,\n      height,\n      zoom\n    });\n  }\n}\n\nexport default class OrbitView extends View {\n  constructor(props) {\n    super(\n      Object.assign({}, props, {\n        type: OrbitViewport\n      })\n    );\n  }\n\n  get controller() {\n    return this._getControllerProps({\n      type: OrbitController\n    });\n  }\n}\n\nOrbitView.displayName = 'OrbitView';\n"],"file":"orbit-view.js"}