{"version":3,"sources":["../../../src/lib/axis-aligned-bounding-box.js"],"names":["Vector3","INTERSECTION","scratchVector","scratchNormal","AxisAlignedBoundingBox","minimum","maximum","center","copy","add","scale","halfDiagonal","subtract","right","Boolean","equals","plane","normal","from","e","x","Math","abs","y","z","s","dot","distance","INSIDE","OUTSIDE","INTERSECTING","point","sqrt","distanceSquaredTo","offset","distanceSquared","d"],"mappings":"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","sourcesContent":["import {Vector3} from '@math.gl/core';\nimport {INTERSECTION} from '../constants';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\n\nexport default class AxisAlignedBoundingBox {\n  constructor(minimum = [0, 0, 0], maximum = [0, 0, 0], center = null) {\n    // If center was not defined, compute it.\n    center =\n      center ||\n      scratchVector\n        .copy(minimum)\n        .add(maximum)\n        .scale(0.5);\n    /**\n     * The center point of the bounding box.\n     * @type {Vector3}\n     */\n    this.center = new Vector3(center);\n    /**\n     * The positive half diagonal of the bounding box.\n     * @type {Vector3}\n     */\n    this.halfDiagonal = new Vector3(maximum).subtract(this.center);\n\n    /**\n     * The minimum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.minimum = new Vector3(minimum);\n\n    /**\n     * The maximum point defining the bounding box.\n     * @type {Vector3}\n     * @default {@link 0, 0, 0}\n     */\n    this.maximum = new Vector3(maximum);\n  }\n\n  /**\n   * Duplicates a AxisAlignedBoundingBox instance.\n   *\n   * @returns {AxisAlignedBoundingBox} A new AxisAlignedBoundingBox instance.\n   */\n  clone() {\n    return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);\n  }\n\n  /**\n   * Compares the provided AxisAlignedBoundingBox componentwise and returns\n   * <code>true</code> if they are equal, <code>false</code> otherwise.\n   *\n   * @param {AxisAlignedBoundingBox} [right] The second AxisAlignedBoundingBox to compare with.\n   * @returns {Boolean} <code>true</code> if left and right are equal, <code>false</code> otherwise.\n   */\n  equals(right) {\n    return (\n      this === right ||\n      (Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum))\n    );\n  }\n\n  /**\n   * Determines which side of a plane a box is located.\n   */\n  intersectPlane(plane) {\n    const {halfDiagonal} = this;\n    const normal = scratchNormal.from(plane.normal);\n    const e =\n      halfDiagonal.x * Math.abs(normal.x) +\n      halfDiagonal.y * Math.abs(normal.y) +\n      halfDiagonal.z * Math.abs(normal.z);\n    const s = this.center.dot(normal) + plane.distance; // signed distance from center\n\n    if (s - e > 0) {\n      return INTERSECTION.INSIDE;\n    }\n\n    if (s + e < 0) {\n      // Not in front because normals point inward\n      return INTERSECTION.OUTSIDE;\n    }\n\n    return INTERSECTION.INTERSECTING;\n  }\n\n  // Computes the estimated distance from the closest point on a bounding box to a point.\n  distanceTo(point) {\n    return Math.sqrt(this.distanceSquaredTo(point));\n  }\n\n  // Computes the estimated distance squared from the closest point on a bounding box to a point.\n  // A simplified version of OrientedBoundingBox.distanceSquaredTo\n  distanceSquaredTo(point) {\n    const offset = scratchVector.from(point).subtract(this.center);\n    const {halfDiagonal} = this;\n\n    let distanceSquared = 0.0;\n    let d;\n\n    d = Math.abs(offset.x) - halfDiagonal.x;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.y) - halfDiagonal.y;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    d = Math.abs(offset.z) - halfDiagonal.z;\n    if (d > 0) {\n      distanceSquared += d * d;\n    }\n\n    return distanceSquared;\n  }\n}\n"],"file":"axis-aligned-bounding-box.js"}