import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { Vector3 } from '@math.gl/core';
import { INTERSECTION } from '../constants';
var scratchVector = new Vector3();
var scratchNormal = new Vector3();

var AxisAlignedBoundingBox = function () {
  function AxisAlignedBoundingBox() {
    var minimum = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [0, 0, 0];
    var maximum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
    var center = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

    _classCallCheck(this, AxisAlignedBoundingBox);

    center = center || scratchVector.copy(minimum).add(maximum).scale(0.5);
    this.center = new Vector3(center);
    this.halfDiagonal = new Vector3(maximum).subtract(this.center);
    this.minimum = new Vector3(minimum);
    this.maximum = new Vector3(maximum);
  }

  _createClass(AxisAlignedBoundingBox, [{
    key: "clone",
    value: function clone() {
      return new AxisAlignedBoundingBox(this.minimum, this.maximum, this.center);
    }
  }, {
    key: "equals",
    value: function equals(right) {
      return this === right || Boolean(right) && this.minimum.equals(right.minimum) && this.maximum.equals(right.maximum);
    }
  }, {
    key: "intersectPlane",
    value: function intersectPlane(plane) {
      var halfDiagonal = this.halfDiagonal;
      var normal = scratchNormal.from(plane.normal);
      var e = halfDiagonal.x * Math.abs(normal.x) + halfDiagonal.y * Math.abs(normal.y) + halfDiagonal.z * Math.abs(normal.z);
      var s = this.center.dot(normal) + plane.distance;

      if (s - e > 0) {
        return INTERSECTION.INSIDE;
      }

      if (s + e < 0) {
        return INTERSECTION.OUTSIDE;
      }

      return INTERSECTION.INTERSECTING;
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(point) {
      return Math.sqrt(this.distanceSquaredTo(point));
    }
  }, {
    key: "distanceSquaredTo",
    value: function distanceSquaredTo(point) {
      var offset = scratchVector.from(point).subtract(this.center);
      var halfDiagonal = this.halfDiagonal;
      var distanceSquared = 0.0;
      var d;
      d = Math.abs(offset.x) - halfDiagonal.x;

      if (d > 0) {
        distanceSquared += d * d;
      }

      d = Math.abs(offset.y) - halfDiagonal.y;

      if (d > 0) {
        distanceSquared += d * d;
      }

      d = Math.abs(offset.z) - halfDiagonal.z;

      if (d > 0) {
        distanceSquared += d * d;
      }

      return distanceSquared;
    }
  }]);

  return AxisAlignedBoundingBox;
}();

export { AxisAlignedBoundingBox as default };
//# sourceMappingURL=axis-aligned-bounding-box.js.map