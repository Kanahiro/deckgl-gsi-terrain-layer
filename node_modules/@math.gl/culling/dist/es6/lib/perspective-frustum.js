import { assert } from '@math.gl/core';
import PerspectiveOffCenterFrustum from './perspective-off-center-frustum';

const defined = val => val !== null && typeof val !== 'undefined';

export default class PerspectiveFrustum {
  constructor(options = {}) {
    options = {
      near: 1.0,
      far: 500000000.0,
      xOffset: 0.0,
      yOffset: 0.0,
      ...options
    };
    this._offCenterFrustum = new PerspectiveOffCenterFrustum();
    this.fov = options.fov;
    this._fov = undefined;
    this._fovy = undefined;
    this._sseDenominator = undefined;
    this.aspectRatio = options.aspectRatio;
    this._aspectRatio = undefined;
    this.near = options.near;
    this._near = this.near;
    this.far = options.far;
    this._far = this.far;
    this.xOffset = options.xOffset;
    this._xOffset = this.xOffset;
    this.yOffset = options.yOffset;
    this._yOffset = this.yOffset;
  }

  clone() {
    return new PerspectiveFrustum({
      aspectRatio: this.aspectRatio,
      fov: this.fov,
      near: this.near,
      far: this.far
    });
  }

  equals(other) {
    if (!defined(other) || !(other instanceof PerspectiveFrustum)) {
      return false;
    }

    update(this);
    update(other);
    return this.fov === other.fov && this.aspectRatio === other.aspectRatio && this.near === other.near && this.far === other.far && this._offCenterFrustum.equals(other._offCenterFrustum);
  }

  get projectionMatrix() {
    update(this);
    return this._offCenterFrustum.projectionMatrix;
  }

  get infiniteProjectionMatrix() {
    update(this);
    return this._offCenterFrustum.infiniteProjectionMatrix;
  }

  get fovy() {
    update(this);
    return this._fovy;
  }

  get sseDenominator() {
    update(this);
    return this._sseDenominator;
  }

  computeCullingVolume(position, direction, up) {
    update(this);
    return this._offCenterFrustum.computeCullingVolume(position, direction, up);
  }

  getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result) {
    update(this);
    return this._offCenterFrustum.getPixelDimensions(drawingBufferWidth, drawingBufferHeight, distance, result);
  }

}

function update(frustum) {
  assert(Number.isFinite(frustum.fov) && Number.isFinite(frustum.aspectRatio) && Number.isFinite(frustum.near) && Number.isFinite(frustum.far));
  const f = frustum._offCenterFrustum;

  if (frustum.fov !== frustum._fov || frustum.aspectRatio !== frustum._aspectRatio || frustum.near !== frustum._near || frustum.far !== frustum._far || frustum.xOffset !== frustum._xOffset || frustum.yOffset !== frustum._yOffset) {
    assert(frustum.fov >= 0 && frustum.fov < Math.PI);
    assert(frustum.aspectRatio > 0);
    assert(frustum.near >= 0 && frustum.near < frustum.far);
    frustum._aspectRatio = frustum.aspectRatio;
    frustum._fov = frustum.fov;
    frustum._fovy = frustum.aspectRatio <= 1 ? frustum.fov : Math.atan(Math.tan(frustum.fov * 0.5) / frustum.aspectRatio) * 2.0;
    frustum._near = frustum.near;
    frustum._far = frustum.far;
    frustum._sseDenominator = 2.0 * Math.tan(0.5 * frustum._fovy);
    frustum._xOffset = frustum.xOffset;
    frustum._yOffset = frustum.yOffset;
    f.top = frustum.near * Math.tan(0.5 * frustum._fovy);
    f.bottom = -f.top;
    f.right = frustum.aspectRatio * f.top;
    f.left = -f.right;
    f.near = frustum.near;
    f.far = frustum.far;
    f.right += frustum.xOffset;
    f.left += frustum.xOffset;
    f.top += frustum.yOffset;
    f.bottom += frustum.yOffset;
  }
}
//# sourceMappingURL=perspective-frustum.js.map