import _typeof from "@babel/runtime/helpers/esm/typeof";
import _construct from "@babel/runtime/helpers/esm/construct";
import _toConsumableArray from "@babel/runtime/helpers/esm/toConsumableArray";
import assert from './assert';
var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
var config = {};
config.EPSILON = 1e-12;
config.debug = false;
config.precision = 4;
config.printTypes = false;
config.printDegrees = false;
config.printRowMajor = true;
export { config };
export function configure() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var key in options) {
    assert(key in config);
    config[key] = options[key];
  }

  return config;
}

function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}

export function formatValue(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$precision = _ref.precision,
      precision = _ref$precision === void 0 ? config.precision || 4 : _ref$precision;

  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision)));
}
export function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && !(value instanceof DataView);
}

function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}

export function clone(array) {
  return array.clone ? array.clone() : _construct(Array, _toConsumableArray(array));
}

function map(value, func, result) {
  if (isArray(value)) {
    result = result || duplicateArray(value);

    for (var i = 0; i < result.length && i < value.length; ++i) {
      result[i] = func(value[i], i, result);
    }

    return result;
  }

  return func(value);
}

export function toRadians(degrees) {
  return radians(degrees);
}
export function toDegrees(radians) {
  return degrees(radians);
}
export function radians(degrees, result) {
  return map(degrees, function (degrees) {
    return degrees * DEGREES_TO_RADIANS;
  }, result);
}
export function degrees(radians, result) {
  return map(radians, function (radians) {
    return radians * RADIANS_TO_DEGREES;
  }, result);
}
export function sin(radians) {
  return map(radians, function (angle) {
    return Math.sin(angle);
  });
}
export function cos(radians) {
  return map(radians, function (angle) {
    return Math.cos(angle);
  });
}
export function tan(radians) {
  return map(radians, function (angle) {
    return Math.tan(angle);
  });
}
export function asin(radians) {
  return map(radians, function (angle) {
    return Math.asin(angle);
  });
}
export function acos(radians) {
  return map(radians, function (angle) {
    return Math.acos(angle);
  });
}
export function atan(radians) {
  return map(radians, function (angle) {
    return Math.atan(angle);
  });
}
export function clamp(value, min, max) {
  return map(value, function (value) {
    return Math.max(min, Math.min(max, value));
  });
}
export function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map(function (ai, i) {
      return lerp(ai, b[i], t);
    });
  }

  return t * b + (1 - t) * a;
}
export function equals(a, b, epsilon) {
  var oldEpsilon = config.EPSILON;

  if (epsilon) {
    config.EPSILON = epsilon;
  }

  try {
    if (a === b) {
      return true;
    }

    if (isArray(a) && isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }

      for (var i = 0; i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    if (a && a.equals) {
      return a.equals(b);
    }

    if (b && b.equals) {
      return b.equals(a);
    }

    if (Number.isFinite(a) && Number.isFinite(b)) {
      return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
    }

    return false;
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
export function exactEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (a && _typeof(a) === 'object' && b && _typeof(b) === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }

    if (a.exactEquals) {
      return a.exactEquals(b);
    }
  }

  if (isArray(a) && isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; ++i) {
      if (!exactEquals(a[i], b[i])) {
        return false;
      }
    }

    return true;
  }

  return false;
}
export function withEpsilon(EPSILON, func) {
  var oldPrecision = config.EPSILON;
  config.EPSILON = EPSILON;
  var value;

  try {
    value = func();
  } finally {
    config.EPSILON = oldPrecision;
  }

  return value;
}
//# sourceMappingURL=common.js.map