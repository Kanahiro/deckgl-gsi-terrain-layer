import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { formatValue, equals as _equals, config } from '../lib/common';
import { degrees, radians, clamp } from '../lib/common';
import Vector3 from './vector3';
import * as vec3 from 'gl-matrix/vec3';
var EPSILON = 0.000001;
var EARTH_RADIUS_METERS = 6.371e6;

var SphericalCoordinates = function () {
  function SphericalCoordinates() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$phi = _ref.phi,
        phi = _ref$phi === void 0 ? 0 : _ref$phi,
        _ref$theta = _ref.theta,
        theta = _ref$theta === void 0 ? 0 : _ref$theta,
        _ref$radius = _ref.radius,
        radius = _ref$radius === void 0 ? 1 : _ref$radius,
        _ref$bearing = _ref.bearing,
        bearing = _ref$bearing === void 0 ? undefined : _ref$bearing,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === void 0 ? undefined : _ref$pitch,
        _ref$altitude = _ref.altitude,
        altitude = _ref$altitude === void 0 ? undefined : _ref$altitude,
        _ref$radiusScale = _ref.radiusScale,
        radiusScale = _ref$radiusScale === void 0 ? EARTH_RADIUS_METERS : _ref$radiusScale;

    _classCallCheck(this, SphericalCoordinates);

    this.phi = phi;
    this.theta = theta;
    this.radius = radius || altitude || 1;
    this.radiusScale = radiusScale || 1;

    if (bearing !== undefined) {
      this.bearing = bearing;
    }

    if (pitch !== undefined) {
      this.pitch = pitch;
    }

    this.check();
  }

  _createClass(SphericalCoordinates, [{
    key: "toString",
    value: function toString() {
      return this.formatString(config);
    }
  }, {
    key: "formatString",
    value: function formatString(_ref2) {
      var _ref2$printTypes = _ref2.printTypes,
          printTypes = _ref2$printTypes === void 0 ? false : _ref2$printTypes;
      var f = formatValue;
      return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return _equals(this.radius, other.radius) && _equals(this.theta, other.theta) && _equals(this.phi, other.phi);
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(other) {
      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
    }
  }, {
    key: "set",
    value: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this.check();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new SphericalCoordinates().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this.check();
    }
  }, {
    key: "fromLngLatZ",
    value: function fromLngLatZ(_ref3) {
      var _ref4 = _slicedToArray(_ref3, 3),
          lng = _ref4[0],
          lat = _ref4[1],
          z = _ref4[2];

      this.radius = 1 + z / this.radiusScale;
      this.phi = radians(lat);
      this.theta = radians(lng);
    }
  }, {
    key: "fromVector3",
    value: function fromVector3(v) {
      this.radius = vec3.length(v);

      if (this.radius > 0) {
        this.theta = Math.atan2(v[0], v[1]);
        this.phi = Math.acos(clamp(v[2] / this.radius, -1, 1));
      }

      return this.check();
    }
  }, {
    key: "toVector3",
    value: function toVector3() {
      return new Vector3(0, 0, this.radius).rotateX({
        radians: this.theta
      }).rotateZ({
        radians: this.phi
      });
    }
  }, {
    key: "makeSafe",
    value: function makeSafe() {
      this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
      return this;
    }
  }, {
    key: "check",
    value: function check() {
      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
        throw new Error('SphericalCoordinates: some fields set to invalid numbers');
      }

      return this;
    }
  }, {
    key: "bearing",
    get: function get() {
      return 180 - degrees(this.phi);
    },
    set: function set(v) {
      this.phi = Math.PI - radians(v);
    }
  }, {
    key: "pitch",
    get: function get() {
      return degrees(this.theta);
    },
    set: function set(v) {
      this.theta = radians(v);
    }
  }, {
    key: "longitude",
    get: function get() {
      return degrees(this.phi);
    }
  }, {
    key: "latitude",
    get: function get() {
      return degrees(this.theta);
    }
  }, {
    key: "lng",
    get: function get() {
      return degrees(this.phi);
    }
  }, {
    key: "lat",
    get: function get() {
      return degrees(this.theta);
    }
  }, {
    key: "z",
    get: function get() {
      return (this.radius - 1) * this.radiusScale;
    }
  }]);

  return SphericalCoordinates;
}();

export { SphericalCoordinates as default };
//# sourceMappingURL=spherical-coordinates.js.map