import { push, copy, getPointAtIndex } from './utils';
export function clipPolyline(positions, bbox) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$size = options.size,
      size = _options$size === void 0 ? 2 : _options$size,
      _options$startIndex = options.startIndex,
      startIndex = _options$startIndex === void 0 ? 0 : _options$startIndex,
      _options$endIndex = options.endIndex,
      endIndex = _options$endIndex === void 0 ? positions.length : _options$endIndex;
  var numPoints = (endIndex - startIndex) / size;
  var result = [];
  var part = [];
  var a;
  var b;
  var codeA = -1;
  var codeB;
  var lastCode;

  for (var i = 1; i < numPoints; i++) {
    a = getPointAtIndex(positions, i - 1, size, startIndex, a);
    b = getPointAtIndex(positions, i, size, startIndex, b);

    if (codeA < 0) {
      codeA = bitCode(a, bbox);
    }

    codeB = lastCode = bitCode(b, bbox);

    while (true) {
      if (!(codeA | codeB)) {
        push(part, a);

        if (codeB !== lastCode) {
          push(part, b);

          if (i < numPoints - 1) {
            result.push(part);
            part = [];
          }
        } else if (i === numPoints - 1) {
          push(part, b);
        }

        break;
      } else if (codeA & codeB) {
        break;
      } else if (codeA) {
        intersect(a, b, codeA, bbox, a);
        codeA = bitCode(a, bbox);
      } else {
        intersect(a, b, codeB, bbox, b);
        codeB = bitCode(b, bbox);
      }
    }

    codeA = lastCode;
  }

  if (part.length) result.push(part);
  return result;
}
export function clipPolygon(positions, bbox) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var _options$size2 = options.size,
      size = _options$size2 === void 0 ? 2 : _options$size2,
      _options$endIndex2 = options.endIndex,
      endIndex = _options$endIndex2 === void 0 ? positions.length : _options$endIndex2;
  var _options$startIndex2 = options.startIndex,
      startIndex = _options$startIndex2 === void 0 ? 0 : _options$startIndex2;
  var numPoints = (endIndex - startIndex) / size;
  var result;
  var p;
  var prev;
  var inside;
  var prevInside;

  for (var edge = 1; edge <= 8; edge *= 2) {
    result = [];
    prev = getPointAtIndex(positions, numPoints - 1, size, startIndex, prev);
    prevInside = !(bitCode(prev, bbox) & edge);

    for (var i = 0; i < numPoints; i++) {
      p = getPointAtIndex(positions, i, size, startIndex, p);
      inside = !(bitCode(p, bbox) & edge);
      if (inside !== prevInside) push(result, intersect(prev, p, edge, bbox));
      if (inside) push(result, p);
      copy(prev, p);
      prevInside = inside;
    }

    positions = result;
    startIndex = 0;
    numPoints = result.length / size;
    if (!numPoints) break;
  }

  return result;
}
export function intersect(a, b, edge, bbox) {
  var out = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
  var t;
  var snap;

  if (edge & 8) {
    t = (bbox[3] - a[1]) / (b[1] - a[1]);
    snap = 3;
  } else if (edge & 4) {
    t = (bbox[1] - a[1]) / (b[1] - a[1]);
    snap = 1;
  } else if (edge & 2) {
    t = (bbox[2] - a[0]) / (b[0] - a[0]);
    snap = 2;
  } else if (edge & 1) {
    t = (bbox[0] - a[0]) / (b[0] - a[0]);
    snap = 0;
  } else {
    return null;
  }

  for (var i = 0; i < a.length; i++) {
    out[i] = (snap & 1) === i ? bbox[snap] : t * b[i] + (1 - t) * a[i];
  }

  return out;
}
export function bitCode(p, bbox) {
  var code = 0;
  if (p[0] < bbox[0]) code |= 1;else if (p[0] > bbox[2]) code |= 2;
  if (p[1] < bbox[1]) code |= 4;else if (p[1] > bbox[3]) code |= 8;
  return code;
}
//# sourceMappingURL=lineclip.js.map