{"version":3,"sources":["../../src/cut-by-grid.js"],"names":["bitCode","intersect","getPointAtIndex","copy","push","cutPolylineByGrid","positions","options","size","broken","gridResolution","gridOffset","startIndex","endIndex","length","numPoints","part","result","a","b","codeB","cell","getGridCell","scratchPoint","i","codeAlt","moveToNeighborCell","TYPE_INSIDE","TYPE_BORDER","cutPolygonByGrid","holeIndices","edgeTypes","queue","pos","types","Array","fill","holes","bbox","shift","getBoundingBox","code","parts","bisectPolygon","polygonLow","polygonHigh","concat","polygon","edge","resultLow","resultHigh","typesLow","typesHigh","p","side","type","prev","prevSide","Math","sign","prevType","lowPointCount","highPointCount","out","left","floor","bottom","minX","Infinity","maxX","minY","maxY","x","y"],"mappings":"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","sourcesContent":["/* eslint-disable max-statements, max-depth, complexity, no-unused-expressions */\nimport {bitCode, intersect} from './lineclip';\nimport {getPointAtIndex, copy, push} from './utils';\n\nexport function cutPolylineByGrid(positions, options = {}) {\n  const {\n    size = 2,\n    broken = false,\n    gridResolution = 10,\n    gridOffset = [0, 0],\n    startIndex = 0,\n    endIndex = positions.length\n  } = options;\n  const numPoints = (endIndex - startIndex) / size;\n  let part = [];\n  const result = [part];\n  const a = getPointAtIndex(positions, 0, size, startIndex);\n  let b;\n  let codeB;\n  const cell = getGridCell(a, gridResolution, gridOffset, []);\n  const scratchPoint = [];\n  push(part, a);\n\n  for (let i = 1; i < numPoints; i++) {\n    b = getPointAtIndex(positions, i, size, startIndex, b);\n    codeB = bitCode(b, cell);\n\n    while (codeB) {\n      // find the intersection with the current cell\n      intersect(a, b, codeB, cell, scratchPoint);\n      const codeAlt = bitCode(scratchPoint, cell);\n      if (codeAlt) {\n        intersect(a, scratchPoint, codeAlt, cell, scratchPoint);\n        codeB = codeAlt;\n      }\n      push(part, scratchPoint);\n      // move to the next cell\n      copy(a, scratchPoint);\n\n      moveToNeighborCell(cell, gridResolution, codeB);\n      if (broken && part.length > size) {\n        part = [];\n        result.push(part);\n        push(part, a);\n      }\n\n      codeB = bitCode(b, cell);\n    }\n\n    push(part, b);\n    copy(a, b);\n  }\n\n  return broken ? result : result[0];\n}\n\nconst TYPE_INSIDE = 0;\nconst TYPE_BORDER = 1;\n\nexport function cutPolygonByGrid(positions, holeIndices, options = {}) {\n  if (!positions.length) {\n    // input is empty\n    return [];\n  }\n  const {size = 2, gridResolution = 10, gridOffset = [0, 0], edgeTypes = false} = options;\n  const result = [];\n  const queue = [\n    {\n      pos: positions,\n      types: edgeTypes && new Array(positions.length / size).fill(TYPE_BORDER),\n      holes: holeIndices || []\n    }\n  ];\n  const bbox = [[], []];\n  let cell = [];\n\n  // Recursively bisect polygon until every part fit in a single grid cell\n  while (queue.length) {\n    const {pos, types, holes} = queue.shift();\n\n    // Get the bounding box of the outer polygon\n    getBoundingBox(pos, size, holes[0] || pos.length, bbox);\n    cell = getGridCell(bbox[0], gridResolution, gridOffset, cell);\n    const code = bitCode(bbox[1], cell);\n\n    if (code) {\n      // Split the outer ring at the boundary\n      let parts = bisectPolygon(pos, types, size, 0, holes[0] || pos.length, cell, code);\n      const polygonLow = {pos: parts[0].pos, types: parts[0].types, holes: []};\n      const polygonHigh = {pos: parts[1].pos, types: parts[1].types, holes: []};\n      queue.push(polygonLow, polygonHigh);\n\n      // Split each hole at the boundary\n      for (let i = 0; i < holes.length; i++) {\n        parts = bisectPolygon(pos, types, size, holes[i], holes[i + 1] || pos.length, cell, code);\n\n        if (parts[0]) {\n          polygonLow.holes.push(polygonLow.pos.length);\n          polygonLow.pos = polygonLow.pos.concat(parts[0].pos);\n          if (edgeTypes) {\n            polygonLow.types = polygonLow.types.concat(parts[0].types);\n          }\n        }\n        if (parts[1]) {\n          polygonHigh.holes.push(polygonHigh.pos.length);\n          polygonHigh.pos = polygonHigh.pos.concat(parts[1].pos);\n          if (edgeTypes) {\n            polygonHigh.types = polygonHigh.types.concat(parts[1].types);\n          }\n        }\n      }\n    } else {\n      // Polygon fits in a single cell, no more processing required\n      const polygon = {positions: pos};\n      if (edgeTypes) {\n        polygon.edgeTypes = types;\n      }\n      if (holes.length) {\n        polygon.holeIndices = holes;\n      }\n\n      result.push(polygon);\n    }\n  }\n  return result;\n}\n\n// edgeTypes:\n// TYPE_BORDER - edge from the original polygon\n// TYPE_INSIDE - inside the original polygon\n// eslint-disable-next-line max-params\nfunction bisectPolygon(positions, edgeTypes, size, startIndex, endIndex, bbox, edge) {\n  const numPoints = (endIndex - startIndex) / size;\n  const resultLow = [];\n  const resultHigh = [];\n  const typesLow = [];\n  const typesHigh = [];\n  const scratchPoint = [];\n\n  let p;\n  let side;\n  let type;\n  const prev = getPointAtIndex(positions, numPoints - 1, size, startIndex);\n  let prevSide = Math.sign(edge & 8 ? prev[1] - bbox[3] : prev[0] - bbox[2]);\n  let prevType = edgeTypes && edgeTypes[numPoints - 1];\n  let lowPointCount = 0;\n  let highPointCount = 0;\n\n  for (let i = 0; i < numPoints; i++) {\n    p = getPointAtIndex(positions, i, size, startIndex, p);\n    side = Math.sign(edge & 8 ? p[1] - bbox[3] : p[0] - bbox[2]);\n    type = edgeTypes && edgeTypes[startIndex / size + i];\n\n    // if segment goes through the boundary, add an intersection\n    if (side && prevSide && prevSide !== side) {\n      intersect(prev, p, edge, bbox, scratchPoint);\n      push(resultLow, scratchPoint) && typesLow.push(prevType);\n      push(resultHigh, scratchPoint) && typesHigh.push(prevType);\n    }\n\n    if (side <= 0) {\n      push(resultLow, p) && typesLow.push(type);\n      lowPointCount -= side;\n    } else if (typesLow.length) {\n      typesLow[typesLow.length - 1] = TYPE_INSIDE;\n    }\n    if (side >= 0) {\n      push(resultHigh, p) && typesHigh.push(type);\n      highPointCount += side;\n    } else if (typesHigh.length) {\n      typesHigh[typesHigh.length - 1] = TYPE_INSIDE;\n    }\n\n    copy(prev, p);\n    prevSide = side;\n    prevType = type;\n  }\n\n  return [\n    lowPointCount ? {pos: resultLow, types: edgeTypes && typesLow} : null,\n    highPointCount ? {pos: resultHigh, types: edgeTypes && typesHigh} : null\n  ];\n}\n\nfunction getGridCell(p, gridResolution, gridOffset, out) {\n  const left = Math.floor((p[0] - gridOffset[0]) / gridResolution) * gridResolution + gridOffset[0];\n  const bottom =\n    Math.floor((p[1] - gridOffset[1]) / gridResolution) * gridResolution + gridOffset[1];\n  out[0] = left;\n  out[1] = bottom;\n  out[2] = left + gridResolution;\n  out[3] = bottom + gridResolution;\n  return out;\n}\n\nfunction moveToNeighborCell(cell, gridResolution, edge) {\n  if (edge & 8) {\n    // top\n    cell[1] += gridResolution;\n    cell[3] += gridResolution;\n  } else if (edge & 4) {\n    // bottom\n    cell[1] -= gridResolution;\n    cell[3] -= gridResolution;\n  } else if (edge & 2) {\n    // right\n    cell[0] += gridResolution;\n    cell[2] += gridResolution;\n  } else if (edge & 1) {\n    // left\n    cell[0] -= gridResolution;\n    cell[2] -= gridResolution;\n  }\n}\n\nfunction getBoundingBox(positions, size, endIndex, out) {\n  let minX = Infinity;\n  let maxX = -Infinity;\n  let minY = Infinity;\n  let maxY = -Infinity;\n\n  for (let i = 0; i < endIndex; i += size) {\n    const x = positions[i];\n    const y = positions[i + 1];\n    minX = x < minX ? x : minX;\n    maxX = x > maxX ? x : maxX;\n    minY = y < minY ? y : minY;\n    maxY = y > maxY ? y : maxY;\n  }\n\n  out[0][0] = minX;\n  out[0][1] = minY;\n  out[1][0] = maxX;\n  out[1][1] = maxY;\n  return out;\n}\n"],"file":"cut-by-grid.js"}