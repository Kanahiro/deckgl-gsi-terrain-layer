import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _classCallCheck from "@babel/runtime/helpers/esm/classCallCheck";
import _createClass from "@babel/runtime/helpers/esm/createClass";
import { Vector3, Matrix4, toRadians, toDegrees, assert, equals, _MathUtils } from '@math.gl/core';
import * as vec3 from 'gl-matrix/vec3';
import { WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z } from '../constants';
import { fromCartographicToRadians, toCartographicFromRadians } from '../type-utils';
import _scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';
import _localFrameToFixedFrame from './helpers/ellipsoid-transform';
var scratchVector = new Vector3();
var scratchNormal = new Vector3();
var scratchK = new Vector3();
var scratchPosition = new Vector3();
var scratchHeight = new Vector3();
var scratchCartesian = new Vector3();
var wgs84;

var Ellipsoid = function () {
  _createClass(Ellipsoid, null, [{
    key: "WGS84",
    get: function get() {
      wgs84 = wgs84 || new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);
      return wgs84;
    }
  }]);

  function Ellipsoid() {
    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.0;

    _classCallCheck(this, Ellipsoid);

    assert(x >= 0.0);
    assert(y >= 0.0);
    assert(z >= 0.0);
    this.radii = new Vector3(x, y, z);
    this.radiiSquared = new Vector3(x * x, y * y, z * z);
    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);
    this.oneOverRadii = new Vector3(x === 0.0 ? 0.0 : 1.0 / x, y === 0.0 ? 0.0 : 1.0 / y, z === 0.0 ? 0.0 : 1.0 / z);
    this.oneOverRadiiSquared = new Vector3(x === 0.0 ? 0.0 : 1.0 / (x * x), y === 0.0 ? 0.0 : 1.0 / (y * y), z === 0.0 ? 0.0 : 1.0 / (z * z));
    this.minimumRadius = Math.min(x, y, z);
    this.maximumRadius = Math.max(x, y, z);
    this.centerToleranceSquared = _MathUtils.EPSILON1;

    if (this.radiiSquared.z !== 0) {
      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;
    }

    Object.freeze(this);
  }

  _createClass(Ellipsoid, [{
    key: "equals",
    value: function equals(right) {
      return this === right || Boolean(right && this.radii.equals(right.radii));
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.radii.toString();
    }
  }, {
    key: "cartographicToCartesian",
    value: function cartographicToCartesian(cartographic) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      var normal = scratchNormal;
      var k = scratchK;

      var _cartographic = _slicedToArray(cartographic, 3),
          height = _cartographic[2];

      this.geodeticSurfaceNormalCartographic(cartographic, normal);
      k.copy(this.radiiSquared).scale(normal);
      var gamma = Math.sqrt(normal.dot(k));
      k.scale(1 / gamma);
      normal.scale(height);
      k.add(normal);
      return k.to(result);
    }
  }, {
    key: "cartesianToCartographic",
    value: function cartesianToCartographic(cartesian) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      scratchCartesian.from(cartesian);
      var point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);

      if (!point) {
        return undefined;
      }

      var normal = this.geodeticSurfaceNormal(point, scratchNormal);
      var h = scratchHeight;
      h.copy(scratchCartesian).subtract(point);
      var longitude = Math.atan2(normal.y, normal.x);
      var latitude = Math.asin(normal.z);
      var height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);
      return toCartographicFromRadians([longitude, latitude, height], result);
    }
  }, {
    key: "eastNorthUpToFixedFrame",
    value: function eastNorthUpToFixedFrame(origin) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Matrix4();
      return _localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);
    }
  }, {
    key: "localFrameToFixedFrame",
    value: function localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin) {
      var result = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Matrix4();
      return _localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);
    }
  }, {
    key: "geocentricSurfaceNormal",
    value: function geocentricSurfaceNormal(cartesian) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      return scratchVector.from(cartesian).normalize().to(result);
    }
  }, {
    key: "geodeticSurfaceNormalCartographic",
    value: function geodeticSurfaceNormalCartographic(cartographic) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      var cartographicVectorRadians = fromCartographicToRadians(cartographic);
      var longitude = cartographicVectorRadians[0];
      var latitude = cartographicVectorRadians[1];
      var cosLatitude = Math.cos(latitude);
      scratchVector.set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude)).normalize();
      return scratchVector.to(result);
    }
  }, {
    key: "geodeticSurfaceNormal",
    value: function geodeticSurfaceNormal(cartesian) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      return scratchVector.from(cartesian).scale(this.oneOverRadiiSquared).normalize().to(result);
    }
  }, {
    key: "scaleToGeodeticSurface",
    value: function scaleToGeodeticSurface(cartesian, result) {
      return _scaleToGeodeticSurface(cartesian, this, result);
    }
  }, {
    key: "scaleToGeocentricSurface",
    value: function scaleToGeocentricSurface(cartesian) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      scratchPosition.from(cartesian);
      var positionX = scratchPosition.x;
      var positionY = scratchPosition.y;
      var positionZ = scratchPosition.z;
      var oneOverRadiiSquared = this.oneOverRadiiSquared;
      var beta = 1.0 / Math.sqrt(positionX * positionX * oneOverRadiiSquared.x + positionY * positionY * oneOverRadiiSquared.y + positionZ * positionZ * oneOverRadiiSquared.z);
      return scratchPosition.multiplyScalar(beta).to(result);
    }
  }, {
    key: "transformPositionToScaledSpace",
    value: function transformPositionToScaledSpace(position) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      return scratchPosition.from(position).scale(this.oneOverRadii).to(result);
    }
  }, {
    key: "transformPositionFromScaledSpace",
    value: function transformPositionFromScaledSpace(position) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0, 0];
      return scratchPosition.from(position).scale(this.radii).to(result);
    }
  }, {
    key: "getSurfaceNormalIntersectionWithZAxis",
    value: function getSurfaceNormalIntersectionWithZAxis(position) {
      var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.0;
      var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0];
      assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));
      assert(this.radii.z > 0);
      scratchPosition.from(position);
      var z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);

      if (Math.abs(z) >= this.radii.z - buffer) {
        return undefined;
      }

      return scratchPosition.set(0.0, 0.0, z).to(result);
    }
  }]);

  return Ellipsoid;
}();

export { Ellipsoid as default };
//# sourceMappingURL=ellipsoid.js.map