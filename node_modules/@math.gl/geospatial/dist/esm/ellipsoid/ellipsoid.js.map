{"version":3,"sources":["../../../src/ellipsoid/ellipsoid.js"],"names":["Vector3","Matrix4","toRadians","toDegrees","assert","equals","_MathUtils","vec3","WGS84_RADIUS_X","WGS84_RADIUS_Y","WGS84_RADIUS_Z","fromCartographicToRadians","toCartographicFromRadians","scaleToGeodeticSurface","localFrameToFixedFrame","scratchVector","scratchNormal","scratchK","scratchPosition","scratchHeight","scratchCartesian","wgs84","Ellipsoid","x","y","z","radii","radiiSquared","radiiToTheFourth","oneOverRadii","oneOverRadiiSquared","minimumRadius","Math","min","maximumRadius","max","centerToleranceSquared","EPSILON1","squaredXOverSquaredZ","Object","freeze","right","Boolean","toString","cartographic","result","normal","k","height","geodeticSurfaceNormalCartographic","copy","scale","gamma","sqrt","dot","add","to","cartesian","from","point","undefined","geodeticSurfaceNormal","h","subtract","longitude","atan2","latitude","asin","sign","length","origin","firstAxis","secondAxis","thirdAxis","normalize","cartographicVectorRadians","cosLatitude","cos","set","sin","positionX","positionY","positionZ","beta","multiplyScalar","position","buffer","EPSILON15","abs"],"mappings":"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","sourcesContent":["// This file is derived from the Cesium math library under Apache 2 license\n// See LICENSE.md and https://github.com/AnalyticalGraphicsInc/cesium/blob/master/LICENSE.md\n\n/* eslint-disable */\nimport {Vector3, Matrix4, toRadians, toDegrees, assert, equals, _MathUtils} from '@math.gl/core';\nimport * as vec3 from 'gl-matrix/vec3';\n\nimport {WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z} from '../constants';\nimport {fromCartographicToRadians, toCartographicFromRadians} from '../type-utils';\n\nimport scaleToGeodeticSurface from './helpers/scale-to-geodetic-surface';\nimport localFrameToFixedFrame from './helpers/ellipsoid-transform';\n\nconst scratchVector = new Vector3();\nconst scratchNormal = new Vector3();\nconst scratchK = new Vector3();\nconst scratchPosition = new Vector3();\nconst scratchHeight = new Vector3();\nconst scratchCartesian = new Vector3();\n\nlet wgs84;\n\n// A quadratic surface defined in Cartesian coordinates by the equation\n// <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used\n// to represent the shape of planetary bodies.\nexport default class Ellipsoid {\n  // An Ellipsoid instance initialized to the WGS84 standard.\n  static get WGS84() {\n    wgs84 = wgs84 || new Ellipsoid(WGS84_RADIUS_X, WGS84_RADIUS_Y, WGS84_RADIUS_Z);\n    return wgs84;\n  }\n\n  // Creates an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.\n  constructor(x = 0.0, y = 0.0, z = 0.0) {\n    assert(x >= 0.0);\n    assert(y >= 0.0);\n    assert(z >= 0.0);\n\n    this.radii = new Vector3(x, y, z);\n\n    this.radiiSquared = new Vector3(x * x, y * y, z * z);\n\n    this.radiiToTheFourth = new Vector3(x * x * x * x, y * y * y * y, z * z * z * z);\n\n    this.oneOverRadii = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / x,\n      y === 0.0 ? 0.0 : 1.0 / y,\n      z === 0.0 ? 0.0 : 1.0 / z\n    );\n\n    this.oneOverRadiiSquared = new Vector3(\n      x === 0.0 ? 0.0 : 1.0 / (x * x),\n      y === 0.0 ? 0.0 : 1.0 / (y * y),\n      z === 0.0 ? 0.0 : 1.0 / (z * z)\n    );\n\n    this.minimumRadius = Math.min(x, y, z);\n\n    this.maximumRadius = Math.max(x, y, z);\n\n    this.centerToleranceSquared = _MathUtils.EPSILON1;\n\n    if (this.radiiSquared.z !== 0) {\n      this.squaredXOverSquaredZ = this.radiiSquared.x / this.radiiSquared.z;\n    }\n\n    Object.freeze(this);\n  }\n\n  // Compares this Ellipsoid against the provided Ellipsoid componentwise and returns\n  equals(right) {\n    return this === right || Boolean(right && this.radii.equals(right.radii));\n  }\n\n  // Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.\n  toString() {\n    return this.radii.toString();\n  }\n\n  // Converts the provided cartographic to Cartesian representation.\n  cartographicToCartesian(cartographic, result = [0, 0, 0]) {\n    const normal = scratchNormal;\n    const k = scratchK;\n\n    const [, , height] = cartographic;\n    this.geodeticSurfaceNormalCartographic(cartographic, normal);\n    k.copy(this.radiiSquared).scale(normal);\n\n    const gamma = Math.sqrt(normal.dot(k));\n    k.scale(1 / gamma);\n\n    normal.scale(height);\n\n    k.add(normal);\n\n    return k.to(result);\n  }\n\n  // Converts the provided cartesian to cartographic (lng/lat/z) representation.\n  // The cartesian is undefined at the center of the ellipsoid.\n  cartesianToCartographic(cartesian, result = [0, 0, 0]) {\n    scratchCartesian.from(cartesian);\n    const point = this.scaleToGeodeticSurface(scratchCartesian, scratchPosition);\n\n    if (!point) {\n      return undefined;\n    }\n\n    const normal = this.geodeticSurfaceNormal(point, scratchNormal);\n\n    const h = scratchHeight;\n    h.copy(scratchCartesian).subtract(point);\n\n    const longitude = Math.atan2(normal.y, normal.x);\n    const latitude = Math.asin(normal.z);\n    const height = Math.sign(vec3.dot(h, scratchCartesian)) * vec3.length(h);\n\n    return toCartographicFromRadians([longitude, latitude, height], result);\n  }\n\n  // Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes\n  // centered at the provided origin to the provided ellipsoid's fixed reference frame.\n  eastNorthUpToFixedFrame(origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, 'east', 'north', 'up', origin, result);\n  }\n\n  // Computes a 4x4 transformation matrix from a reference frame centered at\n  // the provided origin to the ellipsoid's fixed reference frame.\n  localFrameToFixedFrame(firstAxis, secondAxis, thirdAxis, origin, result = new Matrix4()) {\n    return localFrameToFixedFrame(this, firstAxis, secondAxis, thirdAxis, origin, result);\n  }\n\n  // Computes the unit vector directed from the center of this ellipsoid toward\n  // the provided Cartesian position.\n  geocentricSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector\n      .from(cartesian)\n      .normalize()\n      .to(result);\n  }\n\n  // Computes the normal of the plane tangent to the surface of the ellipsoid at provided position.\n  geodeticSurfaceNormalCartographic(cartographic, result = [0, 0, 0]) {\n    const cartographicVectorRadians = fromCartographicToRadians(cartographic);\n\n    const longitude = cartographicVectorRadians[0];\n    const latitude = cartographicVectorRadians[1];\n\n    const cosLatitude = Math.cos(latitude);\n\n    scratchVector\n      .set(cosLatitude * Math.cos(longitude), cosLatitude * Math.sin(longitude), Math.sin(latitude))\n      .normalize();\n\n    return scratchVector.to(result);\n  }\n\n  // Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.\n  geodeticSurfaceNormal(cartesian, result = [0, 0, 0]) {\n    return scratchVector\n      .from(cartesian)\n      .scale(this.oneOverRadiiSquared)\n      .normalize()\n      .to(result);\n  }\n\n  // Scales the provided Cartesian position along the geodetic surface normal\n  // so that it is on the surface of this ellipsoid.  If the position is\n  // at the center of the ellipsoid, this function returns undefined.\n  scaleToGeodeticSurface(cartesian, result) {\n    return scaleToGeodeticSurface(cartesian, this, result);\n  }\n\n  // Scales the provided Cartesian position along the geocentric surface normal\n  // so that it is on the surface of this ellipsoid.\n  scaleToGeocentricSurface(cartesian, result = [0, 0, 0]) {\n    scratchPosition.from(cartesian);\n\n    const positionX = scratchPosition.x;\n    const positionY = scratchPosition.y;\n    const positionZ = scratchPosition.z;\n    const oneOverRadiiSquared = this.oneOverRadiiSquared;\n\n    const beta =\n      1.0 /\n      Math.sqrt(\n        positionX * positionX * oneOverRadiiSquared.x +\n          positionY * positionY * oneOverRadiiSquared.y +\n          positionZ * positionZ * oneOverRadiiSquared.z\n      );\n\n    return scratchPosition.multiplyScalar(beta).to(result);\n  }\n\n  // Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying\n  // its components by the result of `Ellipsoid#oneOverRadii`\n  transformPositionToScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition\n      .from(position)\n      .scale(this.oneOverRadii)\n      .to(result);\n  }\n\n  // Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying\n  // its components by the result of `Ellipsoid#radii`.\n  transformPositionFromScaledSpace(position, result = [0, 0, 0]) {\n    return scratchPosition\n      .from(position)\n      .scale(this.radii)\n      .to(result);\n  }\n\n  // Computes a point which is the intersection of the surface normal with the z-axis.\n  getSurfaceNormalIntersectionWithZAxis(position, buffer = 0.0, result = [0, 0, 0]) {\n    // Ellipsoid must be an ellipsoid of revolution (radii.x == radii.y)\n    assert(equals(this.radii.x, this.radii.y, _MathUtils.EPSILON15));\n    assert(this.radii.z > 0);\n\n    scratchPosition.from(position);\n    const z = scratchPosition.z * (1 - this.squaredXOverSquaredZ);\n\n    if (Math.abs(z) >= this.radii.z - buffer) {\n      return undefined;\n    }\n\n    return scratchPosition.set(0.0, 0.0, z).to(result);\n  }\n}\n"],"file":"ellipsoid.js"}