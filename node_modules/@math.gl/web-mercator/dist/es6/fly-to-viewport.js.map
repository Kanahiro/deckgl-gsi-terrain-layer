{"version":3,"sources":["../../src/fly-to-viewport.js"],"names":["lerp","scaleToZoom","zoomToScale","lngLatToWorld","worldToLngLat","vec2","EPSILON","VIEWPORT_TRANSITION_PROPS","DEFAULT_OPTS","curve","speed","flyToViewport","startProps","endProps","t","opts","viewport","startZoom","startCenterXY","uDelta","w0","u1","S","rho","rho2","r0","getFlyToTransitionParams","key","startValue","endValue","s","w","Math","cosh","u","tanh","sinh","scaleIncrement","newZoom","newCenterWorld","scale","add","newCenter","longitude","latitude","zoom","getFlyToDuration","Object","assign","screenSpeed","maxDuration","length","duration","Number","isFinite","startCenter","startScale","endZoom","endCenter","endCenterXY","sub","max","width","height","w1","_u1","b0","b1","log","sqrt","r1"],"mappings":"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","sourcesContent":["import {lerp} from './math-utils';\nimport {scaleToZoom, zoomToScale, lngLatToWorld, worldToLngLat} from './web-mercator-utils';\nimport * as vec2 from 'gl-matrix/vec2';\n\nconst EPSILON = 0.01;\nconst VIEWPORT_TRANSITION_PROPS = ['longitude', 'latitude', 'zoom'];\nconst DEFAULT_OPTS = {\n  curve: 1.414,\n  speed: 1.2\n  // screenSpeed and maxDuration are used only if specified\n};\n\n/**\n * mapbox-gl-js flyTo : https://www.mapbox.com/mapbox-gl-js/api/#map#flyto.\n * It implements “Smooth and efficient zooming and panning.” algorithm by\n * \"Jarke J. van Wijk and Wim A.A. Nuij\"\n */\nexport default function flyToViewport(startProps, endProps, t, opts = {}) {\n  // Equations from above paper are referred where needed.\n\n  const viewport = {};\n\n  const {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0} = getFlyToTransitionParams(\n    startProps,\n    endProps,\n    opts\n  );\n\n  // If change in center is too small, do linear interpolaiton.\n  if (u1 < EPSILON) {\n    for (const key of VIEWPORT_TRANSITION_PROPS) {\n      const startValue = startProps[key];\n      const endValue = endProps[key];\n      viewport[key] = lerp(startValue, endValue, t);\n    }\n    return viewport;\n  }\n\n  const s = t * S;\n\n  const w = Math.cosh(r0) / Math.cosh(r0 + rho * s);\n  const u = (w0 * ((Math.cosh(r0) * Math.tanh(r0 + rho * s) - Math.sinh(r0)) / rho2)) / u1;\n\n  const scaleIncrement = 1 / w; // Using w method for scaling.\n  const newZoom = startZoom + scaleToZoom(scaleIncrement);\n\n  const newCenterWorld = vec2.scale([], uDelta, u);\n  vec2.add(newCenterWorld, newCenterWorld, startCenterXY);\n\n  const newCenter = worldToLngLat(newCenterWorld);\n  viewport.longitude = newCenter[0];\n  viewport.latitude = newCenter[1];\n  viewport.zoom = newZoom;\n  return viewport;\n}\n\n// returns transition duration in milliseconds\nexport function getFlyToDuration(startProps, endProps, opts = {}) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const {screenSpeed, speed, maxDuration} = opts;\n  const {S, rho} = getFlyToTransitionParams(startProps, endProps, opts);\n  const length = 1000 * S;\n  let duration;\n  if (Number.isFinite(screenSpeed)) {\n    duration = length / (screenSpeed / rho);\n  } else {\n    duration = length / speed;\n  }\n\n  return Number.isFinite(maxDuration) && duration > maxDuration ? 0 : duration;\n}\n\n// Private Methods\n\n// Calculate all parameters that are static for given startProps and endProps\nfunction getFlyToTransitionParams(startProps, endProps, opts) {\n  opts = Object.assign({}, DEFAULT_OPTS, opts);\n  const rho = opts.curve;\n  const startZoom = startProps.zoom;\n  const startCenter = [startProps.longitude, startProps.latitude];\n  const startScale = zoomToScale(startZoom);\n  const endZoom = endProps.zoom;\n  const endCenter = [endProps.longitude, endProps.latitude];\n  const scale = zoomToScale(endZoom - startZoom);\n\n  const startCenterXY = lngLatToWorld(startCenter);\n  const endCenterXY = lngLatToWorld(endCenter);\n  const uDelta = vec2.sub([], endCenterXY, startCenterXY);\n\n  const w0 = Math.max(startProps.width, startProps.height);\n  const w1 = w0 / scale;\n  const u1 = vec2.length(uDelta) * startScale;\n  // u0 is treated as '0' in Eq (9).\n\n  // If u1 is too small, will generate invalid number\n  const _u1 = Math.max(u1, EPSILON);\n\n  // Implement Equation (9) from above algorithm.\n  const rho2 = rho * rho;\n  const b0 = (w1 * w1 - w0 * w0 + rho2 * rho2 * _u1 * _u1) / (2 * w0 * rho2 * _u1);\n  const b1 = (w1 * w1 - w0 * w0 - rho2 * rho2 * _u1 * _u1) / (2 * w1 * rho2 * _u1);\n  const r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0);\n  const r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\n  const S = (r1 - r0) / rho;\n\n  return {startZoom, startCenterXY, uDelta, w0, u1, S, rho, rho2, r0, r1};\n}\n"],"file":"fly-to-viewport.js"}